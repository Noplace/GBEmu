; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?num@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::num
PUBLIC	?den@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::den
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_monotonic@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_monotonic
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?is_steady@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_steady
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	ConcRT_ProviderGuid
PUBLIC	ConcRTEventGuid
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	SchedulerEventGuid
PUBLIC	ScheduleGroupEventGuid
PUBLIC	ContextEventGuid
PUBLIC	ChoreEventGuid
PUBLIC	VirtualProcessorEventGuid
PUBLIC	LockEventGuid
PUBLIC	ResourceManagerEventGuid
PUBLIC	PPLParallelInvokeEventGuid
PUBLIC	PPLParallelForEventGuid
PUBLIC	PPLParallelForeachEventGuid
PUBLIC	AgentEventGuid
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?value@?$integral_constant@_K$0A@@std@@2_KB	; std::integral_constant<unsigned __int64,0>::value
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?value@?$integral_constant@H$0A@@std@@2HB	; std::integral_constant<int,0>::value
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB		; std::_GcdX<10000000,1>::value
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB		; std::_GcdX<1,10000000>::value
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB		; std::_Gcd<1,10000000>::value
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?num@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::num
PUBLIC	?den@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::den
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?value@?$_Abs@$0GE@@std@@2_JB			; std::_Abs<100>::value
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?value@?$_Abs@$0DLJKMKAA@@std@@2_JB		; std::_Abs<1000000000>::value
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
PUBLIC	?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
PUBLIC	?value@?$_GcdX@$0GE@$0A@@std@@2_JB		; std::_GcdX<100,0>::value
PUBLIC	?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
PUBLIC	?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB	; std::_GcdX<1000000000,100>::value
PUBLIC	?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<100,1000000000>::value
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<100,1000000000>::value
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?value@?$_Abs@$00@std@@2_JB			; std::_Abs<1>::value
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_GcdX@$00$0A@@std@@2_JB		; std::_GcdX<1,0>::value
PUBLIC	?value@?$_GcdX@$00$00@std@@2_JB			; std::_GcdX<1,1>::value
PUBLIC	?value@?$_Gcd@$00$00@std@@2_JB			; std::_Gcd<1,1>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
PUBLIC	?is_monotonic@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_monotonic
PUBLIC	?is_steady@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_steady
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
PUBLIC	?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
PUBLIC	?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_nonNull
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelException
PUBLIC	?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_notInlined
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_structured
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_localCancel
PUBLIC	?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_reserved
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
PUBLIC	?value@?$_Abs@$0JIJGIA@@std@@2_JB		; std::_Abs<10000000>::value
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB		; std::_GcdX<10000000,0>::value
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_GcdX<10000000,10000000>::value
PUBLIC	?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Gcd<10000000,10000000>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0JIJGIA@@std@@2_JB DQ 0000000000989680H	; std::_Abs<10000000>::value
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_reserved
CONST	ENDS
;	COMDAT ?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_localCancel
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_structured
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB DD 0ffffffffH ; Concurrency::details::_TaskCollectionBase::_S_notInlined
CONST	ENDS
;	COMDAT ?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB DQ 000000000000000cH ; Concurrency::details::_TaskCollectionBase::_S_cancelException
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000008H ; Concurrency::details::_TaskCollectionBase::_S_nonNull
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000003H ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
CONST	ENDS
;	COMDAT ?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000002H ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000001H ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000000H ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
CONST	ENDS
;	COMDAT ?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000003H ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB DQ 0000000000000000H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_steady@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@system_clock@chrono@std@@2_NB DB 00H		; std::chrono::system_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@system_clock@chrono@std@@2_NB DB 00H	; std::chrono::system_clock::is_monotonic
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0A@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?value@?$_Abs@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$00@std@@2_JB DQ 0000000000000001H	; std::_Abs<1>::value
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_Gcd<100,1000000000>::value
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<100,1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<1000000000,100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB DD 03H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
CONST	ENDS
;	COMDAT ?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 02H ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0A@@std@@2_JB DQ 0000000000000064H	; std::_GcdX<100,0>::value
CONST	ENDS
;	COMDAT ?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 01H ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
CONST	ENDS
;	COMDAT ?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB DD 00H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Abs<1000000000>::value
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0GE@@std@@2_JB DQ 0000000000000064H	; std::_Abs<100>::value
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::ratio<1,10000000>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,10000000>::num
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,10000000>::value
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000000>::value
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000000,1>::value
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@H$0A@@std@@2HB
CONST	SEGMENT
?value@?$integral_constant@H$0A@@std@@2HB DD 00H	; std::integral_constant<int,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_K$0A@@std@@2_KB
CONST	SEGMENT
?value@?$integral_constant@_K$0A@@std@@2_KB DQ 0000000000000000H ; std::integral_constant<unsigned __int64,0>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT AgentEventGuid
CONST	SEGMENT
AgentEventGuid DD 0b9b5b78cH
	DW	0713H
	DW	04898H
	DB	0a2H
	DB	01aH
	DB	0c6H
	DB	079H
	DB	049H
	DB	0dcH
	DB	0edH
	DB	07H
CONST	ENDS
;	COMDAT PPLParallelForeachEventGuid
CONST	SEGMENT
PPLParallelForeachEventGuid DD 05cb7d785H
	DW	09d66H
	DW	0465dH
	DB	0baH
	DB	0e1H
	DB	046H
	DB	011H
	DB	06H
	DB	01bH
	DB	054H
	DB	034H
CONST	ENDS
;	COMDAT PPLParallelForEventGuid
CONST	SEGMENT
PPLParallelForEventGuid DD 031c8da6bH
	DW	06165H
	DW	04042H
	DB	08bH
	DB	092H
	DB	094H
	DB	09eH
	DB	031H
	DB	05fH
	DB	04dH
	DB	084H
CONST	ENDS
;	COMDAT PPLParallelInvokeEventGuid
CONST	SEGMENT
PPLParallelInvokeEventGuid DD 0d1b5b133H
	DW	0ec3dH
	DW	049f4H
	DB	098H
	DB	0a3H
	DB	046H
	DB	04dH
	DB	01aH
	DB	09eH
	DB	046H
	DB	082H
CONST	ENDS
;	COMDAT ResourceManagerEventGuid
CONST	SEGMENT
ResourceManagerEventGuid DD 02718d25bH
	DW	05bf5H
	DW	04479H
	DB	08eH
	DB	088H
	DB	0baH
	DB	0bcH
	DB	064H
	DB	0bdH
	DB	0bfH
	DB	0caH
CONST	ENDS
;	COMDAT LockEventGuid
CONST	SEGMENT
LockEventGuid DD 079a60dc6H
	DW	05fc8H
	DW	04952H
	DB	0a4H
	DB	01cH
	DB	011H
	DB	063H
	DB	0aeH
	DB	0ecH
	DB	05eH
	DB	0b8H
CONST	ENDS
;	COMDAT VirtualProcessorEventGuid
CONST	SEGMENT
VirtualProcessorEventGuid DD 02f27805fH
	DW	01676H
	DW	04eccH
	DB	096H
	DB	0faH
	DB	07eH
	DB	0b0H
	DB	09dH
	DB	044H
	DB	030H
	DB	02fH
CONST	ENDS
;	COMDAT ChoreEventGuid
CONST	SEGMENT
ChoreEventGuid DD 07e854ec7H
	DW	0cdc4H
	DW	0405aH
	DB	0b5H
	DB	0b2H
	DB	0aaH
	DB	0f7H
	DB	0c9H
	DB	0e7H
	DB	0d4H
	DB	0cH
CONST	ENDS
;	COMDAT ContextEventGuid
CONST	SEGMENT
ContextEventGuid DD 05727a00fH
	DW	050beH
	DW	04519H
	DB	082H
	DB	056H
	DB	0f7H
	DB	069H
	DB	098H
	DB	071H
	DB	0feH
	DB	0cbH
CONST	ENDS
;	COMDAT ScheduleGroupEventGuid
CONST	SEGMENT
ScheduleGroupEventGuid DD 0e8a3bf1fH
	DW	0a86bH
	DW	04390H
	DB	09cH
	DB	060H
	DB	053H
	DB	090H
	DB	0b9H
	DB	069H
	DB	0d2H
	DB	02cH
CONST	ENDS
;	COMDAT SchedulerEventGuid
CONST	SEGMENT
SchedulerEventGuid DD 0e2091f8aH
	DW	01e0aH
	DW	04731H
	DB	084H
	DB	0a2H
	DB	0dH
	DB	0d5H
	DB	07cH
	DB	08aH
	DB	052H
	DB	061H
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ConcRTEventGuid
CONST	SEGMENT
ConcRTEventGuid DD 072b14a7dH
	DW	0704cH
	DW	0423eH
	DB	092H
	DB	0f8H
	DB	07eH
	DB	06dH
	DB	064H
	DB	0bcH
	DB	0b9H
	DB	02aH
CONST	ENDS
;	COMDAT ConcRT_ProviderGuid
CONST	SEGMENT
ConcRT_ProviderGuid DD 0f7b697a3H
	DW	04db5H
	DW	04d3bH
	DB	0beH
	DB	071H
	DB	0c4H
	DB	0d2H
	DB	084H
	DB	0e6H
	DB	059H
	DB	02fH
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_steady@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@steady_clock@chrono@std@@2_NB DB 01H		; std::chrono::steady_clock::is_steady
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?is_monotonic@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@steady_clock@chrono@std@@2_NB DB 01H	; std::chrono::steady_clock::is_monotonic
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB DQ 0000000000000001H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
CONST	SEGMENT
dutycycletable DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
$SG113850 DB	'Code\emulation\gb\cartridge.cpp', 00H
$SG113859 DB	'Code\emulation\gb\cartridge.cpp', 00H
$SG113863 DB	'Code\emulation\gb\cartridge.cpp', 00H
$SG113867 DB	'Code\emulation\gb\cartridge.cpp', 00H
$SG113883 DB	'%s.ram', 00H
	ORG $+1
$SG113889 DB	'%s.ram', 00H
	ORG $+1
$SG113891 DB	'wb', 00H
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::num
CONST	ENDS
PUBLIC	??0_Ignore@std@@QEAA@XZ				; std::_Ignore::_Ignore
PUBLIC	?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z ; emulation::gb::Component::Initialize
PUBLIC	?rom_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ ; emulation::gb::CartridgeHeader::rom_size_bytes
PUBLIC	?ram_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ ; emulation::gb::CartridgeHeader::ram_size_bytes
PUBLIC	?Initialize@Cartridge@gb@emulation@@UEAAXPEAVEmu@23@@Z ; emulation::gb::Cartridge::Initialize
PUBLIC	?Deinitialize@Cartridge@gb@emulation@@UEAAXXZ	; emulation::gb::Cartridge::Deinitialize
PUBLIC	?LoadFile@Cartridge@gb@emulation@@QEAAXPEBDPEAUCartridgeHeader@23@@Z ; emulation::gb::Cartridge::LoadFile
PUBLIC	?LoadRam@Cartridge@gb@emulation@@QEAAXXZ	; emulation::gb::Cartridge::LoadRam
PUBLIC	?SaveRam@Cartridge@gb@emulation@@QEAAXXZ	; emulation::gb::Cartridge::SaveRam
PUBLIC	?rom@Cartridge@gb@emulation@@QEAAPEBEXZ		; emulation::gb::Cartridge::rom
PUBLIC	?Read@Cartridge@gb@emulation@@QEAAEG@Z		; emulation::gb::Cartridge::Read
PUBLIC	?Write@Cartridge@gb@emulation@@QEAAXGE@Z	; emulation::gb::Cartridge::Write
PUBLIC	?Initialize@MemoryBankController@gb@emulation@@UEAAXPEAVCartridge@23@@Z ; emulation::gb::MemoryBankController::Initialize
PUBLIC	?Deinitialize@MemoryBankController@gb@emulation@@UEAAXXZ ; emulation::gb::MemoryBankController::Deinitialize
PUBLIC	?Tick@MemoryBankController@gb@emulation@@UEAAXXZ ; emulation::gb::MemoryBankController::Tick
PUBLIC	?eram@MemoryBankController@gb@emulation@@QEAAPEAEXZ ; emulation::gb::MemoryBankController::eram
PUBLIC	??0MemoryBankController@gb@emulation@@QEAA@XZ	; emulation::gb::MemoryBankController::MemoryBankController
PUBLIC	??$SafeDeleteArray@E@@YAXPEAPEAE@Z		; SafeDeleteArray<unsigned char>
PUBLIC	?Deinitialize@MBCNone@gb@emulation@@UEAAXXZ	; emulation::gb::MBCNone::Deinitialize
PUBLIC	?Read@MBCNone@gb@emulation@@UEAAEG@Z		; emulation::gb::MBCNone::Read
PUBLIC	?Write@MBCNone@gb@emulation@@UEAAXGE@Z		; emulation::gb::MBCNone::Write
PUBLIC	??0MBCNone@gb@emulation@@QEAA@XZ		; emulation::gb::MBCNone::MBCNone
PUBLIC	?Initialize@MBC1@gb@emulation@@UEAAXPEAVCartridge@23@@Z ; emulation::gb::MBC1::Initialize
PUBLIC	?Deinitialize@MBC1@gb@emulation@@UEAAXXZ	; emulation::gb::MBC1::Deinitialize
PUBLIC	?Read@MBC1@gb@emulation@@UEAAEG@Z		; emulation::gb::MBC1::Read
PUBLIC	?Write@MBC1@gb@emulation@@UEAAXGE@Z		; emulation::gb::MBC1::Write
PUBLIC	??0MBC1@gb@emulation@@QEAA@XZ			; emulation::gb::MBC1::MBC1
PUBLIC	?Initialize@MBC3@gb@emulation@@UEAAXPEAVCartridge@23@@Z ; emulation::gb::MBC3::Initialize
PUBLIC	?Deinitialize@MBC3@gb@emulation@@UEAAXXZ	; emulation::gb::MBC3::Deinitialize
PUBLIC	?Read@MBC3@gb@emulation@@UEAAEG@Z		; emulation::gb::MBC3::Read
PUBLIC	?Write@MBC3@gb@emulation@@UEAAXGE@Z		; emulation::gb::MBC3::Write
PUBLIC	?Tick@MBC3@gb@emulation@@UEAAXXZ		; emulation::gb::MBC3::Tick
PUBLIC	??0MBC3@gb@emulation@@QEAA@XZ			; emulation::gb::MBC3::MBC3
PUBLIC	??$SafeDelete@VMemoryBankController@gb@emulation@@@@YAXPEAPEAVMemoryBankController@gb@emulation@@@Z ; SafeDelete<emulation::gb::MemoryBankController>
PUBLIC	??_7MemoryBankController@gb@emulation@@6B@	; emulation::gb::MemoryBankController::`vftable'
PUBLIC	??_C@_0EC@EPIJFGKG@d?3?2personal?2projects?2gbemu?2solut@ ; `string'
PUBLIC	??_7MBCNone@gb@emulation@@6B@			; emulation::gb::MBCNone::`vftable'
PUBLIC	??_7MBC1@gb@emulation@@6B@			; emulation::gb::MBC1::`vftable'
PUBLIC	??_7MBC3@gb@emulation@@6B@			; emulation::gb::MBC3::`vftable'
PUBLIC	??_R4MemoryBankController@gb@emulation@@6B@	; emulation::gb::MemoryBankController::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMemoryBankController@gb@emulation@@@8	; emulation::gb::MemoryBankController `RTTI Type Descriptor'
PUBLIC	??_R3MemoryBankController@gb@emulation@@8	; emulation::gb::MemoryBankController::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MemoryBankController@gb@emulation@@8	; emulation::gb::MemoryBankController::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MemoryBankController@gb@emulation@@8 ; emulation::gb::MemoryBankController::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4MBCNone@gb@emulation@@6B@			; emulation::gb::MBCNone::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMBCNone@gb@emulation@@@8		; emulation::gb::MBCNone `RTTI Type Descriptor'
PUBLIC	??_R3MBCNone@gb@emulation@@8			; emulation::gb::MBCNone::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MBCNone@gb@emulation@@8			; emulation::gb::MBCNone::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MBCNone@gb@emulation@@8		; emulation::gb::MBCNone::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4MBC1@gb@emulation@@6B@			; emulation::gb::MBC1::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMBC1@gb@emulation@@@8			; emulation::gb::MBC1 `RTTI Type Descriptor'
PUBLIC	??_R3MBC1@gb@emulation@@8			; emulation::gb::MBC1::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MBC1@gb@emulation@@8			; emulation::gb::MBC1::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MBC1@gb@emulation@@8		; emulation::gb::MBC1::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4MBC3@gb@emulation@@6B@			; emulation::gb::MBC3::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMBC3@gb@emulation@@@8			; emulation::gb::MBC3 `RTTI Type Descriptor'
PUBLIC	??_R3MBC3@gb@emulation@@8			; emulation::gb::MBC3::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MBC3@gb@emulation@@8			; emulation::gb::MBC3::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MBC3@gb@emulation@@8		; emulation::gb::MBC3::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	_purecall:PROC
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__imp_DebugBreak:PROC
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp_sprintf:PROC
EXTRN	??2@YAPEAX_KHPEBDH@Z:PROC			; operator new
EXTRN	??_U@YAPEAX_KHPEBDH@Z:PROC			; operator new[]
EXTRN	?ReadWholeFileBinary@io@core@@YAXPEBDPEAPEAEAEA_K@Z:PROC ; core::io::ReadWholeFileBinary
EXTRN	?DestroyFileBuffer@io@core@@YAXPEAPEAE@Z:PROC	; core::io::DestroyFileBuffer
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
piecewise_construct DB 01H DUP (?)
allocator_arg DB 01H DUP (?)
ignore	DB	01H DUP (?)
_Tuple_alloc DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Epiecewise_construct@std@@YAXXZ DD imagerel ??__Epiecewise_construct@std@@YAXXZ
	DD	imagerel ??__Epiecewise_construct@std@@YAXXZ+43
	DD	imagerel $unwind$??__Epiecewise_construct@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eallocator_arg@std@@YAXXZ DD imagerel ??__Eallocator_arg@std@@YAXXZ
	DD	imagerel ??__Eallocator_arg@std@@YAXXZ+43
	DD	imagerel $unwind$??__Eallocator_arg@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Ignore@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+13
	DD	imagerel $unwind$??0_Ignore@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eignore@std@@YAXXZ DD imagerel ??__Eignore@std@@YAXXZ
	DD	imagerel ??__Eignore@std@@YAXXZ+39
	DD	imagerel $unwind$??__Eignore@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E_Tuple_alloc@std@@YAXXZ DD imagerel ??__E_Tuple_alloc@std@@YAXXZ
	DD	imagerel ??__E_Tuple_alloc@std@@YAXXZ+43
	DD	imagerel $unwind$??__E_Tuple_alloc@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rom_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ DD imagerel $LN10
	DD	imagerel $LN10+138
	DD	imagerel $unwind$?rom_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ram_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ DD imagerel $LN12
	DD	imagerel $LN12+138
	DD	imagerel $unwind$?ram_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?Initialize@Cartridge@gb@emulation@@UEAAXPEAVEmu@23@@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?Initialize@Cartridge@gb@emulation@@UEAAXPEAVEmu@23@@Z
$pdata$?Deinitialize@Cartridge@gb@emulation@@UEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+116
	DD	imagerel $unwind$?Deinitialize@Cartridge@gb@emulation@@UEAAXXZ
$pdata$?LoadFile@Cartridge@gb@emulation@@QEAAXPEBDPEAUCartridgeHeader@23@@Z DD imagerel $LN17
	DD	imagerel $LN17+822
	DD	imagerel $unwind$?LoadFile@Cartridge@gb@emulation@@QEAAXPEBDPEAUCartridgeHeader@23@@Z
$pdata$?LoadRam@Cartridge@gb@emulation@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+203
	DD	imagerel $unwind$?LoadRam@Cartridge@gb@emulation@@QEAAXXZ
$pdata$?SaveRam@Cartridge@gb@emulation@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+248
	DD	imagerel $unwind$?SaveRam@Cartridge@gb@emulation@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rom@Cartridge@gb@emulation@@QEAAPEBEXZ DD imagerel $LN3
	DD	imagerel $LN3+17
	DD	imagerel $unwind$?rom@Cartridge@gb@emulation@@QEAAPEBEXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?Read@Cartridge@gb@emulation@@QEAAEG@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?Read@Cartridge@gb@emulation@@QEAAEG@Z
$pdata$?Write@Cartridge@gb@emulation@@QEAAXGE@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$?Write@Cartridge@gb@emulation@@QEAAXGE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@MemoryBankController@gb@emulation@@UEAAXPEAVCartridge@23@@Z DD imagerel $LN9
	DD	imagerel $LN9+268
	DD	imagerel $unwind$?Initialize@MemoryBankController@gb@emulation@@UEAAXPEAVCartridge@23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Deinitialize@MemoryBankController@gb@emulation@@UEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?Deinitialize@MemoryBankController@gb@emulation@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Tick@MemoryBankController@gb@emulation@@UEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+8
	DD	imagerel $unwind$?Tick@MemoryBankController@gb@emulation@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eram@MemoryBankController@gb@emulation@@QEAAPEAEXZ DD imagerel $LN3
	DD	imagerel $LN3+17
	DD	imagerel $unwind$?eram@MemoryBankController@gb@emulation@@QEAAPEAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0MemoryBankController@gb@emulation@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$??0MemoryBankController@gb@emulation@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SafeDeleteArray@E@@YAXPEAPEAE@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??$SafeDeleteArray@E@@YAXPEAPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Deinitialize@MBCNone@gb@emulation@@UEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?Deinitialize@MBCNone@gb@emulation@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Read@MBCNone@gb@emulation@@UEAAEG@Z DD imagerel $LN8
	DD	imagerel $LN8+170
	DD	imagerel $unwind$?Read@MBCNone@gb@emulation@@UEAAEG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Write@MBCNone@gb@emulation@@UEAAXGE@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?Write@MBCNone@gb@emulation@@UEAAXGE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0MBCNone@gb@emulation@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??0MBCNone@gb@emulation@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@MBC1@gb@emulation@@UEAAXPEAVCartridge@23@@Z DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$?Initialize@MBC1@gb@emulation@@UEAAXPEAVCartridge@23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Deinitialize@MBC1@gb@emulation@@UEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?Deinitialize@MBC1@gb@emulation@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Read@MBC1@gb@emulation@@UEAAEG@Z DD imagerel $LN10
	DD	imagerel $LN10+273
	DD	imagerel $unwind$?Read@MBC1@gb@emulation@@UEAAEG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Write@MBC1@gb@emulation@@UEAAXGE@Z DD imagerel $LN16
	DD	imagerel $LN16+325
	DD	imagerel $unwind$?Write@MBC1@gb@emulation@@UEAAXGE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0MBC1@gb@emulation@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??0MBC1@gb@emulation@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@MBC3@gb@emulation@@UEAAXPEAVCartridge@23@@Z DD imagerel $LN3
	DD	imagerel $LN3+164
	DD	imagerel $unwind$?Initialize@MBC3@gb@emulation@@UEAAXPEAVCartridge@23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Deinitialize@MBC3@gb@emulation@@UEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?Deinitialize@MBC3@gb@emulation@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Read@MBC3@gb@emulation@@UEAAEG@Z DD imagerel $LN10
	DD	imagerel $LN10+350
	DD	imagerel $unwind$?Read@MBC3@gb@emulation@@UEAAEG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Write@MBC3@gb@emulation@@UEAAXGE@Z DD imagerel $LN18
	DD	imagerel $LN18+420
	DD	imagerel $unwind$?Write@MBC3@gb@emulation@@UEAAXGE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Tick@MBC3@gb@emulation@@UEAAXXZ DD imagerel $LN12
	DD	imagerel $LN12+610
	DD	imagerel $unwind$?Tick@MBC3@gb@emulation@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0MBC3@gb@emulation@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??0MBC3@gb@emulation@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SafeDelete@VMemoryBankController@gb@emulation@@@@YAXPEAPEAVMemoryBankController@gb@emulation@@@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??$SafeDelete@VMemoryBankController@gb@emulation@@@@YAXPEAPEAVMemoryBankController@gb@emulation@@@Z
pdata	ENDS
CRT$XCU	SEGMENT
piecewise_construct$initializer$ DQ FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@MBC3@gb@emulation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MBC3@gb@emulation@@8 DD imagerel ??_R0?AVMBC3@gb@emulation@@@8 ; emulation::gb::MBC3::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3MBC3@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R2MBC3@gb@emulation@@8
rdata$r	SEGMENT
??_R2MBC3@gb@emulation@@8 DD imagerel ??_R1A@?0A@EA@MBC3@gb@emulation@@8 ; emulation::gb::MBC3::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@MemoryBankController@gb@emulation@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3MBC3@gb@emulation@@8
rdata$r	SEGMENT
??_R3MBC3@gb@emulation@@8 DD 00H			; emulation::gb::MBC3::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2MBC3@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMBC3@gb@emulation@@@8
_DATA	SEGMENT
??_R0?AVMBC3@gb@emulation@@@8 DQ FLAT:??_7type_info@@6B@ ; emulation::gb::MBC3 `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVMBC3@gb@emulation@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MBC3@gb@emulation@@6B@
rdata$r	SEGMENT
??_R4MBC3@gb@emulation@@6B@ DD 01H			; emulation::gb::MBC3::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVMBC3@gb@emulation@@@8
	DD	imagerel ??_R3MBC3@gb@emulation@@8
	DD	imagerel ??_R4MBC3@gb@emulation@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MBC1@gb@emulation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MBC1@gb@emulation@@8 DD imagerel ??_R0?AVMBC1@gb@emulation@@@8 ; emulation::gb::MBC1::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3MBC1@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R2MBC1@gb@emulation@@8
rdata$r	SEGMENT
??_R2MBC1@gb@emulation@@8 DD imagerel ??_R1A@?0A@EA@MBC1@gb@emulation@@8 ; emulation::gb::MBC1::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@MemoryBankController@gb@emulation@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3MBC1@gb@emulation@@8
rdata$r	SEGMENT
??_R3MBC1@gb@emulation@@8 DD 00H			; emulation::gb::MBC1::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2MBC1@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMBC1@gb@emulation@@@8
_DATA	SEGMENT
??_R0?AVMBC1@gb@emulation@@@8 DQ FLAT:??_7type_info@@6B@ ; emulation::gb::MBC1 `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVMBC1@gb@emulation@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MBC1@gb@emulation@@6B@
rdata$r	SEGMENT
??_R4MBC1@gb@emulation@@6B@ DD 01H			; emulation::gb::MBC1::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVMBC1@gb@emulation@@@8
	DD	imagerel ??_R3MBC1@gb@emulation@@8
	DD	imagerel ??_R4MBC1@gb@emulation@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MBCNone@gb@emulation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MBCNone@gb@emulation@@8 DD imagerel ??_R0?AVMBCNone@gb@emulation@@@8 ; emulation::gb::MBCNone::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3MBCNone@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R2MBCNone@gb@emulation@@8
rdata$r	SEGMENT
??_R2MBCNone@gb@emulation@@8 DD imagerel ??_R1A@?0A@EA@MBCNone@gb@emulation@@8 ; emulation::gb::MBCNone::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@MemoryBankController@gb@emulation@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3MBCNone@gb@emulation@@8
rdata$r	SEGMENT
??_R3MBCNone@gb@emulation@@8 DD 00H			; emulation::gb::MBCNone::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2MBCNone@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMBCNone@gb@emulation@@@8
_DATA	SEGMENT
??_R0?AVMBCNone@gb@emulation@@@8 DQ FLAT:??_7type_info@@6B@ ; emulation::gb::MBCNone `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVMBCNone@gb@emulation@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MBCNone@gb@emulation@@6B@
rdata$r	SEGMENT
??_R4MBCNone@gb@emulation@@6B@ DD 01H			; emulation::gb::MBCNone::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVMBCNone@gb@emulation@@@8
	DD	imagerel ??_R3MBCNone@gb@emulation@@8
	DD	imagerel ??_R4MBCNone@gb@emulation@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MemoryBankController@gb@emulation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MemoryBankController@gb@emulation@@8 DD imagerel ??_R0?AVMemoryBankController@gb@emulation@@@8 ; emulation::gb::MemoryBankController::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3MemoryBankController@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R2MemoryBankController@gb@emulation@@8
rdata$r	SEGMENT
??_R2MemoryBankController@gb@emulation@@8 DD imagerel ??_R1A@?0A@EA@MemoryBankController@gb@emulation@@8 ; emulation::gb::MemoryBankController::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3MemoryBankController@gb@emulation@@8
rdata$r	SEGMENT
??_R3MemoryBankController@gb@emulation@@8 DD 00H	; emulation::gb::MemoryBankController::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2MemoryBankController@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMemoryBankController@gb@emulation@@@8
_DATA	SEGMENT
??_R0?AVMemoryBankController@gb@emulation@@@8 DQ FLAT:??_7type_info@@6B@ ; emulation::gb::MemoryBankController `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVMemoryBankController@gb@emulation@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MemoryBankController@gb@emulation@@6B@
rdata$r	SEGMENT
??_R4MemoryBankController@gb@emulation@@6B@ DD 01H	; emulation::gb::MemoryBankController::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVMemoryBankController@gb@emulation@@@8
	DD	imagerel ??_R3MemoryBankController@gb@emulation@@8
	DD	imagerel ??_R4MemoryBankController@gb@emulation@@6B@
rdata$r	ENDS
;	COMDAT ??_7MBC3@gb@emulation@@6B@
CONST	SEGMENT
??_7MBC3@gb@emulation@@6B@ DQ FLAT:??_R4MBC3@gb@emulation@@6B@ ; emulation::gb::MBC3::`vftable'
	DQ	FLAT:?Initialize@MBC3@gb@emulation@@UEAAXPEAVCartridge@23@@Z
	DQ	FLAT:?Deinitialize@MBC3@gb@emulation@@UEAAXXZ
	DQ	FLAT:?Read@MBC3@gb@emulation@@UEAAEG@Z
	DQ	FLAT:?Write@MBC3@gb@emulation@@UEAAXGE@Z
	DQ	FLAT:?Tick@MBC3@gb@emulation@@UEAAXXZ
CONST	ENDS
;	COMDAT ??_7MBC1@gb@emulation@@6B@
CONST	SEGMENT
??_7MBC1@gb@emulation@@6B@ DQ FLAT:??_R4MBC1@gb@emulation@@6B@ ; emulation::gb::MBC1::`vftable'
	DQ	FLAT:?Initialize@MBC1@gb@emulation@@UEAAXPEAVCartridge@23@@Z
	DQ	FLAT:?Deinitialize@MBC1@gb@emulation@@UEAAXXZ
	DQ	FLAT:?Read@MBC1@gb@emulation@@UEAAEG@Z
	DQ	FLAT:?Write@MBC1@gb@emulation@@UEAAXGE@Z
	DQ	FLAT:?Tick@MemoryBankController@gb@emulation@@UEAAXXZ
CONST	ENDS
;	COMDAT ??_7MBCNone@gb@emulation@@6B@
CONST	SEGMENT
??_7MBCNone@gb@emulation@@6B@ DQ FLAT:??_R4MBCNone@gb@emulation@@6B@ ; emulation::gb::MBCNone::`vftable'
	DQ	FLAT:?Initialize@MemoryBankController@gb@emulation@@UEAAXPEAVCartridge@23@@Z
	DQ	FLAT:?Deinitialize@MBCNone@gb@emulation@@UEAAXXZ
	DQ	FLAT:?Read@MBCNone@gb@emulation@@UEAAEG@Z
	DQ	FLAT:?Write@MBCNone@gb@emulation@@UEAAXGE@Z
	DQ	FLAT:?Tick@MemoryBankController@gb@emulation@@UEAAXXZ
CONST	ENDS
;	COMDAT ??_C@_0EC@EPIJFGKG@d?3?2personal?2projects?2gbemu?2solut@
CONST	SEGMENT
??_C@_0EC@EPIJFGKG@d?3?2personal?2projects?2gbemu?2solut@ DB 'd:\personal'
	DB	'\projects\gbemu\solution\code\emulation\gb\cartridge.h', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7MemoryBankController@gb@emulation@@6B@
CONST	SEGMENT
??_7MemoryBankController@gb@emulation@@6B@ DQ FLAT:??_R4MemoryBankController@gb@emulation@@6B@ ; emulation::gb::MemoryBankController::`vftable'
	DQ	FLAT:?Initialize@MemoryBankController@gb@emulation@@UEAAXPEAVCartridge@23@@Z
	DQ	FLAT:?Deinitialize@MemoryBankController@gb@emulation@@UEAAXXZ
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:?Tick@MemoryBankController@gb@emulation@@UEAAXXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SafeDelete@VMemoryBankController@gb@emulation@@@@YAXPEAPEAVMemoryBankController@gb@emulation@@@Z DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0MBC3@gb@emulation@@QEAA@XZ DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Tick@MBC3@gb@emulation@@UEAAXXZ DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Write@MBC3@gb@emulation@@UEAAXGE@Z DD 011001H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Read@MBC3@gb@emulation@@UEAAEG@Z DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Deinitialize@MBC3@gb@emulation@@UEAAXXZ DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@MBC3@gb@emulation@@UEAAXPEAVCartridge@23@@Z DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0MBC1@gb@emulation@@QEAA@XZ DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Write@MBC1@gb@emulation@@UEAAXGE@Z DD 011001H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Read@MBC1@gb@emulation@@UEAAEG@Z DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Deinitialize@MBC1@gb@emulation@@UEAAXXZ DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@MBC1@gb@emulation@@UEAAXPEAVCartridge@23@@Z DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0MBCNone@gb@emulation@@QEAA@XZ DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Write@MBCNone@gb@emulation@@UEAAXGE@Z DD 022801H
	DD	070101214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Read@MBCNone@gb@emulation@@UEAAEG@Z DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Deinitialize@MBCNone@gb@emulation@@UEAAXXZ DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SafeDeleteArray@E@@YAXPEAPEAE@Z DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0MemoryBankController@gb@emulation@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eram@MemoryBankController@gb@emulation@@QEAAPEAEXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Tick@MemoryBankController@gb@emulation@@UEAAXXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Deinitialize@MemoryBankController@gb@emulation@@UEAAXXZ DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@MemoryBankController@gb@emulation@@UEAAXPEAVCartridge@23@@Z DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rom@Cartridge@gb@emulation@@QEAAPEBEXZ DD 010601H
	DD	07006H
xdata	ENDS
CONST	SEGMENT
	ORG $+1
?LoadFile@Cartridge@gb@emulation@@QEAAXPEBDPEAUCartridgeHeader@23@@Z$rtcName$0 DB 064H ; emulation::gb::Cartridge::LoadFile
	DB	061H
	DB	074H
	DB	061H
	DB	00H
	ORG $+3
?LoadFile@Cartridge@gb@emulation@@QEAAXPEBDPEAUCartridgeHeader@23@@Z$rtcName$1 DB 06cH ; emulation::gb::Cartridge::LoadFile
	DB	065H
	DB	06eH
	DB	067H
	DB	074H
	DB	068H
	DB	00H
	ORG $+5
?LoadFile@Cartridge@gb@emulation@@QEAAXPEBDPEAUCartridgeHeader@23@@Z$rtcFrameData DD 02H ; emulation::gb::Cartridge::LoadFile
	DD	00H
	DQ	FLAT:?LoadFile@Cartridge@gb@emulation@@QEAAXPEBDPEAUCartridgeHeader@23@@Z$rtcVarDesc
?LoadRam@Cartridge@gb@emulation@@QEAAXXZ$rtcName$0 DB 064H ; emulation::gb::Cartridge::LoadRam
	DB	061H
	DB	074H
	DB	061H
	DB	00H
	ORG $+3
?LoadFile@Cartridge@gb@emulation@@QEAAXPEBDPEAUCartridgeHeader@23@@Z$rtcVarDesc DD 048H ; emulation::gb::Cartridge::LoadFile
	DD	08H
	DQ	FLAT:?LoadFile@Cartridge@gb@emulation@@QEAAXPEBDPEAUCartridgeHeader@23@@Z$rtcName$1
	DD	028H
	DD	08H
	DQ	FLAT:?LoadFile@Cartridge@gb@emulation@@QEAAXPEBDPEAUCartridgeHeader@23@@Z$rtcName$0
	ORG $+96
?LoadRam@Cartridge@gb@emulation@@QEAAXXZ$rtcName$1 DB 06cH ; emulation::gb::Cartridge::LoadRam
	DB	065H
	DB	06eH
	DB	067H
	DB	074H
	DB	068H
	DB	00H
	ORG $+1
?LoadRam@Cartridge@gb@emulation@@QEAAXXZ$rtcName$2 DB 066H ; emulation::gb::Cartridge::LoadRam
	DB	069H
	DB	06cH
	DB	065H
	DB	06eH
	DB	061H
	DB	06dH
	DB	065H
	DB	00H
	ORG $+7
?LoadRam@Cartridge@gb@emulation@@QEAAXXZ$rtcFrameData DD 03H ; emulation::gb::Cartridge::LoadRam
	DD	00H
	DQ	FLAT:?LoadRam@Cartridge@gb@emulation@@QEAAXXZ$rtcVarDesc
	ORG $+8
?LoadRam@Cartridge@gb@emulation@@QEAAXXZ$rtcVarDesc DD 070H ; emulation::gb::Cartridge::LoadRam
	DD	0100H
	DQ	FLAT:?LoadRam@Cartridge@gb@emulation@@QEAAXXZ$rtcName$2
	DD	048H
	DD	08H
	DQ	FLAT:?LoadRam@Cartridge@gb@emulation@@QEAAXXZ$rtcName$1
	DD	028H
	DD	08H
	DQ	FLAT:?LoadRam@Cartridge@gb@emulation@@QEAAXXZ$rtcName$0
	ORG $+144
?SaveRam@Cartridge@gb@emulation@@QEAAXXZ$rtcName$0 DB 066H ; emulation::gb::Cartridge::SaveRam
	DB	069H
	DB	06cH
	DB	065H
	DB	06eH
	DB	061H
	DB	06dH
	DB	065H
	DB	00H
	ORG $+7
?SaveRam@Cartridge@gb@emulation@@QEAAXXZ$rtcVarDesc DD 030H ; emulation::gb::Cartridge::SaveRam
	DD	0100H
	DQ	FLAT:?SaveRam@Cartridge@gb@emulation@@QEAAXXZ$rtcName$0
	ORG $+48
?SaveRam@Cartridge@gb@emulation@@QEAAXXZ$rtcFrameData DD 01H ; emulation::gb::Cartridge::SaveRam
	DD	00H
	DQ	FLAT:?SaveRam@Cartridge@gb@emulation@@QEAAXXZ$rtcVarDesc
CONST	ENDS
xdata	SEGMENT
$unwind$?Initialize@Cartridge@gb@emulation@@UEAAXPEAVEmu@23@@Z DD 022301H
	DD	0700b320fH
$unwind$?Deinitialize@Cartridge@gb@emulation@@UEAAXXZ DD 021e01H
	DD	07006320aH
$unwind$?LoadFile@Cartridge@gb@emulation@@QEAAXPEBDPEAUCartridgeHeader@23@@Z DD 032e01H
	DD	0140117H
	DD	07010H
$unwind$?LoadRam@Cartridge@gb@emulation@@QEAAXXZ DD 033619H
	DD	032010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$?SaveRam@Cartridge@gb@emulation@@QEAAXXZ DD 033619H
	DD	02c010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$?Read@Cartridge@gb@emulation@@QEAAEG@Z DD 022301H
	DD	0700b320fH
$unwind$?Write@Cartridge@gb@emulation@@QEAAXGE@Z DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ram_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rom_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E_Tuple_alloc@std@@YAXXZ DD 021501H
	DD	070021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eignore@std@@YAXXZ DD 021501H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Ignore@std@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eallocator_arg@std@@YAXXZ DD 021501H
	DD	070021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Epiecewise_construct@std@@YAXXZ DD 021501H
	DD	070021206H
xdata	ENDS
CRT$XCU	SEGMENT
allocator_arg$initializer$ DQ FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
ignore$initializer$ DQ FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_Tuple_alloc$initializer$ DQ FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\wincore\types.h
;	COMDAT ??$SafeDelete@VMemoryBankController@gb@emulation@@@@YAXPEAPEAVMemoryBankController@gb@emulation@@@Z
_TEXT	SEGMENT
$T1 = 32
ppInterfaceToDelete$ = 64
??$SafeDelete@VMemoryBankController@gb@emulation@@@@YAXPEAPEAVMemoryBankController@gb@emulation@@@Z PROC ; SafeDelete<emulation::gb::MemoryBankController>, COMDAT

; 37   : inline void SafeDelete(Interface **ppInterfaceToDelete) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 38   :     if (*ppInterfaceToDelete != NULL) {

	mov	rax, QWORD PTR ppInterfaceToDelete$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN1@SafeDelete

; 39   :         delete (*ppInterfaceToDelete);

	mov	rax, QWORD PTR ppInterfaceToDelete$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	??3@YAXPEAX@Z				; operator delete

; 40   :         (*ppInterfaceToDelete) = NULL;

	mov	rax, QWORD PTR ppInterfaceToDelete$[rsp]
	mov	QWORD PTR [rax], 0
$LN1@SafeDelete:

; 41   :     }
; 42   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$SafeDelete@VMemoryBankController@gb@emulation@@@@YAXPEAPEAVMemoryBankController@gb@emulation@@@Z ENDP ; SafeDelete<emulation::gb::MemoryBankController>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0MBC3@gb@emulation@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0MBC3@gb@emulation@@QEAA@XZ PROC			; emulation::gb::MBC3::MBC3, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0MemoryBankController@gb@emulation@@QEAA@XZ
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7MBC3@gb@emulation@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0MBC3@gb@emulation@@QEAA@XZ ENDP			; emulation::gb::MBC3::MBC3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Tick@MBC3@gb@emulation@@UEAAXXZ
_TEXT	SEGMENT
tv66 = 0
tv71 = 2
tv86 = 4
tv95 = 5
tv136 = 6
tv145 = 7
this$ = 32
?Tick@MBC3@gb@emulation@@UEAAXXZ PROC			; emulation::gb::MBC3::Tick, COMDAT

; 143  :   void Tick() {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 144  :     if (++counter1 == 128) { //32768Hz, for original gameboy

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+42]
	inc	al
	mov	BYTE PTR tv66[rsp], al
	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR tv66[rsp]
	mov	BYTE PTR [rax+42], cl
	movzx	eax, BYTE PTR tv66[rsp]
	cmp	eax, 128				; 00000080H
	jne	$LN9@Tick

; 145  :       if (++counter2 == 32768) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, WORD PTR [rax+44]
	inc	ax
	mov	WORD PTR tv71[rsp], ax
	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, WORD PTR tv71[rsp]
	mov	WORD PTR [rax+44], cx
	movzx	eax, WORD PTR tv71[rsp]
	cmp	eax, 32768				; 00008000H
	jne	$LN8@Tick

; 146  :         if (rtc[4]&0x40) return;//halt

	mov	eax, 1
	imul	rax, 4
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+35]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN7@Tick
	jmp	$LN10@Tick
$LN7@Tick:

; 147  :         if (++rtc[0] == 60) { //sec

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+35]
	inc	al
	mov	BYTE PTR tv86[rsp], al
	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR tv86[rsp]
	mov	BYTE PTR [rcx+rax+35], dl
	movzx	eax, BYTE PTR tv86[rsp]
	cmp	eax, 60					; 0000003cH
	jne	$LN6@Tick

; 148  :           if (++rtc[1] == 60) { //min

	mov	eax, 1
	imul	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+35]
	inc	al
	mov	BYTE PTR tv95[rsp], al
	mov	eax, 1
	imul	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR tv95[rsp]
	mov	BYTE PTR [rcx+rax+35], dl
	movzx	eax, BYTE PTR tv95[rsp]
	cmp	eax, 60					; 0000003cH
	jne	$LN5@Tick

; 149  :             if (++rtc[2] == 24) { //hour

	mov	eax, 1
	imul	rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+35]
	inc	al
	mov	BYTE PTR tv136[rsp], al
	mov	eax, 1
	imul	rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR tv136[rsp]
	mov	BYTE PTR [rcx+rax+35], dl
	movzx	eax, BYTE PTR tv136[rsp]
	cmp	eax, 24
	jne	$LN4@Tick

; 150  :               if (++rtc[3] == 0xFF) { //day

	mov	eax, 1
	imul	rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+35]
	inc	al
	mov	BYTE PTR tv145[rsp], al
	mov	eax, 1
	imul	rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR tv145[rsp]
	mov	BYTE PTR [rcx+rax+35], dl
	movzx	eax, BYTE PTR tv145[rsp]
	cmp	eax, 255				; 000000ffH
	jne	$LN3@Tick

; 151  :                 if (rtc[4]&1)

	mov	eax, 1
	imul	rax, 4
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+35]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@Tick

; 152  :                   rtc[4] |= 0x80;

	mov	eax, 1
	imul	rax, 4
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+35]
	bts	eax, 7
	mov	ecx, 1
	imul	rcx, 4
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+35], al

; 153  :                 else

	jmp	SHORT $LN1@Tick
$LN2@Tick:

; 154  :                   rtc[4] |= 1;

	mov	eax, 1
	imul	rax, 4
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+35]
	or	eax, 1
	mov	ecx, 1
	imul	rcx, 4
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+35], al
$LN1@Tick:

; 155  :                 rtc[3] = 0;

	mov	eax, 1
	imul	rax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+rax+35], 0
$LN3@Tick:

; 156  :               }
; 157  :               rtc[2] = 0;

	mov	eax, 1
	imul	rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+rax+35], 0
$LN4@Tick:

; 158  :             }
; 159  :             rtc[1] = 0;

	mov	eax, 1
	imul	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+rax+35], 0
$LN5@Tick:

; 160  :           }
; 161  :           rtc[0] = 0;

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+rax+35], 0
$LN6@Tick:

; 162  :         }
; 163  :         counter2 =0 ;

	xor	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+44], ax
$LN8@Tick:

; 164  :       }
; 165  :       counter1 = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+42], 0
$LN9@Tick:
$LN10@Tick:

; 166  :     }
; 167  :   }

	add	rsp, 16
	pop	rdi
	ret	0
?Tick@MBC3@gb@emulation@@UEAAXXZ ENDP			; emulation::gb::MBC3::Tick
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Write@MBC3@gb@emulation@@UEAAXGE@Z
_TEXT	SEGMENT
this$ = 16
address$ = 24
data$ = 32
?Write@MBC3@gb@emulation@@UEAAXGE@Z PROC		; emulation::gb::MBC3::Write, COMDAT

; 116  :   void Write(uint16_t address, uint8_t data) {

$LN18:
	mov	BYTE PTR [rsp+24], r8b
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 117  :    if (address >= 0x0000 && address <= 0x1FFF) {

	movzx	eax, WORD PTR address$[rsp]
	test	eax, eax
	jl	SHORT $LN15@Write
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 8191				; 00001fffH
	jg	SHORT $LN15@Write

; 118  : 	    eram_enable = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+24], cl

; 119  :       rtc_enable = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+40], cl
	jmp	$LN14@Write
$LN15@Write:

; 120  : 	  } else if (address >= 0x2000 && address <= 0x3FFF) {

	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 8192				; 00002000H
	jl	SHORT $LN13@Write
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 16383				; 00003fffH
	jg	SHORT $LN13@Write

; 121  :       rom_bank_number = data&0x7F;

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, 127				; 0000007fH
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+32], al

; 122  :       if (rom_bank_number == 0)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+32]
	test	eax, eax
	jne	SHORT $LN12@Write

; 123  :         rom_bank_number = 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+32], 1
$LN12@Write:

; 124  :     } else if (address >= 0x4000 && address <= 0x5FFF) {

	jmp	$LN11@Write
$LN13@Write:
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 16384				; 00004000H
	jl	SHORT $LN10@Write
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 24575				; 00005fffH
	jg	SHORT $LN10@Write

; 125  :       if (data>=0&&data<=3) {

	movzx	eax, BYTE PTR data$[rsp]
	test	eax, eax
	jl	SHORT $LN9@Write
	movzx	eax, BYTE PTR data$[rsp]
	cmp	eax, 3
	jg	SHORT $LN9@Write

; 126  :         mode = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+33], 0

; 127  :         ram_bank_number = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+34], cl
	jmp	SHORT $LN8@Write
$LN9@Write:

; 128  :       } else if (data>=0x08&&data<=0x0C) {

	movzx	eax, BYTE PTR data$[rsp]
	cmp	eax, 8
	jl	SHORT $LN7@Write
	movzx	eax, BYTE PTR data$[rsp]
	cmp	eax, 12
	jg	SHORT $LN7@Write

; 129  :         mode = 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+33], 1

; 130  :         rtc_select = data-0x08;

	movzx	eax, BYTE PTR data$[rsp]
	sub	eax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+41], al
$LN7@Write:
$LN8@Write:

; 131  :       }

	jmp	$LN6@Write
$LN10@Write:

; 132  :     } else if (address >= 0x6000 && address <= 0x7FFF) {

	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 24576				; 00006000H
	jl	SHORT $LN5@Write
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 32767				; 00007fffH
	jg	SHORT $LN5@Write
	jmp	$LN4@Write
$LN5@Write:

; 133  :       
; 134  : 
; 135  :     } else if (address >= 0xA000 && address <= 0xBFFF) {

	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 40960				; 0000a000H
	jl	SHORT $LN3@Write
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 49151				; 0000bfffH
	jg	SHORT $LN3@Write

; 136  :       if ((eram_enable&0x0A)==0x0A&&mode==0)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+24]
	and	eax, 10
	cmp	eax, 10
	jne	SHORT $LN2@Write
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	test	eax, eax
	jne	SHORT $LN2@Write

; 137  :         eram_[address&0x1FFF] = data;

	movzx	eax, WORD PTR address$[rsp]
	and	eax, 8191				; 00001fffH
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	movzx	edx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rcx+rax], dl
$LN2@Write:

; 138  :       
; 139  :       if ((rtc_enable&0x0A)==0x0A&&mode==1)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	eax, 10
	cmp	eax, 10
	jne	SHORT $LN1@Write
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	cmp	eax, 1
	jne	SHORT $LN1@Write

; 140  :         rtc[rtc_select] = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rcx+rax+35], dl
$LN1@Write:
$LN3@Write:
$LN4@Write:
$LN6@Write:
$LN11@Write:
$LN14@Write:

; 141  : 	  }
; 142  :   }

	pop	rdi
	ret	0
?Write@MBC3@gb@emulation@@UEAAXGE@Z ENDP		; emulation::gb::MBC3::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Read@MBC3@gb@emulation@@UEAAEG@Z
_TEXT	SEGMENT
this$ = 48
address$ = 56
?Read@MBC3@gb@emulation@@UEAAEG@Z PROC			; emulation::gb::MBC3::Read, COMDAT

; 98   :   uint8_t Read(uint16_t address) {

$LN10:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 99   :     if (address >= 0x0000 && address <= 0x3FFF) {

	movzx	eax, WORD PTR address$[rsp]
	test	eax, eax
	jl	SHORT $LN7@Read
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 16383				; 00003fffH
	jg	SHORT $LN7@Read

; 100  : 	    return cartridge->rom()[address];

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?rom@Cartridge@gb@emulation@@QEAAPEBEXZ	; emulation::gb::Cartridge::rom
	movzx	ecx, WORD PTR address$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	jmp	$LN8@Read
	jmp	$LN6@Read
$LN7@Read:

; 101  : 	  } else if (address >= 0x4000 && address <= 0x7FFF) {

	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 16384				; 00004000H
	jl	SHORT $LN5@Read
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 32767				; 00007fffH
	jg	SHORT $LN5@Read

; 102  :       return cartridge->rom()[address+0x4000*(rom_bank_number-1)];

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?rom@Cartridge@gb@emulation@@QEAAPEBEXZ	; emulation::gb::Cartridge::rom
	movzx	ecx, WORD PTR address$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+32]
	dec	edx
	imul	edx, 16384				; 00004000H
	add	ecx, edx
	movsxd	rcx, ecx
	movzx	eax, BYTE PTR [rax+rcx]
	jmp	$LN8@Read
	jmp	$LN4@Read
$LN5@Read:

; 103  :     } else if (address >= 0xA000 && address <= 0xBFFF) {

	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 40960				; 0000a000H
	jl	$LN3@Read
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 49151				; 0000bfffH
	jg	$LN3@Read

; 104  : 
; 105  : 
; 106  :       if ((eram_enable&0x0A)==0x0A&&mode==0)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+24]
	and	eax, 10
	cmp	eax, 10
	jne	SHORT $LN2@Read
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	test	eax, eax
	jne	SHORT $LN2@Read

; 107  :         return eram_[(address&0x1FFF)+(0x2000*ram_bank_number*mode)];

	movzx	eax, WORD PTR address$[rsp]
	and	eax, 8191				; 00001fffH
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+34]
	imul	ecx, 8192				; 00002000H
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+33]
	imul	ecx, edx
	add	eax, ecx
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	movzx	eax, BYTE PTR [rcx+rax]
	jmp	SHORT $LN8@Read
$LN2@Read:

; 108  :       
; 109  :       if ((rtc_enable&0x0A)==0x0A&&mode==1)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	eax, 10
	cmp	eax, 10
	jne	SHORT $LN1@Read
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	cmp	eax, 1
	jne	SHORT $LN1@Read

; 110  :         return rtc[rtc_select];

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+35]
	jmp	SHORT $LN8@Read
$LN1@Read:

; 111  : 
; 112  :       return 0;

	xor	al, al
	jmp	SHORT $LN8@Read
$LN3@Read:
$LN4@Read:
$LN6@Read:

; 113  :     }
; 114  :     return 0;

	xor	al, al
$LN8@Read:

; 115  :   }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Read@MBC3@gb@emulation@@UEAAEG@Z ENDP			; emulation::gb::MBC3::Read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Deinitialize@MBC3@gb@emulation@@UEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Deinitialize@MBC3@gb@emulation@@UEAAXXZ PROC		; emulation::gb::MBC3::Deinitialize, COMDAT

; 95   :   void Deinitialize() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 96   :     MemoryBankController::Deinitialize();

	mov	rcx, QWORD PTR this$[rsp]
	call	?Deinitialize@MemoryBankController@gb@emulation@@UEAAXXZ ; emulation::gb::MemoryBankController::Deinitialize

; 97   :   }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Deinitialize@MBC3@gb@emulation@@UEAAXXZ ENDP		; emulation::gb::MBC3::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Initialize@MBC3@gb@emulation@@UEAAXPEAVCartridge@23@@Z
_TEXT	SEGMENT
this$ = 48
cartridge$ = 56
?Initialize@MBC3@gb@emulation@@UEAAXPEAVCartridge@23@@Z PROC ; emulation::gb::MBC3::Initialize, COMDAT

; 82   :   void Initialize(Cartridge* cartridge) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 83   :     MemoryBankController::Initialize(cartridge);

	mov	rdx, QWORD PTR cartridge$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?Initialize@MemoryBankController@gb@emulation@@UEAAXPEAVCartridge@23@@Z ; emulation::gb::MemoryBankController::Initialize

; 84   :     eram_enable = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+24], 0

; 85   :     eram_enable = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+24], 0

; 86   :     rom_bank_number = 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+32], 1

; 87   :     ram_bank_number = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+34], 0

; 88   :     mode = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+33], 0

; 89   :     rtc_enable = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+40], 0

; 90   :     rtc_select = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+41], 0

; 91   :     counter1 = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+42], 0

; 92   :     counter2 = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+44], ax

; 93   :     memset(rtc,0,sizeof(rtc));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 35					; 00000023H
	mov	r8d, 5
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 94   :   }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Initialize@MBC3@gb@emulation@@UEAAXPEAVCartridge@23@@Z ENDP ; emulation::gb::MBC3::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0MBC1@gb@emulation@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0MBC1@gb@emulation@@QEAA@XZ PROC			; emulation::gb::MBC1::MBC1, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0MemoryBankController@gb@emulation@@QEAA@XZ
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7MBC1@gb@emulation@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0MBC1@gb@emulation@@QEAA@XZ ENDP			; emulation::gb::MBC1::MBC1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Write@MBC1@gb@emulation@@UEAAXGE@Z
_TEXT	SEGMENT
this$ = 16
address$ = 24
data$ = 32
?Write@MBC1@gb@emulation@@UEAAXGE@Z PROC		; emulation::gb::MBC1::Write, COMDAT

; 52   :   void Write(uint16_t address, uint8_t data) {

$LN16:
	mov	BYTE PTR [rsp+24], r8b
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 53   :    if (address >= 0x0000 && address <= 0x1FFF) {

	movzx	eax, WORD PTR address$[rsp]
	test	eax, eax
	jl	SHORT $LN13@Write
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 8191				; 00001fffH
	jg	SHORT $LN13@Write

; 54   : 	    eram_enable = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+24], cl
	jmp	$LN12@Write
$LN13@Write:

; 55   : 	  } else if (address >= 0x2000 && address <= 0x3FFF) {

	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 8192				; 00002000H
	jl	SHORT $LN11@Write
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 16383				; 00003fffH
	jg	SHORT $LN11@Write

; 56   :       rom_bank_number = data&0x1F;

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, 31
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+32], al

; 57   :       if (rom_bank_number == 0)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+32]
	test	eax, eax
	jne	SHORT $LN10@Write

; 58   :         rom_bank_number = 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+32], 1
$LN10@Write:

; 59   :     } else if (address >= 0x4000 && address <= 0x5FFF) {

	jmp	$LN9@Write
$LN11@Write:
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 16384				; 00004000H
	jl	SHORT $LN8@Write
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 24575				; 00005fffH
	jg	SHORT $LN8@Write

; 60   :       if (mode==0) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	test	eax, eax
	jne	SHORT $LN7@Write

; 61   :         rom_bank_number |= (data&0x3)<<5;

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, 3
	shl	eax, 5
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+32]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+32], al

; 62   :         //ram_bank_number = 0;
; 63   :       } else {

	jmp	SHORT $LN6@Write
$LN7@Write:

; 64   :         //rom_bank_number &= 0x1F;
; 65   :         ram_bank_number = data&3;

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+34], al
$LN6@Write:

; 66   :       }

	jmp	SHORT $LN5@Write
$LN8@Write:

; 67   :     } else if (address >= 0x6000 && address <= 0x7FFF) {

	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 24576				; 00006000H
	jl	SHORT $LN4@Write
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 32767				; 00007fffH
	jg	SHORT $LN4@Write

; 68   :        mode = data&1;

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+33], al
	jmp	SHORT $LN3@Write
$LN4@Write:

; 69   : 
; 70   :     } else if (address >= 0xA000 && address <= 0xBFFF) {

	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 40960				; 0000a000H
	jl	SHORT $LN2@Write
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 49151				; 0000bfffH
	jg	SHORT $LN2@Write

; 71   :       if ((eram_enable&0x0A)==0x0A)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+24]
	and	eax, 10
	cmp	eax, 10
	jne	SHORT $LN1@Write

; 72   :         eram_[address&0x1FFF] = data;

	movzx	eax, WORD PTR address$[rsp]
	and	eax, 8191				; 00001fffH
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	movzx	edx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rcx+rax], dl
$LN1@Write:
$LN2@Write:
$LN3@Write:
$LN5@Write:
$LN9@Write:
$LN12@Write:

; 73   : 	  }
; 74   :   }

	pop	rdi
	ret	0
?Write@MBC1@gb@emulation@@UEAAXGE@Z ENDP		; emulation::gb::MBC1::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Read@MBC1@gb@emulation@@UEAAEG@Z
_TEXT	SEGMENT
this$ = 48
address$ = 56
?Read@MBC1@gb@emulation@@UEAAEG@Z PROC			; emulation::gb::MBC1::Read, COMDAT

; 39   :   uint8_t Read(uint16_t address) {

$LN10:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 40   :     if (address >= 0x0000 && address <= 0x3FFF) {

	movzx	eax, WORD PTR address$[rsp]
	test	eax, eax
	jl	SHORT $LN7@Read
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 16383				; 00003fffH
	jg	SHORT $LN7@Read

; 41   : 	    return cartridge->rom()[address];

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?rom@Cartridge@gb@emulation@@QEAAPEBEXZ	; emulation::gb::Cartridge::rom
	movzx	ecx, WORD PTR address$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	jmp	$LN8@Read
	jmp	$LN6@Read
$LN7@Read:

; 42   : 	  } else if (address >= 0x4000 && address <= 0x7FFF) {

	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 16384				; 00004000H
	jl	SHORT $LN5@Read
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 32767				; 00007fffH
	jg	SHORT $LN5@Read

; 43   :       return cartridge->rom()[address+0x4000*(rom_bank_number-1)];

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?rom@Cartridge@gb@emulation@@QEAAPEBEXZ	; emulation::gb::Cartridge::rom
	movzx	ecx, WORD PTR address$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+32]
	dec	edx
	imul	edx, 16384				; 00004000H
	add	ecx, edx
	movsxd	rcx, ecx
	movzx	eax, BYTE PTR [rax+rcx]
	jmp	SHORT $LN8@Read
	jmp	SHORT $LN4@Read
$LN5@Read:

; 44   :     } else if (address >= 0xA000 && address <= 0xBFFF) {

	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 40960				; 0000a000H
	jl	SHORT $LN3@Read
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 49151				; 0000bfffH
	jg	SHORT $LN3@Read

; 45   :       if ((eram_enable&0x0A)==0x0A)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+24]
	and	eax, 10
	cmp	eax, 10
	jne	SHORT $LN2@Read

; 46   :         return eram_[(address&0x1FFF)+(0x2000*ram_bank_number*mode)];

	movzx	eax, WORD PTR address$[rsp]
	and	eax, 8191				; 00001fffH
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+34]
	imul	ecx, 8192				; 00002000H
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+33]
	imul	ecx, edx
	add	eax, ecx
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	movzx	eax, BYTE PTR [rcx+rax]
	jmp	SHORT $LN8@Read

; 47   :       else

	jmp	SHORT $LN1@Read
$LN2@Read:

; 48   :         return 0;

	xor	al, al
	jmp	SHORT $LN8@Read
$LN1@Read:
$LN3@Read:
$LN4@Read:
$LN6@Read:

; 49   :     }
; 50   :     return 0;

	xor	al, al
$LN8@Read:

; 51   :   }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Read@MBC1@gb@emulation@@UEAAEG@Z ENDP			; emulation::gb::MBC1::Read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Deinitialize@MBC1@gb@emulation@@UEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Deinitialize@MBC1@gb@emulation@@UEAAXXZ PROC		; emulation::gb::MBC1::Deinitialize, COMDAT

; 36   :   void Deinitialize() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 37   :     MemoryBankController::Deinitialize();

	mov	rcx, QWORD PTR this$[rsp]
	call	?Deinitialize@MemoryBankController@gb@emulation@@UEAAXXZ ; emulation::gb::MemoryBankController::Deinitialize

; 38   :   }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Deinitialize@MBC1@gb@emulation@@UEAAXXZ ENDP		; emulation::gb::MBC1::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Initialize@MBC1@gb@emulation@@UEAAXPEAVCartridge@23@@Z
_TEXT	SEGMENT
this$ = 48
cartridge$ = 56
?Initialize@MBC1@gb@emulation@@UEAAXPEAVCartridge@23@@Z PROC ; emulation::gb::MBC1::Initialize, COMDAT

; 28   :   void Initialize(Cartridge* cartridge) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 29   :     MemoryBankController::Initialize(cartridge);

	mov	rdx, QWORD PTR cartridge$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?Initialize@MemoryBankController@gb@emulation@@UEAAXPEAVCartridge@23@@Z ; emulation::gb::MemoryBankController::Initialize

; 30   :     eram_enable = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+24], 0

; 31   :     eram_enable = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+24], 0

; 32   :     rom_bank_number = 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+32], 1

; 33   :     ram_bank_number = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+34], 0

; 34   :     mode = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+33], 0

; 35   :   }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Initialize@MBC1@gb@emulation@@UEAAXPEAVCartridge@23@@Z ENDP ; emulation::gb::MBC1::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0MBCNone@gb@emulation@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0MBCNone@gb@emulation@@QEAA@XZ PROC			; emulation::gb::MBCNone::MBCNone, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0MemoryBankController@gb@emulation@@QEAA@XZ
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7MBCNone@gb@emulation@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0MBCNone@gb@emulation@@QEAA@XZ ENDP			; emulation::gb::MBCNone::MBCNone
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Write@MBCNone@gb@emulation@@UEAAXGE@Z
_TEXT	SEGMENT
a$ = 0
this$ = 32
address$ = 40
data$ = 48
?Write@MBCNone@gb@emulation@@UEAAXGE@Z PROC		; emulation::gb::MBCNone::Write, COMDAT

; 21   :   void Write(uint16_t address, uint8_t data) {

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 22   :     int a = 1;

	mov	DWORD PTR a$[rsp], 1

; 23   :   }

	add	rsp, 16
	pop	rdi
	ret	0
?Write@MBCNone@gb@emulation@@UEAAXGE@Z ENDP		; emulation::gb::MBCNone::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Read@MBCNone@gb@emulation@@UEAAEG@Z
_TEXT	SEGMENT
this$ = 48
address$ = 56
?Read@MBCNone@gb@emulation@@UEAAEG@Z PROC		; emulation::gb::MBCNone::Read, COMDAT

; 11   :   uint8_t Read(uint16_t address) {

$LN8:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 12   :       if (address >= 0x0000 && address <= 0x3FFF) {

	movzx	eax, WORD PTR address$[rsp]
	test	eax, eax
	jl	SHORT $LN5@Read
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 16383				; 00003fffH
	jg	SHORT $LN5@Read

; 13   : 	    return cartridge->rom()[address];

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?rom@Cartridge@gb@emulation@@QEAAPEBEXZ	; emulation::gb::Cartridge::rom
	movzx	ecx, WORD PTR address$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	jmp	SHORT $LN6@Read
	jmp	SHORT $LN4@Read
$LN5@Read:

; 14   : 	  } else if (address >= 0x4000 && address <= 0x7FFF) {

	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 16384				; 00004000H
	jl	SHORT $LN3@Read
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 32767				; 00007fffH
	jg	SHORT $LN3@Read

; 15   :       return cartridge->rom()[address];

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?rom@Cartridge@gb@emulation@@QEAAPEBEXZ	; emulation::gb::Cartridge::rom
	movzx	ecx, WORD PTR address$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	jmp	SHORT $LN6@Read
	jmp	SHORT $LN2@Read
$LN3@Read:

; 16   :     } else if (address >= 0xA000 && address <= 0xBFFF) {

	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 40960				; 0000a000H
	jl	SHORT $LN1@Read
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 49151				; 0000bfffH
	jg	SHORT $LN1@Read

; 17   :       return 0;

	xor	al, al
	jmp	SHORT $LN6@Read
$LN1@Read:
$LN2@Read:
$LN4@Read:

; 18   : 	  }
; 19   :     return 0;

	xor	al, al
$LN6@Read:

; 20   :   }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Read@MBCNone@gb@emulation@@UEAAEG@Z ENDP		; emulation::gb::MBCNone::Read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Deinitialize@MBCNone@gb@emulation@@UEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Deinitialize@MBCNone@gb@emulation@@UEAAXXZ PROC	; emulation::gb::MBCNone::Deinitialize, COMDAT

; 8    :   void Deinitialize() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 9    :     MemoryBankController::Deinitialize();

	mov	rcx, QWORD PTR this$[rsp]
	call	?Deinitialize@MemoryBankController@gb@emulation@@UEAAXXZ ; emulation::gb::MemoryBankController::Deinitialize

; 10   :   }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Deinitialize@MBCNone@gb@emulation@@UEAAXXZ ENDP	; emulation::gb::MBCNone::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\wincore\types.h
;	COMDAT ??$SafeDeleteArray@E@@YAXPEAPEAE@Z
_TEXT	SEGMENT
$T1 = 32
ppInterfaceToDelete$ = 64
??$SafeDeleteArray@E@@YAXPEAPEAE@Z PROC			; SafeDeleteArray<unsigned char>, COMDAT

; 45   : inline void SafeDeleteArray(Interface **ppInterfaceToDelete) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 46   :     if (*ppInterfaceToDelete != NULL) {

	mov	rax, QWORD PTR ppInterfaceToDelete$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN1@SafeDelete

; 47   :         delete [] (*ppInterfaceToDelete);

	mov	rax, QWORD PTR ppInterfaceToDelete$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	??_V@YAXPEAX@Z				; operator delete[]

; 48   :         (*ppInterfaceToDelete) = NULL;

	mov	rax, QWORD PTR ppInterfaceToDelete$[rsp]
	mov	QWORD PTR [rax], 0
$LN1@SafeDelete:

; 49   :     }
; 50   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$SafeDeleteArray@E@@YAXPEAPEAE@Z ENDP			; SafeDeleteArray<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0MemoryBankController@gb@emulation@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0MemoryBankController@gb@emulation@@QEAA@XZ PROC	; emulation::gb::MemoryBankController::MemoryBankController, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7MemoryBankController@gb@emulation@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0MemoryBankController@gb@emulation@@QEAA@XZ ENDP	; emulation::gb::MemoryBankController::MemoryBankController
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cartridge.h
;	COMDAT ?eram@MemoryBankController@gb@emulation@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 16
?eram@MemoryBankController@gb@emulation@@QEAAPEAEXZ PROC ; emulation::gb::MemoryBankController::eram, COMDAT

; 118  :   uint8_t* eram() { return eram_; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	pop	rdi
	ret	0
?eram@MemoryBankController@gb@emulation@@QEAAPEAEXZ ENDP ; emulation::gb::MemoryBankController::eram
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cartridge.h
;	COMDAT ?Tick@MemoryBankController@gb@emulation@@UEAAXXZ
_TEXT	SEGMENT
this$ = 16
?Tick@MemoryBankController@gb@emulation@@UEAAXXZ PROC	; emulation::gb::MemoryBankController::Tick, COMDAT

; 117  :   virtual void Tick() { }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	pop	rdi
	ret	0
?Tick@MemoryBankController@gb@emulation@@UEAAXXZ ENDP	; emulation::gb::MemoryBankController::Tick
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cartridge.h
;	COMDAT ?Deinitialize@MemoryBankController@gb@emulation@@UEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Deinitialize@MemoryBankController@gb@emulation@@UEAAXXZ PROC ; emulation::gb::MemoryBankController::Deinitialize, COMDAT

; 112  :   virtual void Deinitialize() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 113  :      SafeDeleteArray(&eram_); 

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, rax
	call	??$SafeDeleteArray@E@@YAXPEAPEAE@Z	; SafeDeleteArray<unsigned char>

; 114  :   };

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Deinitialize@MemoryBankController@gb@emulation@@UEAAXXZ ENDP ; emulation::gb::MemoryBankController::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cartridge.h
;	COMDAT ?Initialize@MemoryBankController@gb@emulation@@UEAAXPEAVCartridge@23@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 48
tv68 = 56
this$ = 80
cartridge$ = 88
?Initialize@MemoryBankController@gb@emulation@@UEAAXPEAVCartridge@23@@Z PROC ; emulation::gb::MemoryBankController::Initialize, COMDAT

; 103  :   virtual void Initialize(Cartridge* cartridge) {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 104  :     this->cartridge = cartridge;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR cartridge$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 105  :     switch (cartridge->header->ram_size) {

	mov	rax, QWORD PTR cartridge$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rax+73]
	mov	BYTE PTR tv68[rsp], al
	cmp	BYTE PTR tv68[rsp], 0
	je	SHORT $LN4@Initialize
	cmp	BYTE PTR tv68[rsp], 1
	je	SHORT $LN3@Initialize
	cmp	BYTE PTR tv68[rsp], 2
	je	SHORT $LN2@Initialize
	cmp	BYTE PTR tv68[rsp], 3
	je	SHORT $LN1@Initialize
	jmp	$LN5@Initialize
$LN4@Initialize:

; 106  :       case 0 : eram_ = nullptr; break;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	jmp	$LN5@Initialize
$LN3@Initialize:

; 107  :       case 1 : eram_ = new uint8_t[2048]; break;

	mov	r9d, 107				; 0000006bH
	lea	r8, OFFSET FLAT:??_C@_0EC@EPIJFGKG@d?3?2personal?2projects?2gbemu?2solut@
	mov	edx, 1
	mov	ecx, 2048				; 00000800H
	call	??_U@YAPEAX_KHPEBDH@Z			; operator new[]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rax+16], rcx
	jmp	SHORT $LN5@Initialize
$LN2@Initialize:

; 108  :       case 2 : eram_ = new uint8_t[0x2000]; break;

	mov	r9d, 108				; 0000006cH
	lea	r8, OFFSET FLAT:??_C@_0EC@EPIJFGKG@d?3?2personal?2projects?2gbemu?2solut@
	mov	edx, 1
	mov	ecx, 8192				; 00002000H
	call	??_U@YAPEAX_KHPEBDH@Z			; operator new[]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rax+16], rcx
	jmp	SHORT $LN5@Initialize
$LN1@Initialize:

; 109  :       case 3 : eram_ = new uint8_t[0x8000]; break;

	mov	r9d, 109				; 0000006dH
	lea	r8, OFFSET FLAT:??_C@_0EC@EPIJFGKG@d?3?2personal?2projects?2gbemu?2solut@
	mov	edx, 1
	mov	ecx, 32768				; 00008000H
	call	??_U@YAPEAX_KHPEBDH@Z			; operator new[]
	mov	QWORD PTR $T3[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rax+16], rcx
$LN5@Initialize:

; 110  :     }
; 111  :   }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?Initialize@MemoryBankController@gb@emulation@@UEAAXPEAVCartridge@23@@Z ENDP ; emulation::gb::MemoryBankController::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cartridge.cpp
_TEXT	SEGMENT
this$ = 48
address$ = 56
data$ = 64
?Write@Cartridge@gb@emulation@@QEAAXGE@Z PROC		; emulation::gb::Cartridge::Write

; 89   : void Cartridge::Write(uint16_t address, uint8_t data) {

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 90   :   mbc->Write(address,data);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax]
	movzx	r8d, BYTE PTR data$[rsp]
	movzx	edx, WORD PTR address$[rsp]
	call	QWORD PTR [rax+24]

; 91   : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Write@Cartridge@gb@emulation@@QEAAXGE@Z ENDP		; emulation::gb::Cartridge::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cartridge.cpp
_TEXT	SEGMENT
this$ = 48
address$ = 56
?Read@Cartridge@gb@emulation@@QEAAEG@Z PROC		; emulation::gb::Cartridge::Read

; 85   : uint8_t Cartridge::Read(uint16_t address) {

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 86   :   return mbc->Read(address);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax]
	movzx	edx, WORD PTR address$[rsp]
	call	QWORD PTR [rax+16]

; 87   : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Read@Cartridge@gb@emulation@@QEAAEG@Z ENDP		; emulation::gb::Cartridge::Read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cartridge.h
;	COMDAT ?rom@Cartridge@gb@emulation@@QEAAPEBEXZ
_TEXT	SEGMENT
this$ = 16
?rom@Cartridge@gb@emulation@@QEAAPEBEXZ PROC		; emulation::gb::Cartridge::rom, COMDAT

; 86   :   const uint8_t* rom() { return rom_; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	pop	rdi
	ret	0
?rom@Cartridge@gb@emulation@@QEAAPEBEXZ ENDP		; emulation::gb::Cartridge::rom
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cartridge.cpp
_TEXT	SEGMENT
filename$ = 48
fp$ = 312
tv77 = 328
__$ArrayPad$ = 336
this$ = 368
?SaveRam@Cartridge@gb@emulation@@QEAAXXZ PROC		; emulation::gb::Cartridge::SaveRam

; 77   : void Cartridge::SaveRam() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 352				; 00000160H
	mov	rdi, rsp
	mov	ecx, 88					; 00000058H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+368]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 78   :   char filename[256];
; 79   :   sprintf(filename,"%s.ram",header->title);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 52					; 00000034H
	mov	r8, rax
	lea	rdx, OFFSET FLAT:$SG113889
	lea	rcx, QWORD PTR filename$[rsp]
	call	QWORD PTR __imp_sprintf

; 80   :   FILE* fp = fopen(filename,"wb");

	lea	rdx, OFFSET FLAT:$SG113891
	lea	rcx, QWORD PTR filename$[rsp]
	call	QWORD PTR __imp_fopen
	mov	QWORD PTR fp$[rsp], rax

; 81   :   fwrite(mbc->eram(),1,header->ram_size_bytes(),fp);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	?ram_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ ; emulation::gb::CartridgeHeader::ram_size_bytes
	mov	eax, eax
	mov	QWORD PTR tv77[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	call	?eram@MemoryBankController@gb@emulation@@QEAAPEAEXZ ; emulation::gb::MemoryBankController::eram
	mov	r9, QWORD PTR fp$[rsp]
	mov	rcx, QWORD PTR tv77[rsp]
	mov	r8, rcx
	mov	edx, 1
	mov	rcx, rax
	call	QWORD PTR __imp_fwrite

; 82   :   fclose(fp);

	mov	rcx, QWORD PTR fp$[rsp]
	call	QWORD PTR __imp_fclose

; 83   : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:?SaveRam@Cartridge@gb@emulation@@QEAAXXZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 352				; 00000160H
	pop	rdi
	ret	0
?SaveRam@Cartridge@gb@emulation@@QEAAXXZ ENDP		; emulation::gb::Cartridge::SaveRam
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cartridge.cpp
_TEXT	SEGMENT
data$ = 40
length$ = 72
filename$ = 112
__$ArrayPad$ = 384
this$ = 416
?LoadRam@Cartridge@gb@emulation@@QEAAXXZ PROC		; emulation::gb::Cartridge::LoadRam

; 67   : void Cartridge::LoadRam() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 400				; 00000190H
	mov	rdi, rsp
	mov	ecx, 100				; 00000064H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+416]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 68   :   uint8_t* data=nullptr;

	mov	QWORD PTR data$[rsp], 0

; 69   :   size_t length;
; 70   :   char filename[256];
; 71   :   sprintf(filename,"%s.ram",header->title);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 52					; 00000034H
	mov	r8, rax
	lea	rdx, OFFSET FLAT:$SG113883
	lea	rcx, QWORD PTR filename$[rsp]
	call	QWORD PTR __imp_sprintf

; 72   :   core::io::ReadWholeFileBinary(filename,&data,length);

	lea	r8, QWORD PTR length$[rsp]
	lea	rdx, QWORD PTR data$[rsp]
	lea	rcx, QWORD PTR filename$[rsp]
	call	?ReadWholeFileBinary@io@core@@YAXPEBDPEAPEAEAEA_K@Z ; core::io::ReadWholeFileBinary

; 73   :   if (data)

	cmp	QWORD PTR data$[rsp], 0
	je	SHORT $LN1@LoadRam

; 74   :     memcpy(mbc->eram(),data,length);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	?eram@MemoryBankController@gb@emulation@@QEAAPEAEXZ ; emulation::gb::MemoryBankController::eram
	mov	r8, QWORD PTR length$[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	rcx, rax
	call	memcpy
$LN1@LoadRam:

; 75   : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:?LoadRam@Cartridge@gb@emulation@@QEAAXXZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 400				; 00000190H
	pop	rdi
	ret	0
?LoadRam@Cartridge@gb@emulation@@QEAAXXZ ENDP		; emulation::gb::Cartridge::LoadRam
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cartridge.cpp
_TEXT	SEGMENT
data$ = 40
length$ = 72
$T5 = 88
$T6 = 96
$T7 = 104
$T8 = 112
$T9 = 120
tv141 = 128
tv154 = 136
tv168 = 144
tv182 = 152
this$ = 176
filename$ = 184
header$ = 192
?LoadFile@Cartridge@gb@emulation@@QEAAXPEBDPEAUCartridgeHeader@23@@Z PROC ; emulation::gb::Cartridge::LoadFile

; 22   : void Cartridge::LoadFile(const char* filename, CartridgeHeader* header) {

$LN17:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 160				; 000000a0H
	mov	rdi, rsp
	mov	ecx, 40					; 00000028H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+176]

; 23   : 	SafeDeleteArray(&rom_);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??$SafeDeleteArray@E@@YAXPEAPEAE@Z	; SafeDeleteArray<unsigned char>

; 24   :   if (mbc) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN8@LoadFile

; 25   :     mbc->Deinitialize();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax]
	call	QWORD PTR [rax+8]

; 26   : 		delete mbc;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR $T5[rsp], rax
	mov	rcx, QWORD PTR $T5[rsp]
	call	??3@YAXPEAX@Z				; operator delete
$LN8@LoadFile:

; 27   : 	}
; 28   :   uint8_t* data;
; 29   :   size_t length;
; 30   :   core::io::ReadWholeFileBinary(filename,&data,length);

	lea	r8, QWORD PTR length$[rsp]
	lea	rdx, QWORD PTR data$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?ReadWholeFileBinary@io@core@@YAXPEBDPEAPEAEAEA_K@Z ; core::io::ReadWholeFileBinary

; 31   :   memcpy(header,data+0x100,0x50);

	mov	rax, QWORD PTR data$[rsp]
	add	rax, 256				; 00000100H
	mov	r8d, 80					; 00000050H
	mov	rdx, rax
	mov	rcx, QWORD PTR header$[rsp]
	call	memcpy

; 32   :   if (header->rom_size_bytes() == 0) {

	mov	rcx, QWORD PTR header$[rsp]
	call	?rom_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ ; emulation::gb::CartridgeHeader::rom_size_bytes
	test	eax, eax
	jne	SHORT $LN7@LoadFile

; 33   :     //report error
; 34   :     return;

	jmp	$LN9@LoadFile
$LN7@LoadFile:

; 35   :   }
; 36   :   rom_ = new uint8_t[header->rom_size_bytes()];

	mov	rcx, QWORD PTR header$[rsp]
	call	?rom_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ ; emulation::gb::CartridgeHeader::rom_size_bytes
	mov	eax, eax
	mov	r9d, 36					; 00000024H
	lea	r8, OFFSET FLAT:$SG113850
	mov	edx, 1
	mov	ecx, eax
	call	??_U@YAPEAX_KHPEBDH@Z			; operator new[]
	mov	QWORD PTR $T6[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR $T6[rsp]
	mov	QWORD PTR [rax+32], rcx

; 37   :   memcpy(rom_,data,header->rom_size_bytes());

	mov	rcx, QWORD PTR header$[rsp]
	call	?rom_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ ; emulation::gb::CartridgeHeader::rom_size_bytes
	mov	eax, eax
	mov	r8d, eax
	mov	rdx, QWORD PTR data$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+32]
	call	memcpy

; 38   :   this->header = (CartridgeHeader*)&rom_[0x100];

	mov	eax, 1
	imul	rax, 256				; 00000100H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+32]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 39   : 
; 40   :   switch (header->cartridge_type) {

	mov	rax, QWORD PTR header$[rsp]
	movzx	eax, BYTE PTR [rax+71]
	mov	BYTE PTR tv141[rsp], al
	cmp	BYTE PTR tv141[rsp], 0
	je	SHORT $LN4@LoadFile
	cmp	BYTE PTR tv141[rsp], 0
	jbe	$LN1@LoadFile
	cmp	BYTE PTR tv141[rsp], 3
	jbe	$LN3@LoadFile
	cmp	BYTE PTR tv141[rsp], 14
	jbe	$LN1@LoadFile
	cmp	BYTE PTR tv141[rsp], 19
	jbe	$LN2@LoadFile
	jmp	$LN1@LoadFile
$LN4@LoadFile:

; 41   :     case 0:
; 42   :       mbc = new MBCNone();

	mov	r9d, 42					; 0000002aH
	lea	r8, OFFSET FLAT:$SG113859
	mov	edx, 1
	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_KHPEBDH@Z			; operator new
	mov	QWORD PTR $T7[rsp], rax
	cmp	QWORD PTR $T7[rsp], 0
	je	SHORT $LN11@LoadFile
	mov	rcx, QWORD PTR $T7[rsp]
	call	??0MBCNone@gb@emulation@@QEAA@XZ
	mov	QWORD PTR tv154[rsp], rax
	jmp	SHORT $LN12@LoadFile
$LN11@LoadFile:
	mov	QWORD PTR tv154[rsp], 0
$LN12@LoadFile:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR tv154[rsp]
	mov	QWORD PTR [rax+24], rcx

; 43   :       break;

	jmp	$LN5@LoadFile
$LN3@LoadFile:

; 44   :     case 1:
; 45   :     case 2:
; 46   :     case 3:
; 47   :       mbc = new MBC1();

	mov	r9d, 47					; 0000002fH
	lea	r8, OFFSET FLAT:$SG113863
	mov	edx, 1
	mov	ecx, 40					; 00000028H
	call	??2@YAPEAX_KHPEBDH@Z			; operator new
	mov	QWORD PTR $T8[rsp], rax
	cmp	QWORD PTR $T8[rsp], 0
	je	SHORT $LN13@LoadFile
	mov	rcx, QWORD PTR $T8[rsp]
	call	??0MBC1@gb@emulation@@QEAA@XZ
	mov	QWORD PTR tv168[rsp], rax
	jmp	SHORT $LN14@LoadFile
$LN13@LoadFile:
	mov	QWORD PTR tv168[rsp], 0
$LN14@LoadFile:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR tv168[rsp]
	mov	QWORD PTR [rax+24], rcx

; 48   :       break;

	jmp	SHORT $LN5@LoadFile
$LN2@LoadFile:

; 49   :     case 0x0F:
; 50   :     case 0x10:
; 51   :     case 0x11:
; 52   :     case 0x12:
; 53   :     case 0x13:
; 54   :       mbc = new MBC3();

	mov	r9d, 54					; 00000036H
	lea	r8, OFFSET FLAT:$SG113867
	mov	edx, 1
	mov	ecx, 48					; 00000030H
	call	??2@YAPEAX_KHPEBDH@Z			; operator new
	mov	QWORD PTR $T9[rsp], rax
	cmp	QWORD PTR $T9[rsp], 0
	je	SHORT $LN15@LoadFile
	mov	rcx, QWORD PTR $T9[rsp]
	call	??0MBC3@gb@emulation@@QEAA@XZ
	mov	QWORD PTR tv182[rsp], rax
	jmp	SHORT $LN16@LoadFile
$LN15@LoadFile:
	mov	QWORD PTR tv182[rsp], 0
$LN16@LoadFile:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR tv182[rsp]
	mov	QWORD PTR [rax+24], rcx

; 55   :       break;

	jmp	SHORT $LN5@LoadFile
$LN1@LoadFile:

; 56   :     default:
; 57   :       DebugBreak();

	call	QWORD PTR __imp_DebugBreak
$LN5@LoadFile:

; 58   :   }
; 59   : 
; 60   :   mbc->Initialize(this);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax]
	mov	rdx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax]

; 61   :   LoadRam();

	mov	rcx, QWORD PTR this$[rsp]
	call	?LoadRam@Cartridge@gb@emulation@@QEAAXXZ ; emulation::gb::Cartridge::LoadRam

; 62   :   core::io::DestroyFileBuffer(&data);

	lea	rcx, QWORD PTR data$[rsp]
	call	?DestroyFileBuffer@io@core@@YAXPEAPEAE@Z ; core::io::DestroyFileBuffer
$LN9@LoadFile:

; 63   : 
; 64   :   
; 65   : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:?LoadFile@Cartridge@gb@emulation@@QEAAXPEBDPEAUCartridgeHeader@23@@Z$rtcFrameData
	call	_RTC_CheckStackVars
	add	rsp, 160				; 000000a0H
	pop	rdi
	ret	0
?LoadFile@Cartridge@gb@emulation@@QEAAXPEBDPEAUCartridgeHeader@23@@Z ENDP ; emulation::gb::Cartridge::LoadFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cartridge.cpp
_TEXT	SEGMENT
this$ = 48
?Deinitialize@Cartridge@gb@emulation@@UEAAXXZ PROC	; emulation::gb::Cartridge::Deinitialize

; 13   : void Cartridge::Deinitialize() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 14   :   if (mbc) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 0
	je	SHORT $LN1@Deinitiali

; 15   :     SaveRam();

	mov	rcx, QWORD PTR this$[rsp]
	call	?SaveRam@Cartridge@gb@emulation@@QEAAXXZ ; emulation::gb::Cartridge::SaveRam

; 16   :     mbc->Deinitialize();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax]
	call	QWORD PTR [rax+8]
$LN1@Deinitiali:

; 17   :   }
; 18   :   SafeDelete(&mbc);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??$SafeDelete@VMemoryBankController@gb@emulation@@@@YAXPEAPEAVMemoryBankController@gb@emulation@@@Z ; SafeDelete<emulation::gb::MemoryBankController>

; 19   :   core::io::DestroyFileBuffer(&rom_);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	?DestroyFileBuffer@io@core@@YAXPEAPEAE@Z ; core::io::DestroyFileBuffer

; 20   : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Deinitialize@Cartridge@gb@emulation@@UEAAXXZ ENDP	; emulation::gb::Cartridge::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cartridge.cpp
_TEXT	SEGMENT
this$ = 48
emu$ = 56
?Initialize@Cartridge@gb@emulation@@UEAAXPEAVEmu@23@@Z PROC ; emulation::gb::Cartridge::Initialize

; 7    : void Cartridge::Initialize(Emu* emu) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 8    :   Component::Initialize(emu);

	mov	rdx, QWORD PTR emu$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z ; emulation::gb::Component::Initialize

; 9    :   rom_ = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+32], 0

; 10   :   mbc = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 11   : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Initialize@Cartridge@gb@emulation@@UEAAXPEAVEmu@23@@Z ENDP ; emulation::gb::Cartridge::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cartridge.h
;	COMDAT ?ram_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?ram_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ PROC ; emulation::gb::CartridgeHeader::ram_size_bytes, COMDAT

; 64   :   uint32_t ram_size_bytes() {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 65   :     switch (ram_size) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+73]
	mov	BYTE PTR tv66[rsp], al
	cmp	BYTE PTR tv66[rsp], 0
	je	SHORT $LN7@ram_size_b
	cmp	BYTE PTR tv66[rsp], 1
	je	SHORT $LN3@ram_size_b
	cmp	BYTE PTR tv66[rsp], 2
	je	SHORT $LN2@ram_size_b
	cmp	BYTE PTR tv66[rsp], 3
	je	SHORT $LN1@ram_size_b
	jmp	SHORT $LN8@ram_size_b
$LN7@ram_size_b:

; 66   :       case 0: if (cartridge_type==5 || cartridge_type==6) return 256; else return 0;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+71]
	cmp	eax, 5
	je	SHORT $LN5@ram_size_b
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+71]
	cmp	eax, 6
	jne	SHORT $LN6@ram_size_b
$LN5@ram_size_b:
	mov	eax, 256				; 00000100H
	jmp	SHORT $LN10@ram_size_b
	jmp	SHORT $LN4@ram_size_b
$LN6@ram_size_b:
	xor	eax, eax
	jmp	SHORT $LN10@ram_size_b
$LN4@ram_size_b:
$LN3@ram_size_b:

; 67   :       case 1:return 2*1024;

	mov	eax, 2048				; 00000800H
	jmp	SHORT $LN10@ram_size_b
$LN2@ram_size_b:

; 68   :       case 2:return 8*1024;

	mov	eax, 8192				; 00002000H
	jmp	SHORT $LN10@ram_size_b
$LN1@ram_size_b:

; 69   :       case 3:return 32*1024;

	mov	eax, 32768				; 00008000H
	jmp	SHORT $LN10@ram_size_b
$LN8@ram_size_b:

; 70   :     }
; 71   :     return 0;

	xor	eax, eax
$LN10@ram_size_b:

; 72   :   }

	add	rsp, 16
	pop	rdi
	ret	0
?ram_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ ENDP ; emulation::gb::CartridgeHeader::ram_size_bytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cartridge.h
;	COMDAT ?rom_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ
_TEXT	SEGMENT
tv82 = 0
tv72 = 4
this$ = 32
?rom_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ PROC ; emulation::gb::CartridgeHeader::rom_size_bytes, COMDAT

; 51   :   uint32_t rom_size_bytes() {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 52   :     if (rom_size < 10){

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	cmp	eax, 10
	jge	SHORT $LN7@rom_size_b

; 53   :       return 0x8000 << rom_size;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	ecx, 32768				; 00008000H
	mov	DWORD PTR tv82[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv82[rsp]
	shl	eax, cl
	jmp	SHORT $LN8@rom_size_b

; 54   :     } else {

	jmp	SHORT $LN6@rom_size_b
$LN7@rom_size_b:

; 55   :       switch (rom_size) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+72]
	mov	BYTE PTR tv72[rsp], al
	cmp	BYTE PTR tv72[rsp], 82			; 00000052H
	je	SHORT $LN3@rom_size_b
	cmp	BYTE PTR tv72[rsp], 83			; 00000053H
	je	SHORT $LN2@rom_size_b
	cmp	BYTE PTR tv72[rsp], 84			; 00000054H
	je	SHORT $LN1@rom_size_b
	jmp	SHORT $LN4@rom_size_b
$LN3@rom_size_b:

; 56   :         case 0x52:return 0x120000;

	mov	eax, 1179648				; 00120000H
	jmp	SHORT $LN8@rom_size_b
$LN2@rom_size_b:

; 57   :         case 0x53:return 0x140000;

	mov	eax, 1310720				; 00140000H
	jmp	SHORT $LN8@rom_size_b
$LN1@rom_size_b:

; 58   :         case 0x54:return 0x180000;

	mov	eax, 1572864				; 00180000H
	jmp	SHORT $LN8@rom_size_b
$LN4@rom_size_b:
$LN6@rom_size_b:

; 59   :       }
; 60   :     }
; 61   :     return 0;

	xor	eax, eax
$LN8@rom_size_b:

; 62   :   }

	add	rsp, 16
	pop	rdi
	ret	0
?rom_size_bytes@CartridgeHeader@gb@emulation@@QEAAIXZ ENDP ; emulation::gb::CartridgeHeader::rom_size_bytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\gb.h
;	COMDAT ?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z
_TEXT	SEGMENT
this$ = 16
emu$ = 24
?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z PROC ; emulation::gb::Component::Initialize, COMDAT

; 28   :   virtual void Initialize(Emu* emu) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 29   :     emu_ = emu;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR emu$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 30   :   }

	pop	rdi
	ret	0
?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z ENDP ; emulation::gb::Component::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$yc	SEGMENT
$T1 = 0
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 137  : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	add	rsp, 16
	pop	rdi
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$yc	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 130  : const _Ignore ignore;

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:ignore
	call	??0_Ignore@std@@QEAA@XZ			; std::_Ignore::_Ignore
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0_Ignore@std@@QEAA@XZ PROC				; std::_Ignore::_Ignore, COMDAT

; 120  : 	_Ignore()

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 121  : 		{	// construct
; 122  : 		}

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0_Ignore@std@@QEAA@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = 0
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	add	rsp, 16
	pop	rdi
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = 0
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	add	rsp, 16
	pop	rdi
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
