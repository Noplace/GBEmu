; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?num@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::num
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?den@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::den
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?is_monotonic@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_monotonic
PUBLIC	?is_steady@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_steady
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	ConcRT_ProviderGuid
PUBLIC	ConcRTEventGuid
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	SchedulerEventGuid
PUBLIC	ScheduleGroupEventGuid
PUBLIC	ContextEventGuid
PUBLIC	ChoreEventGuid
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	VirtualProcessorEventGuid
PUBLIC	LockEventGuid
PUBLIC	ResourceManagerEventGuid
PUBLIC	PPLParallelInvokeEventGuid
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	PPLParallelForEventGuid
PUBLIC	PPLParallelForeachEventGuid
PUBLIC	AgentEventGuid
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB		; std::_GcdX<10000000,1>::value
PUBLIC	?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB		; std::_GcdX<1,10000000>::value
PUBLIC	?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB		; std::_Gcd<1,10000000>::value
PUBLIC	?value@?$integral_constant@_K$0A@@std@@2_KB	; std::integral_constant<unsigned __int64,0>::value
PUBLIC	?num@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::num
PUBLIC	?den@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::den
PUBLIC	?value@?$integral_constant@H$0A@@std@@2HB	; std::integral_constant<int,0>::value
PUBLIC	?value@?$_Abs@$0GE@@std@@2_JB			; std::_Abs<100>::value
PUBLIC	?value@?$_Abs@$0DLJKMKAA@@std@@2_JB		; std::_Abs<1000000000>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
PUBLIC	?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
PUBLIC	?value@?$_GcdX@$0GE@$0A@@std@@2_JB		; std::_GcdX<100,0>::value
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB	; std::_GcdX<1000000000,100>::value
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<100,1000000000>::value
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<100,1000000000>::value
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?value@?$_Abs@$00@std@@2_JB			; std::_Abs<1>::value
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?value@?$_GcdX@$00$0A@@std@@2_JB		; std::_GcdX<1,0>::value
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?value@?$_GcdX@$00$00@std@@2_JB			; std::_GcdX<1,1>::value
PUBLIC	?value@?$_Gcd@$00$00@std@@2_JB			; std::_Gcd<1,1>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?is_monotonic@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_monotonic
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?is_steady@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_steady
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
PUBLIC	?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
PUBLIC	?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
PUBLIC	?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
PUBLIC	?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_nonNull
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelException
PUBLIC	?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_notInlined
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_structured
PUBLIC	?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_localCancel
PUBLIC	?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_reserved
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
PUBLIC	?value@?$_Abs@$0JIJGIA@@std@@2_JB		; std::_Abs<10000000>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB		; std::_GcdX<10000000,0>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_GcdX<10000000,10000000>::value
PUBLIC	?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Gcd<10000000,10000000>::value
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0JIJGIA@@std@@2_JB DQ 0000000000989680H	; std::_Abs<10000000>::value
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_reserved
CONST	ENDS
;	COMDAT ?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_localCancel
CONST	ENDS
;	COMDAT ?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_structured
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB DD 0ffffffffH ; Concurrency::details::_TaskCollectionBase::_S_notInlined
CONST	ENDS
;	COMDAT ?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB DQ 000000000000000cH ; Concurrency::details::_TaskCollectionBase::_S_cancelException
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000008H ; Concurrency::details::_TaskCollectionBase::_S_nonNull
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000003H ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
CONST	ENDS
;	COMDAT ?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000002H ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
CONST	ENDS
;	COMDAT ?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000001H ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
CONST	ENDS
;	COMDAT ?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000000H ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
CONST	ENDS
;	COMDAT ?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000003H ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?is_steady@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@system_clock@chrono@std@@2_NB DB 00H		; std::chrono::system_clock::is_steady
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?is_monotonic@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@system_clock@chrono@std@@2_NB DB 00H	; std::chrono::system_clock::is_monotonic
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB DQ 0000000000000000H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1>::value
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0A@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?value@?$_Abs@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$00@std@@2_JB DQ 0000000000000001H	; std::_Abs<1>::value
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_Gcd<100,1000000000>::value
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<100,1000000000>::value
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<1000000000,100>::value
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB DD 03H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 02H ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0A@@std@@2_JB DQ 0000000000000064H	; std::_GcdX<100,0>::value
CONST	ENDS
;	COMDAT ?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 01H ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
CONST	ENDS
;	COMDAT ?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB DD 00H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Abs<1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0GE@@std@@2_JB DQ 0000000000000064H	; std::_Abs<100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@H$0A@@std@@2HB
CONST	SEGMENT
?value@?$integral_constant@H$0A@@std@@2HB DD 00H	; std::integral_constant<int,0>::value
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::ratio<1,10000000>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,10000000>::num
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_K$0A@@std@@2_KB
CONST	SEGMENT
?value@?$integral_constant@_K$0A@@std@@2_KB DQ 0000000000000000H ; std::integral_constant<unsigned __int64,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000000,1>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT AgentEventGuid
CONST	SEGMENT
AgentEventGuid DD 0b9b5b78cH
	DW	0713H
	DW	04898H
	DB	0a2H
	DB	01aH
	DB	0c6H
	DB	079H
	DB	049H
	DB	0dcH
	DB	0edH
	DB	07H
CONST	ENDS
;	COMDAT PPLParallelForeachEventGuid
CONST	SEGMENT
PPLParallelForeachEventGuid DD 05cb7d785H
	DW	09d66H
	DW	0465dH
	DB	0baH
	DB	0e1H
	DB	046H
	DB	011H
	DB	06H
	DB	01bH
	DB	054H
	DB	034H
CONST	ENDS
;	COMDAT PPLParallelForEventGuid
CONST	SEGMENT
PPLParallelForEventGuid DD 031c8da6bH
	DW	06165H
	DW	04042H
	DB	08bH
	DB	092H
	DB	094H
	DB	09eH
	DB	031H
	DB	05fH
	DB	04dH
	DB	084H
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT PPLParallelInvokeEventGuid
CONST	SEGMENT
PPLParallelInvokeEventGuid DD 0d1b5b133H
	DW	0ec3dH
	DW	049f4H
	DB	098H
	DB	0a3H
	DB	046H
	DB	04dH
	DB	01aH
	DB	09eH
	DB	046H
	DB	082H
CONST	ENDS
;	COMDAT ResourceManagerEventGuid
CONST	SEGMENT
ResourceManagerEventGuid DD 02718d25bH
	DW	05bf5H
	DW	04479H
	DB	08eH
	DB	088H
	DB	0baH
	DB	0bcH
	DB	064H
	DB	0bdH
	DB	0bfH
	DB	0caH
CONST	ENDS
;	COMDAT LockEventGuid
CONST	SEGMENT
LockEventGuid DD 079a60dc6H
	DW	05fc8H
	DW	04952H
	DB	0a4H
	DB	01cH
	DB	011H
	DB	063H
	DB	0aeH
	DB	0ecH
	DB	05eH
	DB	0b8H
CONST	ENDS
;	COMDAT VirtualProcessorEventGuid
CONST	SEGMENT
VirtualProcessorEventGuid DD 02f27805fH
	DW	01676H
	DW	04eccH
	DB	096H
	DB	0faH
	DB	07eH
	DB	0b0H
	DB	09dH
	DB	044H
	DB	030H
	DB	02fH
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ChoreEventGuid
CONST	SEGMENT
ChoreEventGuid DD 07e854ec7H
	DW	0cdc4H
	DW	0405aH
	DB	0b5H
	DB	0b2H
	DB	0aaH
	DB	0f7H
	DB	0c9H
	DB	0e7H
	DB	0d4H
	DB	0cH
CONST	ENDS
;	COMDAT ContextEventGuid
CONST	SEGMENT
ContextEventGuid DD 05727a00fH
	DW	050beH
	DW	04519H
	DB	082H
	DB	056H
	DB	0f7H
	DB	069H
	DB	098H
	DB	071H
	DB	0feH
	DB	0cbH
CONST	ENDS
;	COMDAT ScheduleGroupEventGuid
CONST	SEGMENT
ScheduleGroupEventGuid DD 0e8a3bf1fH
	DW	0a86bH
	DW	04390H
	DB	09cH
	DB	060H
	DB	053H
	DB	090H
	DB	0b9H
	DB	069H
	DB	0d2H
	DB	02cH
CONST	ENDS
;	COMDAT SchedulerEventGuid
CONST	SEGMENT
SchedulerEventGuid DD 0e2091f8aH
	DW	01e0aH
	DW	04731H
	DB	084H
	DB	0a2H
	DB	0dH
	DB	0d5H
	DB	07cH
	DB	08aH
	DB	052H
	DB	061H
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ConcRTEventGuid
CONST	SEGMENT
ConcRTEventGuid DD 072b14a7dH
	DW	0704cH
	DW	0423eH
	DB	092H
	DB	0f8H
	DB	07eH
	DB	06dH
	DB	064H
	DB	0bcH
	DB	0b9H
	DB	02aH
CONST	ENDS
;	COMDAT ConcRT_ProviderGuid
CONST	SEGMENT
ConcRT_ProviderGuid DD 0f7b697a3H
	DW	04db5H
	DW	04d3bH
	DB	0beH
	DB	071H
	DB	0c4H
	DB	0d2H
	DB	084H
	DB	0e6H
	DB	059H
	DB	02fH
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?is_steady@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@steady_clock@chrono@std@@2_NB DB 01H		; std::chrono::steady_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@steady_clock@chrono@std@@2_NB DB 01H	; std::chrono::steady_clock::is_monotonic
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
CONST	SEGMENT
$SG118908 DB	'Code\winmain.cpp', 00H
	ORG $+7
$SG118920 DB	'Reserved %1.3f MB (%d vallocs,%d heap allocs) of low-mem'
	DB	'ory.', 0aH, 00H
	ORG $+2
dutycycletable DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB DQ 0000000000000001H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::den
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::num
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
CONST	ENDS
PUBLIC	WinMain
PUBLIC	??0_Ignore@std@@QEAA@XZ				; std::_Ignore::_Ignore
PUBLIC	?ReserveBottomMemory@@YAXXZ			; ReserveBottomMemory
PUBLIC	??$sprintf_s@$0DOI@@@YAHAEAY0DOI@DPEBDZZ	; sprintf_s<1000>
PUBLIC	__real@4130000000000000
PUBLIC	__real@43f0000000000000
EXTRN	__imp__malloc_dbg:PROC
EXTRN	__imp__free_dbg:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_HeapAlloc:PROC
EXTRN	__imp_HeapFree:PROC
EXTRN	__imp_GetProcessHeap:PROC
EXTRN	__imp_VirtualAlloc:PROC
EXTRN	__imp_VirtualFree:PROC
EXTRN	__imp_vsprintf_s:PROC
EXTRN	??0Application@app@@QEAA@PEAUHINSTANCE__@@PEADH@Z:PROC ; app::Application::Application
EXTRN	??1Application@app@@UEAA@XZ:PROC		; app::Application::~Application
EXTRN	?Run@Application@app@@UEAAHXZ:PROC		; app::Application::Run
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
piecewise_construct DB 01H DUP (?)
allocator_arg DB 01H DUP (?)
ignore	DB	01H DUP (?)
_Tuple_alloc DB	01H DUP (?)
_BSS	ENDS
;	COMDAT ?s_initialized@?1??ReserveBottomMemory@@YAXXZ@4_NA
_BSS	SEGMENT
?s_initialized@?1??ReserveBottomMemory@@YAXXZ@4_NA DB 01H DUP (?) ; `ReserveBottomMemory'::`2'::s_initialized
_BSS	ENDS
pdata	SEGMENT
$pdata$WinMain DD imagerel $LN3
	DD	imagerel $LN3+192
	DD	imagerel $unwind$WinMain
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Epiecewise_construct@std@@YAXXZ DD imagerel ??__Epiecewise_construct@std@@YAXXZ
	DD	imagerel ??__Epiecewise_construct@std@@YAXXZ+43
	DD	imagerel $unwind$??__Epiecewise_construct@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eallocator_arg@std@@YAXXZ DD imagerel ??__Eallocator_arg@std@@YAXXZ
	DD	imagerel ??__Eallocator_arg@std@@YAXXZ+43
	DD	imagerel $unwind$??__Eallocator_arg@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Ignore@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+13
	DD	imagerel $unwind$??0_Ignore@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eignore@std@@YAXXZ DD imagerel ??__Eignore@std@@YAXXZ
	DD	imagerel ??__Eignore@std@@YAXXZ+39
	DD	imagerel $unwind$??__Eignore@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E_Tuple_alloc@std@@YAXXZ DD imagerel ??__E_Tuple_alloc@std@@YAXXZ
	DD	imagerel ??__E_Tuple_alloc@std@@YAXXZ+43
	DD	imagerel $unwind$??__E_Tuple_alloc@std@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?ReserveBottomMemory@@YAXXZ DD imagerel $LN26
	DD	imagerel $LN26+769
	DD	imagerel $unwind$?ReserveBottomMemory@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$sprintf_s@$0DOI@@@YAHAEAY0DOI@DPEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+108
	DD	imagerel $unwind$??$sprintf_s@$0DOI@@@YAHAEAY0DOI@DPEBDZZ
pdata	ENDS
CRT$XCU	SEGMENT
piecewise_construct$initializer$ DQ FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@43f0000000000000
CONST	SEGMENT
__real@43f0000000000000 DQ 043f0000000000000r	; 1.84467e+019
CONST	ENDS
;	COMDAT __real@4130000000000000
CONST	SEGMENT
__real@4130000000000000 DQ 04130000000000000r	; 1.04858e+006
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$sprintf_s@$0DOI@@@YAHAEAY0DOI@DPEBDZZ DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$sprintf_s@$0DOI@@@YAHAEAY0DOI@DPEBDZZ$rtcName$0 DB 05fH ; sprintf_s<1000>
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
??$sprintf_s@$0DOI@@@YAHAEAY0DOI@DPEBDZZ$rtcVarDesc DD 028H ; sprintf_s<1000>
	DD	08H
	DQ	FLAT:??$sprintf_s@$0DOI@@@YAHAEAY0DOI@DPEBDZZ$rtcName$0
	ORG $+48
??$sprintf_s@$0DOI@@@YAHAEAY0DOI@DPEBDZZ$rtcFrameData DD 01H ; sprintf_s<1000>
	DD	00H
	DQ	FLAT:??$sprintf_s@$0DOI@@@YAHAEAY0DOI@DPEBDZZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E_Tuple_alloc@std@@YAXXZ DD 021501H
	DD	070021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eignore@std@@YAXXZ DD 021501H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Ignore@std@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eallocator_arg@std@@YAXXZ DD 021501H
	DD	070021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Epiecewise_construct@std@@YAXXZ DD 021501H
	DD	070021206H
xdata	ENDS
xdata	SEGMENT
$unwind$WinMain DD 034b19H
	DD	02060122H
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	01028H
$unwind$?ReserveBottomMemory@@YAXXZ DD 032a19H
	DD	0960109H
	DD	07002H
	DD	imagerel __GSHandlerCheck
	DD	04a0H
xdata	ENDS
CONST	SEGMENT
WinMain$rtcName$0 DB 061H
	DB	070H
	DB	070H
	DB	00H
	ORG $+4
WinMain$rtcVarDesc DD 030H
	DD	0fd8H
	DQ	FLAT:WinMain$rtcName$0
	ORG $+48
WinMain$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:WinMain$rtcVarDesc
?ReserveBottomMemory@@YAXXZ$rtcName$0 DB 062H		; ReserveBottomMemory
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+1
?ReserveBottomMemory@@YAXXZ$rtcFrameData DD 01H		; ReserveBottomMemory
	DD	00H
	DQ	FLAT:?ReserveBottomMemory@@YAXXZ$rtcVarDesc
	ORG $+8
?ReserveBottomMemory@@YAXXZ$rtcVarDesc DD 0a0H		; ReserveBottomMemory
	DD	03e8H
	DQ	FLAT:?ReserveBottomMemory@@YAXXZ$rtcName$0
CONST	ENDS
CRT$XCU	SEGMENT
allocator_arg$initializer$ DQ FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
ignore$initializer$ DQ FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_Tuple_alloc$initializer$ DQ FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$0DOI@@@YAHAEAY0DOI@DPEBDZZ
_TEXT	SEGMENT
_ArgList$ = 40
_Dest$ = 80
_Format$ = 88
??$sprintf_s@$0DOI@@@YAHAEAY0DOI@DPEBDZZ PROC		; sprintf_s<1000>, COMDAT

; 309  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, _Post_z_ char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax
	mov	r9, QWORD PTR _ArgList$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	edx, 1000				; 000003e8H
	mov	rcx, QWORD PTR _Dest$[rsp]
	call	QWORD PTR __imp_vsprintf_s
	mov	rdi, rax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:??$sprintf_s@$0DOI@@@YAHAEAY0DOI@DPEBDZZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$sprintf_s@$0DOI@@@YAHAEAY0DOI@DPEBDZZ ENDP		; sprintf_s<1000>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\winmain.cpp
_TEXT	SEGMENT
LOW_MEM_LINE$ = 48
totalReservation$ = 56
numVAllocs$ = 64
numHeapAllocs$ = 72
oneMB$ = 80
size$4 = 88
p$5 = 96
heap$ = 104
blockSize$6 = 112
p$7 = 120
blockSize$8 = 128
p$9 = 136
buffer$ = 160
__$ArrayPad$ = 1184
?ReserveBottomMemory@@YAXXZ PROC			; ReserveBottomMemory

; 4    : {

$LN26:
	push	rdi
	sub	rsp, 1200				; 000004b0H
	mov	rdi, rsp
	mov	ecx, 300				; 0000012cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5    : #ifdef _WIN64
; 6    :     static bool s_initialized = false;
; 7    :     if ( s_initialized )

	movzx	eax, BYTE PTR ?s_initialized@?1??ReserveBottomMemory@@YAXXZ@4_NA
	test	eax, eax
	je	SHORT $LN22@ReserveBot

; 8    :         return;

	jmp	$LN23@ReserveBot
$LN22@ReserveBot:

; 9    :     s_initialized = true;

	mov	BYTE PTR ?s_initialized@?1??ReserveBottomMemory@@YAXXZ@4_NA, 1

; 10   :  
; 11   :     // Start by reserving large blocks of address space, and then
; 12   :     // gradually reduce the size in order to capture all of the
; 13   :     // fragments. Technically we should continue down to 64 KB but
; 14   :     // stopping at 1 MB is sufficient to keep most allocators out.
; 15   :  
; 16   :     const size_t LOW_MEM_LINE = 0x100000000LL;

	mov	rax, 4294967296				; 0000000100000000H
	mov	QWORD PTR LOW_MEM_LINE$[rsp], rax

; 17   :     size_t totalReservation = 0;

	mov	QWORD PTR totalReservation$[rsp], 0

; 18   :     size_t numVAllocs = 0;

	mov	QWORD PTR numVAllocs$[rsp], 0

; 19   :     size_t numHeapAllocs = 0;

	mov	QWORD PTR numHeapAllocs$[rsp], 0

; 20   :     size_t oneMB = 1024 * 1024;

	mov	QWORD PTR oneMB$[rsp], 1048576		; 00100000H

; 21   :     for (size_t size = 256 * oneMB; size >= oneMB; size /= 2)

	mov	rax, QWORD PTR oneMB$[rsp]
	imul	rax, 256				; 00000100H
	mov	QWORD PTR size$4[rsp], rax
	jmp	SHORT $LN21@ReserveBot
$LN20@ReserveBot:
	xor	edx, edx
	mov	rax, QWORD PTR size$4[rsp]
	mov	ecx, 2
	div	rcx
	mov	QWORD PTR size$4[rsp], rax
$LN21@ReserveBot:
	mov	rax, QWORD PTR oneMB$[rsp]
	cmp	QWORD PTR size$4[rsp], rax
	jb	SHORT $LN19@ReserveBot
$LN18@ReserveBot:

; 22   :     {
; 23   :         for (;;)
; 24   :         {
; 25   :             void* p = VirtualAlloc(0, size, MEM_RESERVE, PAGE_NOACCESS);

	mov	r9d, 1
	mov	r8d, 8192				; 00002000H
	mov	rdx, QWORD PTR size$4[rsp]
	xor	ecx, ecx
	call	QWORD PTR __imp_VirtualAlloc
	mov	QWORD PTR p$5[rsp], rax

; 26   :             if (!p)

	cmp	QWORD PTR p$5[rsp], 0
	jne	SHORT $LN16@ReserveBot

; 27   :                 break;

	jmp	SHORT $LN17@ReserveBot
$LN16@ReserveBot:

; 28   :  
; 29   :             if ((size_t)p >= LOW_MEM_LINE)

	mov	rax, 4294967296				; 0000000100000000H
	cmp	QWORD PTR p$5[rsp], rax
	jb	SHORT $LN15@ReserveBot

; 30   :             {
; 31   :                 // We don't need this memory, so release it completely.
; 32   :                 VirtualFree(p, 0, MEM_RELEASE);

	mov	r8d, 32768				; 00008000H
	xor	edx, edx
	mov	rcx, QWORD PTR p$5[rsp]
	call	QWORD PTR __imp_VirtualFree

; 33   :                 break;

	jmp	SHORT $LN17@ReserveBot
$LN15@ReserveBot:

; 34   :             }
; 35   :  
; 36   :             totalReservation += size;

	mov	rax, QWORD PTR size$4[rsp]
	mov	rcx, QWORD PTR totalReservation$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR totalReservation$[rsp], rax

; 37   :             ++numVAllocs;

	mov	rax, QWORD PTR numVAllocs$[rsp]
	inc	rax
	mov	QWORD PTR numVAllocs$[rsp], rax

; 38   :         }

	jmp	SHORT $LN18@ReserveBot
$LN17@ReserveBot:

; 39   :     }

	jmp	$LN20@ReserveBot
$LN19@ReserveBot:

; 40   :  
; 41   :     // Now repeat the same process but making heap allocations, to use up
; 42   :     // the already reserved heap blocks that are below the 4 GB line.
; 43   :     HANDLE heap = GetProcessHeap();

	call	QWORD PTR __imp_GetProcessHeap
	mov	QWORD PTR heap$[rsp], rax

; 44   :     for (size_t blockSize = 64 * 1024; blockSize >= 16; blockSize /= 2)

	mov	QWORD PTR blockSize$6[rsp], 65536	; 00010000H
	jmp	SHORT $LN14@ReserveBot
$LN13@ReserveBot:
	xor	edx, edx
	mov	rax, QWORD PTR blockSize$6[rsp]
	mov	ecx, 2
	div	rcx
	mov	QWORD PTR blockSize$6[rsp], rax
$LN14@ReserveBot:
	cmp	QWORD PTR blockSize$6[rsp], 16
	jb	SHORT $LN12@ReserveBot
$LN11@ReserveBot:

; 45   :     {
; 46   :         for (;;)
; 47   :         {
; 48   :             void* p = HeapAlloc(heap, 0, blockSize);

	mov	r8, QWORD PTR blockSize$6[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR heap$[rsp]
	call	QWORD PTR __imp_HeapAlloc
	mov	QWORD PTR p$7[rsp], rax

; 49   :             if (!p)

	cmp	QWORD PTR p$7[rsp], 0
	jne	SHORT $LN9@ReserveBot

; 50   :                 break;

	jmp	SHORT $LN10@ReserveBot
$LN9@ReserveBot:

; 51   :  
; 52   :             if ((size_t)p >= LOW_MEM_LINE)

	mov	rax, 4294967296				; 0000000100000000H
	cmp	QWORD PTR p$7[rsp], rax
	jb	SHORT $LN8@ReserveBot

; 53   :             {
; 54   :                 // We don't need this memory, so release it completely.
; 55   :                 HeapFree(heap, 0, p);

	mov	r8, QWORD PTR p$7[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR heap$[rsp]
	call	QWORD PTR __imp_HeapFree

; 56   :                 break;

	jmp	SHORT $LN10@ReserveBot
$LN8@ReserveBot:

; 57   :             }
; 58   :  
; 59   :             totalReservation += blockSize;

	mov	rax, QWORD PTR blockSize$6[rsp]
	mov	rcx, QWORD PTR totalReservation$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR totalReservation$[rsp], rax

; 60   :             ++numHeapAllocs;

	mov	rax, QWORD PTR numHeapAllocs$[rsp]
	inc	rax
	mov	QWORD PTR numHeapAllocs$[rsp], rax

; 61   :         }

	jmp	SHORT $LN11@ReserveBot
$LN10@ReserveBot:

; 62   :     }

	jmp	$LN13@ReserveBot
$LN12@ReserveBot:

; 63   :  
; 64   :     // Perversely enough the CRT doesn't use the process heap. Suck up
; 65   :     // the memory the CRT heap has already reserved.
; 66   :     for (size_t blockSize = 64 * 1024; blockSize >= 16; blockSize /= 2)

	mov	QWORD PTR blockSize$8[rsp], 65536	; 00010000H
	jmp	SHORT $LN7@ReserveBot
$LN6@ReserveBot:
	xor	edx, edx
	mov	rax, QWORD PTR blockSize$8[rsp]
	mov	ecx, 2
	div	rcx
	mov	QWORD PTR blockSize$8[rsp], rax
$LN7@ReserveBot:
	cmp	QWORD PTR blockSize$8[rsp], 16
	jb	$LN5@ReserveBot
$LN4@ReserveBot:

; 67   :     {
; 68   :         for (;;)
; 69   :         {
; 70   :             void* p = malloc(blockSize);

	mov	r9d, 70					; 00000046H
	lea	r8, OFFSET FLAT:$SG118908
	mov	edx, 1
	mov	rcx, QWORD PTR blockSize$8[rsp]
	call	QWORD PTR __imp__malloc_dbg
	mov	QWORD PTR p$9[rsp], rax

; 71   :             if (!p)

	cmp	QWORD PTR p$9[rsp], 0
	jne	SHORT $LN2@ReserveBot

; 72   :                 break;

	jmp	SHORT $LN3@ReserveBot
$LN2@ReserveBot:

; 73   :  
; 74   :             if ((size_t)p >= LOW_MEM_LINE)

	mov	rax, 4294967296				; 0000000100000000H
	cmp	QWORD PTR p$9[rsp], rax
	jb	SHORT $LN1@ReserveBot

; 75   :             {
; 76   :                 // We don't need this memory, so release it completely.
; 77   :                 free(p);

	mov	edx, 1
	mov	rcx, QWORD PTR p$9[rsp]
	call	QWORD PTR __imp__free_dbg

; 78   :                 break;

	jmp	SHORT $LN3@ReserveBot
$LN1@ReserveBot:

; 79   :             }
; 80   :  
; 81   :             totalReservation += blockSize;

	mov	rax, QWORD PTR blockSize$8[rsp]
	mov	rcx, QWORD PTR totalReservation$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR totalReservation$[rsp], rax

; 82   :             ++numHeapAllocs;

	mov	rax, QWORD PTR numHeapAllocs$[rsp]
	inc	rax
	mov	QWORD PTR numHeapAllocs$[rsp], rax

; 83   :         }

	jmp	$LN4@ReserveBot
$LN3@ReserveBot:

; 84   :     }

	jmp	$LN6@ReserveBot
$LN5@ReserveBot:

; 85   :  
; 86   :     // Print diagnostics showing how many allocations we had to make in
; 87   :     // order to reserve all of low memory, typically less than 200.
; 88   :     char buffer[1000];
; 89   :     sprintf_s(buffer, "Reserved %1.3f MB (%d vallocs,"
; 90   :                       "%d heap allocs) of low-memory.\n",
; 91   :             totalReservation / (1024 * 1024.0),
; 92   :             (int)numVAllocs, (int)numHeapAllocs);

	mov	rax, QWORD PTR totalReservation$[rsp]
	cvtsi2sd xmm0, rax
	test	rax, rax
	jge	SHORT $LN25@ReserveBot
	addsd	xmm0, QWORD PTR __real@43f0000000000000
$LN25@ReserveBot:
	divsd	xmm0, QWORD PTR __real@4130000000000000
	mov	eax, DWORD PTR numHeapAllocs$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR numVAllocs$[rsp]
	movaps	xmm2, xmm0
	movd	r8, xmm2
	lea	rdx, OFFSET FLAT:$SG118920
	lea	rcx, QWORD PTR buffer$[rsp]
	call	??$sprintf_s@$0DOI@@@YAHAEAY0DOI@DPEBDZZ ; sprintf_s<1000>

; 93   :     OutputDebugStringA(buffer);

	lea	rcx, QWORD PTR buffer$[rsp]
	call	QWORD PTR __imp_OutputDebugStringA
$LN23@ReserveBot:

; 94   : #endif
; 95   : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:?ReserveBottomMemory@@YAXXZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1200				; 000004b0H
	pop	rdi
	ret	0
?ReserveBottomMemory@@YAXXZ ENDP			; ReserveBottomMemory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$yc	SEGMENT
$T1 = 0
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 137  : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	add	rsp, 16
	pop	rdi
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$yc	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 130  : const _Ignore ignore;

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:ignore
	call	??0_Ignore@std@@QEAA@XZ			; std::_Ignore::_Ignore
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0_Ignore@std@@QEAA@XZ PROC				; std::_Ignore::_Ignore, COMDAT

; 120  : 	_Ignore()

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 121  : 		{	// construct
; 122  : 		}

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0_Ignore@std@@QEAA@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = 0
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	add	rsp, 16
	pop	rdi
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = 0
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	add	rsp, 16
	pop	rdi
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\winmain.cpp
_TEXT	SEGMENT
app$ = 48
$T4 = 4128
__$ArrayPad$ = 4136
hInstance$ = 4160
hPrevInstance$ = 4168
lpCmdLine$ = 4176
nShowCmd$ = 4184
WinMain	PROC

; 98   : int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	eax, 4144				; 00001030H
	call	__chkstk
	sub	rsp, rax
	mov	rdi, rsp
	mov	ecx, 1036				; 0000040cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+4160]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 99   :   ReserveBottomMemory();

	call	?ReserveBottomMemory@@YAXXZ		; ReserveBottomMemory

; 100  :   
; 101  :   app::Application app(hInstance,lpCmdLine,nShowCmd);

	mov	r9d, DWORD PTR nShowCmd$[rsp]
	mov	r8, QWORD PTR lpCmdLine$[rsp]
	mov	rdx, QWORD PTR hInstance$[rsp]
	lea	rcx, QWORD PTR app$[rsp]
	call	??0Application@app@@QEAA@PEAUHINSTANCE__@@PEADH@Z ; app::Application::Application

; 102  :   //app.InitConsole();
; 103  :   
; 104  :   return app.Run();

	lea	rcx, QWORD PTR app$[rsp]
	call	?Run@Application@app@@UEAAHXZ		; app::Application::Run
	mov	DWORD PTR $T4[rsp], eax
	lea	rcx, QWORD PTR app$[rsp]
	call	??1Application@app@@UEAA@XZ		; app::Application::~Application
	mov	eax, DWORD PTR $T4[rsp]

; 105  : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:WinMain$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 4144				; 00001030H
	pop	rdi
	ret	0
WinMain	ENDP
_TEXT	ENDS
END
