; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?value@?$integral_constant@_K$0A@@std@@2_KB	; std::integral_constant<unsigned __int64,0>::value
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?theta@graphics@@3NA				; graphics::theta
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
_BSS	SEGMENT
?theta@graphics@@3NA DQ 01H DUP (?)			; graphics::theta
_BSS	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB DQ 0000000000000000H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_K$0A@@std@@2_KB
CONST	SEGMENT
?value@?$integral_constant@_K$0A@@std@@2_KB DQ 0000000000000000H ; std::integral_constant<unsigned __int64,0>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB DQ 0000000000000001H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
PUBLIC	?interpolate_int@graphics@@YANHHN@Z		; graphics::interpolate_int
PUBLIC	?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z ; graphics::interpolate_color
PUBLIC	??0Graphics@graphics@@QEAA@XZ			; graphics::Graphics::Graphics
PUBLIC	??1Graphics@graphics@@UEAA@XZ			; graphics::Graphics::~Graphics
PUBLIC	?Initialize@Graphics@graphics@@QEAAXPEAUHWND__@@HH@Z ; graphics::Graphics::Initialize
PUBLIC	?Deinitialize@Graphics@graphics@@QEAAXXZ	; graphics::Graphics::Deinitialize
PUBLIC	??_GGraphics@graphics@@UEAAPEAXI@Z		; graphics::Graphics::`scalar deleting destructor'
PUBLIC	??0GDI@graphics@@QEAA@XZ			; graphics::GDI::GDI
PUBLIC	??1GDI@graphics@@UEAA@XZ			; graphics::GDI::~GDI
PUBLIC	?Initialize@GDI@graphics@@QEAAXPEAUHWND__@@HH@Z	; graphics::GDI::Initialize
PUBLIC	?Deinitialize@GDI@graphics@@QEAAXXZ		; graphics::GDI::Deinitialize
PUBLIC	?Render@GDI@graphics@@UEAAXXZ			; graphics::GDI::Render
PUBLIC	?Clear@GDI@graphics@@UEAAXUtagRGBQUAD@@@Z	; graphics::GDI::Clear
PUBLIC	?SetClippingArea@GDI@graphics@@QEAAXHHHH@Z	; graphics::GDI::SetClippingArea
PUBLIC	?BeginFill@GDI@graphics@@QEAAXUtagRGBQUAD@@N@Z	; graphics::GDI::BeginFill
PUBLIC	?BeginGradientFill@GDI@graphics@@QEAAXPEBUtagRGBQUAD@@PEBN1HW4FillMode@2@@Z ; graphics::GDI::BeginGradientFill
PUBLIC	?EndFill@GDI@graphics@@QEAAXXZ			; graphics::GDI::EndFill
PUBLIC	?DrawRectangle@GDI@graphics@@QEAAXHHHH@Z	; graphics::GDI::DrawRectangle
PUBLIC	?DrawCircle@GDI@graphics@@QEAAXHHH@Z		; graphics::GDI::DrawCircle
PUBLIC	?DrawTriangle@GDI@graphics@@QEAAXHHHHHH@Z	; graphics::GDI::DrawTriangle
PUBLIC	?DrawLine@GDI@graphics@@QEAAXHHHH@Z		; graphics::GDI::DrawLine
PUBLIC	?TestBoundry@GDI@graphics@@AEAA_NHH@Z		; graphics::GDI::TestBoundry
PUBLIC	?FillPixel@GDI@graphics@@AEAAXHHNN@Z		; graphics::GDI::FillPixel
PUBLIC	?ClearFill@GDI@graphics@@AEAAXXZ		; graphics::GDI::ClearFill
PUBLIC	??_GGDI@graphics@@UEAAPEAXI@Z			; graphics::GDI::`scalar deleting destructor'
PUBLIC	?interpolate_int_array@graphics@@YANPEAHHN@Z	; graphics::interpolate_int_array
PUBLIC	??$swap@H@std@@YAXAEAH0@Z			; std::swap<int>
PUBLIC	??$_Move@AEAH@std@@YA$$QEAHAEAH@Z		; std::_Move<int & __ptr64>
PUBLIC	??_7Graphics@graphics@@6B@			; graphics::Graphics::`vftable'
PUBLIC	??_7GDI@graphics@@6B@				; graphics::GDI::`vftable'
PUBLIC	??_R4Graphics@graphics@@6B@			; graphics::Graphics::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVGraphics@graphics@@@8			; graphics::Graphics `RTTI Type Descriptor'
PUBLIC	??_R3Graphics@graphics@@8			; graphics::Graphics::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Graphics@graphics@@8			; graphics::Graphics::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Graphics@graphics@@8		; graphics::Graphics::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4GDI@graphics@@6B@				; graphics::GDI::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVGDI@graphics@@@8			; graphics::GDI `RTTI Type Descriptor'
PUBLIC	??_R3GDI@graphics@@8				; graphics::GDI::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2GDI@graphics@@8				; graphics::GDI::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@GDI@graphics@@8			; graphics::GDI::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
EXTRN	_purecall:PROC
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__imp_DeleteObject:PROC
EXTRN	__imp_SetDIBitsToDevice:PROC
EXTRN	__imp_CreateDIBSection:PROC
EXTRN	__imp_GetDC:PROC
EXTRN	abs:PROC
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPEAX_K@Z:PROC				; operator new[]
EXTRN	??_EGraphics@graphics@@UEAAPEAXI@Z:PROC		; graphics::Graphics::`vector deleting destructor'
EXTRN	??_EGDI@graphics@@UEAAPEAXI@Z:PROC		; graphics::GDI::`vector deleting destructor'
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	_fltused:DWORD
_BSS	SEGMENT
piecewise_construct DB 01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Epiecewise_construct@std@@YAXXZ DD imagerel ??__Epiecewise_construct@std@@YAXXZ
	DD	imagerel ??__Epiecewise_construct@std@@YAXXZ+43
	DD	imagerel $unwind$??__Epiecewise_construct@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eallocator_arg@std@@YAXXZ DD imagerel ??__Eallocator_arg@std@@YAXXZ
	DD	imagerel ??__Eallocator_arg@std@@YAXXZ+43
	DD	imagerel $unwind$??__Eallocator_arg@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?interpolate_int@graphics@@YANHHN@Z DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$?interpolate_int@graphics@@YANHHN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z DD imagerel $LN3
	DD	imagerel $LN3+159
	DD	imagerel $unwind$?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Graphics@graphics@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$??0Graphics@graphics@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Graphics@graphics@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$??1Graphics@graphics@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@Graphics@graphics@@QEAAXPEAUHWND__@@HH@Z DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$?Initialize@Graphics@graphics@@QEAAXPEAUHWND__@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Deinitialize@Graphics@graphics@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+8
	DD	imagerel $unwind$?Deinitialize@Graphics@graphics@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GGraphics@graphics@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$??_GGraphics@graphics@@UEAAPEAXI@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??0GDI@graphics@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+117
	DD	imagerel $unwind$??0GDI@graphics@@QEAA@XZ
$pdata$??1GDI@graphics@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$??1GDI@graphics@@UEAA@XZ
$pdata$?Initialize@GDI@graphics@@QEAAXPEAUHWND__@@HH@Z DD imagerel $LN3
	DD	imagerel $LN3+390
	DD	imagerel $unwind$?Initialize@GDI@graphics@@QEAAXPEAUHWND__@@HH@Z
$pdata$?Deinitialize@GDI@graphics@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+97
	DD	imagerel $unwind$?Deinitialize@GDI@graphics@@QEAAXXZ
$pdata$?Render@GDI@graphics@@UEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+198
	DD	imagerel $unwind$?Render@GDI@graphics@@UEAAXXZ
$pdata$?Clear@GDI@graphics@@UEAAXUtagRGBQUAD@@@Z DD imagerel $LN6
	DD	imagerel $LN6+146
	DD	imagerel $unwind$?Clear@GDI@graphics@@UEAAXUtagRGBQUAD@@@Z
$pdata$?SetClippingArea@GDI@graphics@@QEAAXHHHH@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?SetClippingArea@GDI@graphics@@QEAAXHHHH@Z
$pdata$?BeginFill@GDI@graphics@@QEAAXUtagRGBQUAD@@N@Z DD imagerel $LN3
	DD	imagerel $LN3+181
	DD	imagerel $unwind$?BeginFill@GDI@graphics@@QEAAXUtagRGBQUAD@@N@Z
$pdata$?BeginGradientFill@GDI@graphics@@QEAAXPEBUtagRGBQUAD@@PEBN1HW4FillMode@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+293
	DD	imagerel $unwind$?BeginGradientFill@GDI@graphics@@QEAAXPEBUtagRGBQUAD@@PEBN1HW4FillMode@2@@Z
$pdata$?EndFill@GDI@graphics@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+8
	DD	imagerel $unwind$?EndFill@GDI@graphics@@QEAAXXZ
$pdata$?DrawRectangle@GDI@graphics@@QEAAXHHHH@Z DD imagerel $LN10
	DD	imagerel $LN10+278
	DD	imagerel $unwind$?DrawRectangle@GDI@graphics@@QEAAXHHHH@Z
$pdata$?DrawCircle@GDI@graphics@@QEAAXHHH@Z DD imagerel $LN11
	DD	imagerel $LN11+376
	DD	imagerel $unwind$?DrawCircle@GDI@graphics@@QEAAXHHH@Z
$pdata$?DrawTriangle@GDI@graphics@@QEAAXHHHHHH@Z DD imagerel $LN27
	DD	imagerel $LN27+1371
	DD	imagerel $unwind$?DrawTriangle@GDI@graphics@@QEAAXHHHHHH@Z
$pdata$?DrawLine@GDI@graphics@@QEAAXHHHH@Z DD imagerel $LN15
	DD	imagerel $LN15+653
	DD	imagerel $unwind$?DrawLine@GDI@graphics@@QEAAXHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TestBoundry@GDI@graphics@@AEAA_NHH@Z DD imagerel $LN5
	DD	imagerel $LN5+133
	DD	imagerel $unwind$?TestBoundry@GDI@graphics@@AEAA_NHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FillPixel@GDI@graphics@@AEAAXHHNN@Z DD imagerel $LN6
	DD	imagerel $LN6+374
	DD	imagerel $unwind$?FillPixel@GDI@graphics@@AEAAXHHNN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClearFill@GDI@graphics@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+8
	DD	imagerel $unwind$?ClearFill@GDI@graphics@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GGDI@graphics@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$??_GGDI@graphics@@UEAAPEAXI@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?interpolate_int_array@graphics@@YANPEAHHN@Z DD imagerel $LN6
	DD	imagerel $LN6+177
	DD	imagerel $unwind$?interpolate_int_array@graphics@@YANPEAHHN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$swap@H@std@@YAXAEAH0@Z DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$??$swap@H@std@@YAXAEAH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Move@AEAH@std@@YA$$QEAHAEAH@Z DD imagerel $LN3
	DD	imagerel $LN3+13
	DD	imagerel $unwind$??$_Move@AEAH@std@@YA$$QEAHAEAH@Z
pdata	ENDS
CRT$XCU	SEGMENT
piecewise_construct$initializer$ DQ FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@GDI@graphics@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@GDI@graphics@@8 DD imagerel ??_R0?AVGDI@graphics@@@8 ; graphics::GDI::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3GDI@graphics@@8
rdata$r	ENDS
;	COMDAT ??_R2GDI@graphics@@8
rdata$r	SEGMENT
??_R2GDI@graphics@@8 DD imagerel ??_R1A@?0A@EA@GDI@graphics@@8 ; graphics::GDI::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Graphics@graphics@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3GDI@graphics@@8
rdata$r	SEGMENT
??_R3GDI@graphics@@8 DD 00H				; graphics::GDI::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2GDI@graphics@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVGDI@graphics@@@8
_DATA	SEGMENT
??_R0?AVGDI@graphics@@@8 DQ FLAT:??_7type_info@@6B@	; graphics::GDI `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVGDI@graphics@@', 00H
_DATA	ENDS
;	COMDAT ??_R4GDI@graphics@@6B@
rdata$r	SEGMENT
??_R4GDI@graphics@@6B@ DD 01H				; graphics::GDI::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVGDI@graphics@@@8
	DD	imagerel ??_R3GDI@graphics@@8
	DD	imagerel ??_R4GDI@graphics@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Graphics@graphics@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Graphics@graphics@@8 DD imagerel ??_R0?AVGraphics@graphics@@@8 ; graphics::Graphics::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Graphics@graphics@@8
rdata$r	ENDS
;	COMDAT ??_R2Graphics@graphics@@8
rdata$r	SEGMENT
??_R2Graphics@graphics@@8 DD imagerel ??_R1A@?0A@EA@Graphics@graphics@@8 ; graphics::Graphics::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3Graphics@graphics@@8
rdata$r	SEGMENT
??_R3Graphics@graphics@@8 DD 00H			; graphics::Graphics::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2Graphics@graphics@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVGraphics@graphics@@@8
_DATA	SEGMENT
??_R0?AVGraphics@graphics@@@8 DQ FLAT:??_7type_info@@6B@ ; graphics::Graphics `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVGraphics@graphics@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Graphics@graphics@@6B@
rdata$r	SEGMENT
??_R4Graphics@graphics@@6B@ DD 01H			; graphics::Graphics::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVGraphics@graphics@@@8
	DD	imagerel ??_R3Graphics@graphics@@8
	DD	imagerel ??_R4Graphics@graphics@@6B@
rdata$r	ENDS
;	COMDAT ??_7GDI@graphics@@6B@
CONST	SEGMENT
??_7GDI@graphics@@6B@ DQ FLAT:??_R4GDI@graphics@@6B@	; graphics::GDI::`vftable'
	DQ	FLAT:??_EGDI@graphics@@UEAAPEAXI@Z
	DQ	FLAT:?Clear@GDI@graphics@@UEAAXUtagRGBQUAD@@@Z
	DQ	FLAT:?Render@GDI@graphics@@UEAAXXZ
CONST	ENDS
;	COMDAT ??_7Graphics@graphics@@6B@
CONST	SEGMENT
??_7Graphics@graphics@@6B@ DQ FLAT:??_R4Graphics@graphics@@6B@ ; graphics::Graphics::`vftable'
	DQ	FLAT:??_EGraphics@graphics@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Move@AEAH@std@@YA$$QEAHAEAH@Z DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$swap@H@std@@YAXAEAH0@Z DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$swap@H@std@@YAXAEAH0@Z$rtcName$0 DB 05fH		; std::swap<int>
	DB	054H
	DB	06dH
	DB	070H
	DB	00H
	ORG $+11
??$swap@H@std@@YAXAEAH0@Z$rtcVarDesc DD 024H		; std::swap<int>
	DD	04H
	DQ	FLAT:??$swap@H@std@@YAXAEAH0@Z$rtcName$0
	ORG $+48
??$swap@H@std@@YAXAEAH0@Z$rtcFrameData DD 01H		; std::swap<int>
	DD	00H
	DQ	FLAT:??$swap@H@std@@YAXAEAH0@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GGDI@graphics@@UEAAPEAXI@Z DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClearFill@GDI@graphics@@AEAAXXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FillPixel@GDI@graphics@@AEAAXHHNN@Z DD 022d01H
	DD	07015b219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?FillPixel@GDI@graphics@@AEAAXHHNN@Z$rtcName$0 DB 063H	; graphics::GDI::FillPixel
	DB	00H
	ORG $+14
?FillPixel@GDI@graphics@@AEAAXHHNN@Z$rtcVarDesc DD 034H	; graphics::GDI::FillPixel
	DD	04H
	DQ	FLAT:?FillPixel@GDI@graphics@@AEAAXHHNN@Z$rtcName$0
	ORG $+48
?FillPixel@GDI@graphics@@AEAAXHHNN@Z$rtcFrameData DD 01H ; graphics::GDI::FillPixel
	DD	00H
	DQ	FLAT:?FillPixel@GDI@graphics@@AEAAXHHNN@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TestBoundry@GDI@graphics@@AEAA_NHH@Z DD 022701H
	DD	0700f1213H
xdata	ENDS
xdata	SEGMENT
$unwind$??0GDI@graphics@@QEAA@XZ DD 021e01H
	DD	07006320aH
$unwind$??1GDI@graphics@@UEAA@XZ DD 021e01H
	DD	07006320aH
$unwind$?Initialize@GDI@graphics@@QEAAXPEAUHWND__@@HH@Z DD 022d01H
	DD	070157219H
$unwind$?Deinitialize@GDI@graphics@@QEAAXXZ DD 021e01H
	DD	07006520aH
$unwind$?Render@GDI@graphics@@UEAAXXZ DD 021e01H
	DD	07006b20aH
$unwind$?Clear@GDI@graphics@@UEAAXUtagRGBQUAD@@@Z DD 022201H
	DD	0700a120eH
$unwind$?SetClippingArea@GDI@graphics@@QEAAXHHHH@Z DD 011401H
	DD	07014H
$unwind$?BeginFill@GDI@graphics@@QEAAXUtagRGBQUAD@@N@Z DD 022801H
	DD	070103214H
$unwind$?BeginGradientFill@GDI@graphics@@QEAAXPEBUtagRGBQUAD@@PEBN1HW4FillMode@2@@Z DD 022d01H
	DD	070155219H
$unwind$?EndFill@GDI@graphics@@QEAAXXZ DD 010601H
	DD	07006H
$unwind$?DrawRectangle@GDI@graphics@@QEAAXHHHH@Z DD 022c01H
	DD	070149218H
$unwind$?DrawCircle@GDI@graphics@@QEAAXHHH@Z DD 022c01H
	DD	070149218H
$unwind$?DrawTriangle@GDI@graphics@@QEAAXHHHHHH@Z DD 033201H
	DD	012011bH
	DD	07014H
$unwind$?DrawLine@GDI@graphics@@QEAAXHHHH@Z DD 022f01H
	DD	07014d218H
$unwind$?interpolate_int_array@graphics@@YANPEAHHN@Z DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GGraphics@graphics@@UEAAPEAXI@Z DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Deinitialize@Graphics@graphics@@QEAAXXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@Graphics@graphics@@QEAAXPEAUHWND__@@HH@Z DD 011501H
	DD	07015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Graphics@graphics@@UEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Graphics@graphics@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z DD 022201H
	DD	0700f7213H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z$rtcName$0 DB 072H ; graphics::interpolate_color
	DB	00H
	ORG $+14
?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z$rtcVarDesc DD 024H ; graphics::interpolate_color
	DD	04H
	DQ	FLAT:?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z$rtcName$0
	ORG $+48
?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z$rtcFrameData DD 01H ; graphics::interpolate_color
	DD	00H
	DQ	FLAT:?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?interpolate_int@graphics@@YANHHN@Z DD 022601H
	DD	0700f1213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eallocator_arg@std@@YAXXZ DD 021501H
	DD	070021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Epiecewise_construct@std@@YAXXZ DD 021501H
	DD	070021206H
xdata	ENDS
CRT$XCU	SEGMENT
allocator_arg$initializer$ DQ FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Move@AEAH@std@@YA$$QEAHAEAH@Z
_TEXT	SEGMENT
_Arg$ = 16
??$_Move@AEAH@std@@YA$$QEAHAEAH@Z PROC			; std::_Move<int & __ptr64>, COMDAT

; 1798 : 	{	// forward _Arg as movable

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 1799 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1800 : 	}

	pop	rdi
	ret	0
??$_Move@AEAH@std@@YA$$QEAHAEAH@Z ENDP			; std::_Move<int & __ptr64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$swap@H@std@@YAXAEAH0@Z
_TEXT	SEGMENT
_Tmp$ = 36
_Left$ = 80
_Right$ = 88
??$swap@H@std@@YAXAEAH0@Z PROC				; std::swap<int>, COMDAT

; 46   : 	{	// exchange values stored at _Left and _Right

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 47   : 	_Ty _Tmp = _Move(_Left);

	mov	rcx, QWORD PTR _Left$[rsp]
	call	??$_Move@AEAH@std@@YA$$QEAHAEAH@Z	; std::_Move<int & __ptr64>
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR _Tmp$[rsp], eax

; 48   : 	_Left = _Move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$_Move@AEAH@std@@YA$$QEAHAEAH@Z	; std::_Move<int & __ptr64>
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 49   : 	_Right = _Move(_Tmp);

	lea	rcx, QWORD PTR _Tmp$[rsp]
	call	??$_Move@AEAH@std@@YA$$QEAHAEAH@Z	; std::_Move<int & __ptr64>
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 50   : 	}

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:??$swap@H@std@@YAXAEAH0@Z$rtcFrameData
	call	_RTC_CheckStackVars
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$swap@H@std@@YAXAEAH0@Z ENDP				; std::swap<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
result$ = 16
i$1 = 24
is$2 = 32
values$ = 64
count$ = 72
s$ = 80
?interpolate_int_array@graphics@@YANPEAHHN@Z PROC	; graphics::interpolate_int_array

; 7    : double interpolate_int_array(int* values, int count, double s) {

$LN6:
	movsdx	QWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 8    :   double result=0;

	xorps	xmm0, xmm0
	movsdx	QWORD PTR result$[rsp], xmm0

; 9    :   for (int i=0;i<count;i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@interpolat
$LN2@interpolat:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@interpolat:
	mov	eax, DWORD PTR count$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN1@interpolat

; 10   :       double is = static_cast<double>(count)/static_cast<double>(count-(i+1));

	cvtsi2sd xmm0, DWORD PTR count$[rsp]
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	ecx, DWORD PTR count$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm1, eax
	divsd	xmm0, xmm1
	movsdx	QWORD PTR is$2[rsp], xmm0

; 11   :       result += values[i]*(is-s);

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR values$[rsp]
	cvtsi2sd xmm0, DWORD PTR [rcx+rax*4]
	movsdx	xmm1, QWORD PTR is$2[rsp]
	subsd	xmm1, QWORD PTR s$[rsp]
	mulsd	xmm0, xmm1
	movsdx	xmm1, QWORD PTR result$[rsp]
	addsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsdx	QWORD PTR result$[rsp], xmm0

; 12   :   }

	jmp	SHORT $LN2@interpolat
$LN1@interpolat:

; 13   :   return result;

	movsdx	xmm0, QWORD PTR result$[rsp]

; 14   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?interpolate_int_array@graphics@@YANPEAHHN@Z ENDP	; graphics::interpolate_int_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GGDI@graphics@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GGDI@graphics@@UEAAPEAXI@Z PROC			; graphics::GDI::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]
	mov	rcx, QWORD PTR this$[rsp]
	call	??1GDI@graphics@@UEAA@XZ		; graphics::GDI::~GDI
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN1@scalar
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX@Z				; operator delete
$LN1@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GGDI@graphics@@UEAAPEAXI@Z ENDP			; graphics::GDI::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.h
;	COMDAT ?ClearFill@GDI@graphics@@AEAAXXZ
_TEXT	SEGMENT
this$ = 16
?ClearFill@GDI@graphics@@AEAAXXZ PROC			; graphics::GDI::ClearFill, COMDAT

; 52   :   void ClearFill() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 53   : 
; 54   :   }

	pop	rdi
	ret	0
?ClearFill@GDI@graphics@@AEAAXXZ ENDP			; graphics::GDI::ClearFill
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.h
;	COMDAT ?FillPixel@GDI@graphics@@AEAAXHHNN@Z
_TEXT	SEGMENT
index$ = 32
c$4 = 52
$T5 = 68
$T6 = 72
$T7 = 76
tv90 = 80
tv158 = 88
this$ = 112
x$ = 120
y$ = 128
xs$ = 136
ys$ = 144
?FillPixel@GDI@graphics@@AEAAXHHNN@Z PROC		; graphics::GDI::FillPixel, COMDAT

; 41   :   void FillPixel(int x, int y, double xs, double ys) {

$LN6:
	movsdx	QWORD PTR [rsp+32], xmm3
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+112]

; 42   :     int index = x+(y*display_width_);

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR y$[rsp]
	imul	ecx, DWORD PTR [rax+16]
	mov	eax, ecx
	mov	ecx, DWORD PTR x$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR index$[rsp], eax

; 43   :     if (fill_.mode == kSolid) { //Solid Fill

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+188], 0
	jne	SHORT $LN3@FillPixel

; 44   :       back_buffer_[index] = interpolate_color(back_buffer_[index],fill_.colors[0],fill_.alphas[0]);

	mov	eax, 8
	imul	rax, 0
	mov	ecx, 4
	imul	rcx, 0
	movsxd	rdx, DWORD PTR index$[rsp]
	mov	QWORD PTR tv90[rsp], rdx
	mov	r8, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [r8+88]
	mov	r9, QWORD PTR this$[rsp]
	movsdx	xmm2, QWORD PTR [r9+rax+120]
	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR [rax+rcx+104]
	mov	rax, QWORD PTR tv90[rsp]
	mov	ecx, DWORD PTR [r8+rax*4]
	call	?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z ; graphics::interpolate_color
	mov	DWORD PTR $T5[rsp], eax
	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	edx, DWORD PTR $T5[rsp]
	mov	DWORD PTR [rcx+rax*4], edx
	jmp	$LN2@FillPixel
$LN3@FillPixel:

; 45   :     }
; 46   :     else if (fill_.mode == kGradientHorizontal) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+188], 1
	jne	$LN1@FillPixel

; 47   :       RGBQUAD c = interpolate_color(fill_.colors[0],fill_.colors[1],xs);

	mov	eax, 4
	imul	rax, 1
	mov	ecx, 4
	imul	rcx, 0
	movsdx	xmm2, QWORD PTR xs$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR [rdx+rax+104]
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rax+rcx+104]
	call	?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z ; graphics::interpolate_color
	mov	DWORD PTR $T6[rsp], eax
	mov	eax, DWORD PTR $T6[rsp]
	mov	DWORD PTR c$4[rsp], eax

; 48   :       back_buffer_[index] = interpolate_color(back_buffer_[index],c,fill_.alphas[0]);

	mov	eax, 8
	imul	rax, 0
	movsxd	rcx, DWORD PTR index$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+88]
	mov	QWORD PTR tv158[rsp], rdx
	mov	r8, QWORD PTR this$[rsp]
	movsdx	xmm2, QWORD PTR [r8+rax+120]
	mov	edx, DWORD PTR c$4[rsp]
	mov	rax, QWORD PTR tv158[rsp]
	mov	ecx, DWORD PTR [rax+rcx*4]
	call	?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z ; graphics::interpolate_color
	mov	DWORD PTR $T7[rsp], eax
	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	edx, DWORD PTR $T7[rsp]
	mov	DWORD PTR [rcx+rax*4], edx
$LN1@FillPixel:
$LN2@FillPixel:

; 49   :     }  
; 50   :   }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:?FillPixel@GDI@graphics@@AEAAXHHNN@Z$rtcFrameData
	call	_RTC_CheckStackVars
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
?FillPixel@GDI@graphics@@AEAAXHHNN@Z ENDP		; graphics::GDI::FillPixel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.h
;	COMDAT ?TestBoundry@GDI@graphics@@AEAA_NHH@Z
_TEXT	SEGMENT
tv76 = 0
this$ = 32
x$ = 40
y$ = 48
?TestBoundry@GDI@graphics@@AEAA_NHH@Z PROC		; graphics::GDI::TestBoundry, COMDAT

; 33   :   bool TestBoundry(int x,int y) {

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 34   :    return ( x >= clip_.x && y >= clip_.y && x < clip_.width && y < clip_.height );

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+192]
	cmp	DWORD PTR x$[rsp], eax
	jl	SHORT $LN3@TestBoundr
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+196]
	cmp	DWORD PTR y$[rsp], eax
	jl	SHORT $LN3@TestBoundr
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+200]
	cmp	DWORD PTR x$[rsp], eax
	jge	SHORT $LN3@TestBoundr
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+204]
	cmp	DWORD PTR y$[rsp], eax
	jge	SHORT $LN3@TestBoundr
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN4@TestBoundr
$LN3@TestBoundr:
	mov	DWORD PTR tv76[rsp], 0
$LN4@TestBoundr:
	movzx	eax, BYTE PTR tv76[rsp]

; 35   :   }

	add	rsp, 16
	pop	rdi
	ret	0
?TestBoundry@GDI@graphics@@AEAA_NHH@Z ENDP		; graphics::GDI::TestBoundry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
steep$ = 48
deltax$ = 52
deltay$ = 56
error$ = 60
ystep$ = 64
y$ = 68
x$1 = 72
xindex$2 = 80
yindex$3 = 88
tv64 = 96
tv71 = 100
this$ = 128
x0$ = 136
y0$ = 144
x1$ = 152
y1$ = 160
?DrawLine@GDI@graphics@@QEAAXHHHH@Z PROC		; graphics::GDI::DrawLine

; 236  : void GDI::DrawLine(int x0, int y0, int x1, int y1) {

$LN15:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]

; 237  :   
; 238  :   //int xmin = x0 > x1 ? x1 : x0;
; 239  :  // int xmax = x0 > x1 ? x0 : x1;
; 240  :   
; 241  :  // int ymin = y0 > y1 ? y1 : y0;
; 242  :  // int ymax = y0 > y1 ? y0 : y1;
; 243  :   
; 244  :   bool steep = abs(y1 - y0) > abs(x1 - x0);

	mov	eax, DWORD PTR y0$[rsp]
	mov	ecx, DWORD PTR y1$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, eax
	call	abs
	mov	DWORD PTR tv64[rsp], eax
	mov	ecx, DWORD PTR x0$[rsp]
	mov	edx, DWORD PTR x1$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	call	abs
	mov	ecx, DWORD PTR tv64[rsp]
	cmp	ecx, eax
	jle	SHORT $LN13@DrawLine
	mov	DWORD PTR tv71[rsp], 1
	jmp	SHORT $LN14@DrawLine
$LN13@DrawLine:
	mov	DWORD PTR tv71[rsp], 0
$LN14@DrawLine:
	movzx	eax, BYTE PTR tv71[rsp]
	mov	BYTE PTR steep$[rsp], al

; 245  :   if (steep == true) {

	movzx	eax, BYTE PTR steep$[rsp]
	cmp	eax, 1
	jne	SHORT $LN10@DrawLine

; 246  :     //swap_int(x0,y0);
; 247  :     //swap_int(x1,y1);
; 248  :     std::swap<int>(x0,y0);

	lea	rdx, QWORD PTR y0$[rsp]
	lea	rcx, QWORD PTR x0$[rsp]
	call	??$swap@H@std@@YAXAEAH0@Z		; std::swap<int>

; 249  :     std::swap<int>(x1,y1);    

	lea	rdx, QWORD PTR y1$[rsp]
	lea	rcx, QWORD PTR x1$[rsp]
	call	??$swap@H@std@@YAXAEAH0@Z		; std::swap<int>
$LN10@DrawLine:

; 250  :   }
; 251  :   
; 252  :   if (x0 > x1) {

	mov	eax, DWORD PTR x1$[rsp]
	cmp	DWORD PTR x0$[rsp], eax
	jle	SHORT $LN9@DrawLine

; 253  :     std::swap<int>(x0,x1);

	lea	rdx, QWORD PTR x1$[rsp]
	lea	rcx, QWORD PTR x0$[rsp]
	call	??$swap@H@std@@YAXAEAH0@Z		; std::swap<int>

; 254  :     std::swap<int>(y0,y1);

	lea	rdx, QWORD PTR y1$[rsp]
	lea	rcx, QWORD PTR y0$[rsp]
	call	??$swap@H@std@@YAXAEAH0@Z		; std::swap<int>
$LN9@DrawLine:

; 255  :   }
; 256  : 
; 257  :   
; 258  :   int deltax = x1 - x0;

	mov	eax, DWORD PTR x0$[rsp]
	mov	ecx, DWORD PTR x1$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR deltax$[rsp], eax

; 259  :   int deltay = abs(y1 - y0);

	mov	eax, DWORD PTR y0$[rsp]
	mov	ecx, DWORD PTR y1$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, eax
	call	abs
	mov	DWORD PTR deltay$[rsp], eax

; 260  :   int error = deltax / 2;

	mov	eax, DWORD PTR deltax$[rsp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR error$[rsp], eax

; 261  :   int ystep;
; 262  :   int y = y0;

	mov	eax, DWORD PTR y0$[rsp]
	mov	DWORD PTR y$[rsp], eax

; 263  :   if (y0 < y1) 

	mov	eax, DWORD PTR y1$[rsp]
	cmp	DWORD PTR y0$[rsp], eax
	jge	SHORT $LN8@DrawLine

; 264  :     ystep = 1;

	mov	DWORD PTR ystep$[rsp], 1

; 265  :   else 

	jmp	SHORT $LN7@DrawLine
$LN8@DrawLine:

; 266  :     ystep = -1;

	mov	DWORD PTR ystep$[rsp], -1
$LN7@DrawLine:

; 267  :     
; 268  :   for (int x = x0; x <= x1; x++) {

	mov	eax, DWORD PTR x0$[rsp]
	mov	DWORD PTR x$1[rsp], eax
	jmp	SHORT $LN6@DrawLine
$LN5@DrawLine:
	mov	eax, DWORD PTR x$1[rsp]
	inc	eax
	mov	DWORD PTR x$1[rsp], eax
$LN6@DrawLine:
	mov	eax, DWORD PTR x1$[rsp]
	cmp	DWORD PTR x$1[rsp], eax
	jg	$LN4@DrawLine

; 269  :     double xindex = static_cast<double>(x-x0)/static_cast<double>(x1-x0); 

	mov	eax, DWORD PTR x0$[rsp]
	mov	ecx, DWORD PTR x$1[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm0, eax
	mov	eax, DWORD PTR x0$[rsp]
	mov	ecx, DWORD PTR x1$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm1, eax
	divsd	xmm0, xmm1
	movsdx	QWORD PTR xindex$2[rsp], xmm0

; 270  :     double yindex = static_cast<double>(y-y0)/static_cast<double>(y1-y0);         

	mov	eax, DWORD PTR y0$[rsp]
	mov	ecx, DWORD PTR y$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm0, eax
	mov	eax, DWORD PTR y0$[rsp]
	mov	ecx, DWORD PTR y1$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm1, eax
	divsd	xmm0, xmm1
	movsdx	QWORD PTR yindex$3[rsp], xmm0

; 271  :     if (steep == true) {

	movzx	eax, BYTE PTR steep$[rsp]
	cmp	eax, 1
	jne	SHORT $LN3@DrawLine

; 272  :       FillPixel(y,x,xindex,yindex);

	movsdx	xmm0, QWORD PTR yindex$3[rsp]
	movsdx	QWORD PTR [rsp+32], xmm0
	movsdx	xmm3, QWORD PTR xindex$2[rsp]
	mov	r8d, DWORD PTR x$1[rsp]
	mov	edx, DWORD PTR y$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?FillPixel@GDI@graphics@@AEAAXHHNN@Z	; graphics::GDI::FillPixel

; 273  :     }
; 274  :     else {

	jmp	SHORT $LN2@DrawLine
$LN3@DrawLine:

; 275  :       FillPixel(x,y,xindex,yindex);

	movsdx	xmm0, QWORD PTR yindex$3[rsp]
	movsdx	QWORD PTR [rsp+32], xmm0
	movsdx	xmm3, QWORD PTR xindex$2[rsp]
	mov	r8d, DWORD PTR y$[rsp]
	mov	edx, DWORD PTR x$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?FillPixel@GDI@graphics@@AEAAXHHNN@Z	; graphics::GDI::FillPixel
$LN2@DrawLine:

; 276  :     }
; 277  :     
; 278  :     error = error - deltay;

	mov	eax, DWORD PTR deltay$[rsp]
	mov	ecx, DWORD PTR error$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR error$[rsp], eax

; 279  :     if (error < 0) {

	cmp	DWORD PTR error$[rsp], 0
	jge	SHORT $LN1@DrawLine

; 280  :       y = y + ystep;

	mov	eax, DWORD PTR ystep$[rsp]
	mov	ecx, DWORD PTR y$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR y$[rsp], eax

; 281  :       error = error + deltax;  

	mov	eax, DWORD PTR deltax$[rsp]
	mov	ecx, DWORD PTR error$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR error$[rsp], eax
$LN1@DrawLine:

; 282  :     }
; 283  :     
; 284  :   }

	jmp	$LN5@DrawLine
$LN4@DrawLine:

; 285  :   
; 286  : 
; 287  :   /*double slope = (y1-y0)/(x1-x0);
; 288  :   for (int i = i0; i <= i1; i++) {
; 289  :     double ry = (slope*i)+y0;
; 290  :     int y = static_cast<int>(ry);
; 291  :     double xindex = static_cast<double>(i-xmin)/static_cast<double>(xmax-xmin); 
; 292  :     double yindex = static_cast<double>(y-ymin)/static_cast<double>(ymax-ymin);         
; 293  :     FillPixel(u,v,xindex,yindex);
; 294  :   }*/
; 295  : 
; 296  : }

	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
?DrawLine@GDI@graphics@@QEAAXHHHH@Z ENDP		; graphics::GDI::DrawLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
xmin$ = 48
ymin$ = 52
xmax$ = 56
ymax$ = 60
v$1 = 64
u$2 = 68
alpha$3 = 72
beta$4 = 80
gamma$5 = 88
xindex$6 = 96
yindex$7 = 104
tv65 = 112
tv67 = 116
tv69 = 120
tv71 = 124
tv73 = 128
tv75 = 132
tv77 = 136
tv79 = 140
this$ = 160
x0$ = 168
y0$ = 176
x1$ = 184
y1$ = 192
x2$ = 200
y2$ = 208
?DrawTriangle@GDI@graphics@@QEAAXHHHHHH@Z PROC		; graphics::GDI::DrawTriangle

; 158  : void GDI::DrawTriangle(int x0, int y0, int x1, int y1, int x2, int y2) {

$LN27:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 144				; 00000090H
	mov	rdi, rsp
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+160]

; 159  : 
; 160  :   //rotation
; 161  :   /*math::vector_1x2 v1={x0,y0};
; 162  :   math::vector_1x2 v2={x1,y1};
; 163  :   math::vector_1x2 v3={x2,y2};
; 164  :   math::vector_1x2 rv;
; 165  : 
; 166  :   math::matrix_2x2 m1;
; 167  :   math::matrix_2x2 m2,m3;
; 168  : 
; 169  :   theta += M_PI/100;
; 170  : 
; 171  :   double c = cos(theta);
; 172  :   double s = sin(theta);
; 173  :   m1(0,0) = c;
; 174  :   m1(0,1) = -s;
; 175  :   m1(1,0) = s;
; 176  :   m1(1,1) = c;
; 177  : 
; 178  :   m2(0,0) = 2;
; 179  :   m2(0,1) = 0;
; 180  :   m2(1,0) = 0;
; 181  :   m2(1,1) = 2;
; 182  :   
; 183  :   m1 = m1 * m2;
; 184  :   m3 = m1.inverse();
; 185  : 
; 186  :   rv = v1 * m1;
; 187  :   x0 = static_cast<int>(rv.x);
; 188  :   y0 = static_cast<int>(rv.y);
; 189  :   rv = v2 * m1;
; 190  :   x1 = static_cast<int>(rv.x);
; 191  :   y1 = static_cast<int>(rv.y);
; 192  :   rv = v3 * m1;
; 193  :   x2 = static_cast<int>(rv.x);
; 194  :   y2 = static_cast<int>(rv.y);*/  
; 195  : 
; 196  : #define f12(x,y) ((y1-y2)*x + (x2-x1)*y + x1*y2 - x2*y1)
; 197  : #define f20(x,y) ((y2-y0)*x + (x0-x2)*y + x2*y0 - x0*y2)
; 198  : #define f01(x,y) ((y0-y1)*x + (x1-x0)*y + x0*y1 - x1*y0)
; 199  : 
; 200  :   int xmin = x0 > x1 ? x1 : x0;

	mov	eax, DWORD PTR x1$[rsp]
	cmp	DWORD PTR x0$[rsp], eax
	jle	SHORT $LN11@DrawTriang
	mov	eax, DWORD PTR x1$[rsp]
	mov	DWORD PTR tv65[rsp], eax
	jmp	SHORT $LN12@DrawTriang
$LN11@DrawTriang:
	mov	eax, DWORD PTR x0$[rsp]
	mov	DWORD PTR tv65[rsp], eax
$LN12@DrawTriang:
	mov	eax, DWORD PTR tv65[rsp]
	mov	DWORD PTR xmin$[rsp], eax

; 201  :   xmin = xmin > x2 ? x2 : xmin;

	mov	eax, DWORD PTR x2$[rsp]
	cmp	DWORD PTR xmin$[rsp], eax
	jle	SHORT $LN13@DrawTriang
	mov	eax, DWORD PTR x2$[rsp]
	mov	DWORD PTR tv67[rsp], eax
	jmp	SHORT $LN14@DrawTriang
$LN13@DrawTriang:
	mov	eax, DWORD PTR xmin$[rsp]
	mov	DWORD PTR tv67[rsp], eax
$LN14@DrawTriang:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR xmin$[rsp], eax

; 202  :   
; 203  :   int ymin = y0 > y1 ? y1 : y0;

	mov	eax, DWORD PTR y1$[rsp]
	cmp	DWORD PTR y0$[rsp], eax
	jle	SHORT $LN15@DrawTriang
	mov	eax, DWORD PTR y1$[rsp]
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN16@DrawTriang
$LN15@DrawTriang:
	mov	eax, DWORD PTR y0$[rsp]
	mov	DWORD PTR tv69[rsp], eax
$LN16@DrawTriang:
	mov	eax, DWORD PTR tv69[rsp]
	mov	DWORD PTR ymin$[rsp], eax

; 204  :   ymin = ymin > y2 ? y2 : ymin;  

	mov	eax, DWORD PTR y2$[rsp]
	cmp	DWORD PTR ymin$[rsp], eax
	jle	SHORT $LN17@DrawTriang
	mov	eax, DWORD PTR y2$[rsp]
	mov	DWORD PTR tv71[rsp], eax
	jmp	SHORT $LN18@DrawTriang
$LN17@DrawTriang:
	mov	eax, DWORD PTR ymin$[rsp]
	mov	DWORD PTR tv71[rsp], eax
$LN18@DrawTriang:
	mov	eax, DWORD PTR tv71[rsp]
	mov	DWORD PTR ymin$[rsp], eax

; 205  : 
; 206  :   int xmax = x0 > x1 ? x0 : x1;

	mov	eax, DWORD PTR x1$[rsp]
	cmp	DWORD PTR x0$[rsp], eax
	jle	SHORT $LN19@DrawTriang
	mov	eax, DWORD PTR x0$[rsp]
	mov	DWORD PTR tv73[rsp], eax
	jmp	SHORT $LN20@DrawTriang
$LN19@DrawTriang:
	mov	eax, DWORD PTR x1$[rsp]
	mov	DWORD PTR tv73[rsp], eax
$LN20@DrawTriang:
	mov	eax, DWORD PTR tv73[rsp]
	mov	DWORD PTR xmax$[rsp], eax

; 207  :   xmax = xmax > x2 ? xmax : x2;

	mov	eax, DWORD PTR x2$[rsp]
	cmp	DWORD PTR xmax$[rsp], eax
	jle	SHORT $LN21@DrawTriang
	mov	eax, DWORD PTR xmax$[rsp]
	mov	DWORD PTR tv75[rsp], eax
	jmp	SHORT $LN22@DrawTriang
$LN21@DrawTriang:
	mov	eax, DWORD PTR x2$[rsp]
	mov	DWORD PTR tv75[rsp], eax
$LN22@DrawTriang:
	mov	eax, DWORD PTR tv75[rsp]
	mov	DWORD PTR xmax$[rsp], eax

; 208  : 
; 209  :   int ymax = y0 > y1 ? y0 : y1;

	mov	eax, DWORD PTR y1$[rsp]
	cmp	DWORD PTR y0$[rsp], eax
	jle	SHORT $LN23@DrawTriang
	mov	eax, DWORD PTR y0$[rsp]
	mov	DWORD PTR tv77[rsp], eax
	jmp	SHORT $LN24@DrawTriang
$LN23@DrawTriang:
	mov	eax, DWORD PTR y1$[rsp]
	mov	DWORD PTR tv77[rsp], eax
$LN24@DrawTriang:
	mov	eax, DWORD PTR tv77[rsp]
	mov	DWORD PTR ymax$[rsp], eax

; 210  :   ymax = ymax > y2 ? ymax : y2;

	mov	eax, DWORD PTR y2$[rsp]
	cmp	DWORD PTR ymax$[rsp], eax
	jle	SHORT $LN25@DrawTriang
	mov	eax, DWORD PTR ymax$[rsp]
	mov	DWORD PTR tv79[rsp], eax
	jmp	SHORT $LN26@DrawTriang
$LN25@DrawTriang:
	mov	eax, DWORD PTR y2$[rsp]
	mov	DWORD PTR tv79[rsp], eax
$LN26@DrawTriang:
	mov	eax, DWORD PTR tv79[rsp]
	mov	DWORD PTR ymax$[rsp], eax

; 211  :   
; 212  :   for (int v = ymin; v <= ymax; v++) {

	mov	eax, DWORD PTR ymin$[rsp]
	mov	DWORD PTR v$1[rsp], eax
	jmp	SHORT $LN8@DrawTriang
$LN7@DrawTriang:
	mov	eax, DWORD PTR v$1[rsp]
	inc	eax
	mov	DWORD PTR v$1[rsp], eax
$LN8@DrawTriang:
	mov	eax, DWORD PTR ymax$[rsp]
	cmp	DWORD PTR v$1[rsp], eax
	jg	$LN6@DrawTriang

; 213  :     for (int u = xmin; u <= xmax; u++) {

	mov	eax, DWORD PTR xmin$[rsp]
	mov	DWORD PTR u$2[rsp], eax
	jmp	SHORT $LN5@DrawTriang
$LN4@DrawTriang:
	mov	eax, DWORD PTR u$2[rsp]
	inc	eax
	mov	DWORD PTR u$2[rsp], eax
$LN5@DrawTriang:
	mov	eax, DWORD PTR xmax$[rsp]
	cmp	DWORD PTR u$2[rsp], eax
	jg	$LN3@DrawTriang

; 214  :       if ( TestBoundry(u,v) == true ) {    

	mov	r8d, DWORD PTR v$1[rsp]
	mov	edx, DWORD PTR u$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?TestBoundry@GDI@graphics@@AEAA_NHH@Z	; graphics::GDI::TestBoundry
	movzx	eax, al
	cmp	eax, 1
	jne	$LN2@DrawTriang

; 215  :         double alpha = static_cast<double>(f12(u,v))/static_cast<double>(f12(x0,y0));

	mov	eax, DWORD PTR y2$[rsp]
	mov	ecx, DWORD PTR y1$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	imul	eax, DWORD PTR u$2[rsp]
	mov	ecx, DWORD PTR x1$[rsp]
	mov	edx, DWORD PTR x2$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	imul	ecx, DWORD PTR v$1[rsp]
	add	eax, ecx
	mov	ecx, DWORD PTR x1$[rsp]
	imul	ecx, DWORD PTR y2$[rsp]
	add	eax, ecx
	mov	ecx, DWORD PTR x2$[rsp]
	imul	ecx, DWORD PTR y1$[rsp]
	sub	eax, ecx
	cvtsi2sd xmm0, eax
	mov	eax, DWORD PTR y2$[rsp]
	mov	ecx, DWORD PTR y1$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	imul	eax, DWORD PTR x0$[rsp]
	mov	ecx, DWORD PTR x1$[rsp]
	mov	edx, DWORD PTR x2$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	imul	ecx, DWORD PTR y0$[rsp]
	add	eax, ecx
	mov	ecx, DWORD PTR x1$[rsp]
	imul	ecx, DWORD PTR y2$[rsp]
	add	eax, ecx
	mov	ecx, DWORD PTR x2$[rsp]
	imul	ecx, DWORD PTR y1$[rsp]
	sub	eax, ecx
	cvtsi2sd xmm1, eax
	divsd	xmm0, xmm1
	movsdx	QWORD PTR alpha$3[rsp], xmm0

; 216  :         double beta  = static_cast<double>(f20(u,v))/static_cast<double>(f20(x1,y1));

	mov	eax, DWORD PTR y0$[rsp]
	mov	ecx, DWORD PTR y2$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	imul	eax, DWORD PTR u$2[rsp]
	mov	ecx, DWORD PTR x2$[rsp]
	mov	edx, DWORD PTR x0$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	imul	ecx, DWORD PTR v$1[rsp]
	add	eax, ecx
	mov	ecx, DWORD PTR x2$[rsp]
	imul	ecx, DWORD PTR y0$[rsp]
	add	eax, ecx
	mov	ecx, DWORD PTR x0$[rsp]
	imul	ecx, DWORD PTR y2$[rsp]
	sub	eax, ecx
	cvtsi2sd xmm0, eax
	mov	eax, DWORD PTR y0$[rsp]
	mov	ecx, DWORD PTR y2$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	imul	eax, DWORD PTR x1$[rsp]
	mov	ecx, DWORD PTR x2$[rsp]
	mov	edx, DWORD PTR x0$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	imul	ecx, DWORD PTR y1$[rsp]
	add	eax, ecx
	mov	ecx, DWORD PTR x2$[rsp]
	imul	ecx, DWORD PTR y0$[rsp]
	add	eax, ecx
	mov	ecx, DWORD PTR x0$[rsp]
	imul	ecx, DWORD PTR y2$[rsp]
	sub	eax, ecx
	cvtsi2sd xmm1, eax
	divsd	xmm0, xmm1
	movsdx	QWORD PTR beta$4[rsp], xmm0

; 217  :         double gamma = static_cast<double>(f01(u,v))/static_cast<double>(f01(x2,y2));

	mov	eax, DWORD PTR y1$[rsp]
	mov	ecx, DWORD PTR y0$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	imul	eax, DWORD PTR u$2[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	mov	edx, DWORD PTR x1$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	imul	ecx, DWORD PTR v$1[rsp]
	add	eax, ecx
	mov	ecx, DWORD PTR x0$[rsp]
	imul	ecx, DWORD PTR y1$[rsp]
	add	eax, ecx
	mov	ecx, DWORD PTR x1$[rsp]
	imul	ecx, DWORD PTR y0$[rsp]
	sub	eax, ecx
	cvtsi2sd xmm0, eax
	mov	eax, DWORD PTR y1$[rsp]
	mov	ecx, DWORD PTR y0$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	imul	eax, DWORD PTR x2$[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	mov	edx, DWORD PTR x1$[rsp]
	sub	edx, ecx
	mov	ecx, edx
	imul	ecx, DWORD PTR y2$[rsp]
	add	eax, ecx
	mov	ecx, DWORD PTR x0$[rsp]
	imul	ecx, DWORD PTR y1$[rsp]
	add	eax, ecx
	mov	ecx, DWORD PTR x1$[rsp]
	imul	ecx, DWORD PTR y0$[rsp]
	sub	eax, ecx
	cvtsi2sd xmm1, eax
	divsd	xmm0, xmm1
	movsdx	QWORD PTR gamma$5[rsp], xmm0

; 218  :         if ( alpha >= 0 && alpha <= 1 && 
; 219  :              beta  >= 0 && beta  <= 1 && 
; 220  :              gamma >= 0 && gamma <= 1) {

	movsdx	xmm0, QWORD PTR alpha$3[rsp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	$LN1@DrawTriang
	movsdx	xmm0, QWORD PTR __real@3ff0000000000000
	comisd	xmm0, QWORD PTR alpha$3[rsp]
	jb	$LN1@DrawTriang
	movsdx	xmm0, QWORD PTR beta$4[rsp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	$LN1@DrawTriang
	movsdx	xmm0, QWORD PTR __real@3ff0000000000000
	comisd	xmm0, QWORD PTR beta$4[rsp]
	jb	$LN1@DrawTriang
	movsdx	xmm0, QWORD PTR gamma$5[rsp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	$LN1@DrawTriang
	movsdx	xmm0, QWORD PTR __real@3ff0000000000000
	comisd	xmm0, QWORD PTR gamma$5[rsp]
	jb	SHORT $LN1@DrawTriang

; 221  :           double xindex = static_cast<double>(u-xmin)/static_cast<double>(xmax-xmin); 

	mov	eax, DWORD PTR xmin$[rsp]
	mov	ecx, DWORD PTR u$2[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm0, eax
	mov	eax, DWORD PTR xmin$[rsp]
	mov	ecx, DWORD PTR xmax$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm1, eax
	divsd	xmm0, xmm1
	movsdx	QWORD PTR xindex$6[rsp], xmm0

; 222  :           double yindex = static_cast<double>(v-ymin)/static_cast<double>(ymax-ymin);         

	mov	eax, DWORD PTR ymin$[rsp]
	mov	ecx, DWORD PTR v$1[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm0, eax
	mov	eax, DWORD PTR ymin$[rsp]
	mov	ecx, DWORD PTR ymax$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm1, eax
	divsd	xmm0, xmm1
	movsdx	QWORD PTR yindex$7[rsp], xmm0

; 223  :           FillPixel(u,v,xindex,yindex);

	movsdx	xmm0, QWORD PTR yindex$7[rsp]
	movsdx	QWORD PTR [rsp+32], xmm0
	movsdx	xmm3, QWORD PTR xindex$6[rsp]
	mov	r8d, DWORD PTR v$1[rsp]
	mov	edx, DWORD PTR u$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?FillPixel@GDI@graphics@@AEAAXHHNN@Z	; graphics::GDI::FillPixel
$LN1@DrawTriang:
$LN2@DrawTriang:

; 224  :         }
; 225  :       }
; 226  :     }

	jmp	$LN4@DrawTriang
$LN3@DrawTriang:

; 227  :   }

	jmp	$LN7@DrawTriang
$LN6@DrawTriang:

; 228  :   
; 229  : 
; 230  : #undef f12
; 231  : #undef f20
; 232  : #undef f01
; 233  : 
; 234  : }

	add	rsp, 144				; 00000090H
	pop	rdi
	ret	0
?DrawTriangle@GDI@graphics@@QEAAXHHHHHH@Z ENDP		; graphics::GDI::DrawTriangle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
v$1 = 48
u$2 = 52
test$3 = 56
xindex$4 = 64
yindex$5 = 72
this$ = 96
x$ = 104
y$ = 112
radius$ = 120
?DrawCircle@GDI@graphics@@QEAAXHHH@Z PROC		; graphics::GDI::DrawCircle

; 142  : void GDI::DrawCircle(int x, int y, int radius) {

$LN11:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 143  :   
; 144  :   for (int v = y; v < (y+radius*2); v++) {

	mov	eax, DWORD PTR y$[rsp]
	mov	DWORD PTR v$1[rsp], eax
	jmp	SHORT $LN8@DrawCircle
$LN7@DrawCircle:
	mov	eax, DWORD PTR v$1[rsp]
	inc	eax
	mov	DWORD PTR v$1[rsp], eax
$LN8@DrawCircle:
	mov	eax, DWORD PTR y$[rsp]
	mov	ecx, DWORD PTR radius$[rsp]
	lea	eax, DWORD PTR [rax+rcx*2]
	cmp	DWORD PTR v$1[rsp], eax
	jge	$LN6@DrawCircle

; 145  :     for (int u = x; u < (x+radius*2); u++) {

	mov	eax, DWORD PTR x$[rsp]
	mov	DWORD PTR u$2[rsp], eax
	jmp	SHORT $LN5@DrawCircle
$LN4@DrawCircle:
	mov	eax, DWORD PTR u$2[rsp]
	inc	eax
	mov	DWORD PTR u$2[rsp], eax
$LN5@DrawCircle:
	mov	eax, DWORD PTR x$[rsp]
	mov	ecx, DWORD PTR radius$[rsp]
	lea	eax, DWORD PTR [rax+rcx*2]
	cmp	DWORD PTR u$2[rsp], eax
	jge	$LN3@DrawCircle

; 146  :       if ( TestBoundry(u,v) == true ) {

	mov	r8d, DWORD PTR v$1[rsp]
	mov	edx, DWORD PTR u$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?TestBoundry@GDI@graphics@@AEAA_NHH@Z	; graphics::GDI::TestBoundry
	movzx	eax, al
	cmp	eax, 1
	jne	$LN2@DrawCircle

; 147  :         int test = (u-x-radius)*(u-x-radius) + (v-y-radius)*(v-y-radius);

	mov	eax, DWORD PTR x$[rsp]
	mov	ecx, DWORD PTR u$2[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sub	eax, DWORD PTR radius$[rsp]
	mov	ecx, DWORD PTR x$[rsp]
	mov	edx, DWORD PTR u$2[rsp]
	sub	edx, ecx
	mov	ecx, edx
	sub	ecx, DWORD PTR radius$[rsp]
	imul	eax, ecx
	mov	ecx, DWORD PTR y$[rsp]
	mov	edx, DWORD PTR v$1[rsp]
	sub	edx, ecx
	mov	ecx, edx
	sub	ecx, DWORD PTR radius$[rsp]
	mov	edx, DWORD PTR y$[rsp]
	mov	r8d, DWORD PTR v$1[rsp]
	sub	r8d, edx
	mov	edx, r8d
	sub	edx, DWORD PTR radius$[rsp]
	imul	ecx, edx
	add	eax, ecx
	mov	DWORD PTR test$3[rsp], eax

; 148  :         if (test < radius*radius) {

	mov	eax, DWORD PTR radius$[rsp]
	imul	eax, DWORD PTR radius$[rsp]
	cmp	DWORD PTR test$3[rsp], eax
	jge	SHORT $LN1@DrawCircle

; 149  :           double xindex = static_cast<double>(u-x)/static_cast<double>(radius*2); 

	mov	eax, DWORD PTR x$[rsp]
	mov	ecx, DWORD PTR u$2[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm0, eax
	mov	eax, DWORD PTR radius$[rsp]
	shl	eax, 1
	cvtsi2sd xmm1, eax
	divsd	xmm0, xmm1
	movsdx	QWORD PTR xindex$4[rsp], xmm0

; 150  :           double yindex = static_cast<double>(v-y)/static_cast<double>(radius*2);         

	mov	eax, DWORD PTR y$[rsp]
	mov	ecx, DWORD PTR v$1[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm0, eax
	mov	eax, DWORD PTR radius$[rsp]
	shl	eax, 1
	cvtsi2sd xmm1, eax
	divsd	xmm0, xmm1
	movsdx	QWORD PTR yindex$5[rsp], xmm0

; 151  :           FillPixel(u,v,xindex,yindex);

	movsdx	xmm0, QWORD PTR yindex$5[rsp]
	movsdx	QWORD PTR [rsp+32], xmm0
	movsdx	xmm3, QWORD PTR xindex$4[rsp]
	mov	r8d, DWORD PTR v$1[rsp]
	mov	edx, DWORD PTR u$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?FillPixel@GDI@graphics@@AEAAXHHNN@Z	; graphics::GDI::FillPixel
$LN1@DrawCircle:
$LN2@DrawCircle:

; 152  :         }
; 153  :       }
; 154  :     }

	jmp	$LN4@DrawCircle
$LN3@DrawCircle:

; 155  :   }

	jmp	$LN7@DrawCircle
$LN6@DrawCircle:

; 156  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?DrawCircle@GDI@graphics@@QEAAXHHH@Z ENDP		; graphics::GDI::DrawCircle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
v$1 = 48
u$2 = 52
xindex$3 = 56
yindex$4 = 64
this$ = 96
x$ = 104
y$ = 112
width$ = 120
height$ = 128
?DrawRectangle@GDI@graphics@@QEAAXHHHH@Z PROC		; graphics::GDI::DrawRectangle

; 110  : void GDI::DrawRectangle(int x, int y, int width, int height) {

$LN10:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 111  : 
; 112  :   //DrawTriangle(x,y,x+width,y,x,y+height);
; 113  :   //DrawTriangle(x,y+height,x+width,y+height,x+width,y);
; 114  : 
; 115  :   /*
; 116  :   //theta += M_PI/100;
; 117  :   double vx=0,vy=0;
; 118  :   double c = cos(theta);
; 119  :   double s = sin(theta);
; 120  :   double m00 = c;//vx*vx+(1-vx*vx)*c;
; 121  :   double m01 = -s;//vx*vy*(1-c);
; 122  :   double m10 = s;//vx*vy*(1-c);
; 123  :   double m11 = c;//vy*vy+(1-vy*vy)*c;
; 124  :   */
; 125  : 
; 126  :   for (int v = y; v < (y+height); v++) {

	mov	eax, DWORD PTR y$[rsp]
	mov	DWORD PTR v$1[rsp], eax
	jmp	SHORT $LN7@DrawRectan
$LN6@DrawRectan:
	mov	eax, DWORD PTR v$1[rsp]
	inc	eax
	mov	DWORD PTR v$1[rsp], eax
$LN7@DrawRectan:
	mov	eax, DWORD PTR height$[rsp]
	mov	ecx, DWORD PTR y$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	DWORD PTR v$1[rsp], eax
	jge	$LN5@DrawRectan

; 127  :     for (int u = x; u < (x+width); u++) {

	mov	eax, DWORD PTR x$[rsp]
	mov	DWORD PTR u$2[rsp], eax
	jmp	SHORT $LN4@DrawRectan
$LN3@DrawRectan:
	mov	eax, DWORD PTR u$2[rsp]
	inc	eax
	mov	DWORD PTR u$2[rsp], eax
$LN4@DrawRectan:
	mov	eax, DWORD PTR width$[rsp]
	mov	ecx, DWORD PTR x$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	DWORD PTR u$2[rsp], eax
	jge	$LN2@DrawRectan

; 128  :       //int ud = static_cast<int>(u*m00+v*m01);//(u*cos(theta)-v*sin(theta));
; 129  :       //int vd = static_cast<int>(u*m10+v*m11);//(u*sin(theta)+v*cos(theta));
; 130  :       if ( TestBoundry(u,v) == true ) {

	mov	r8d, DWORD PTR v$1[rsp]
	mov	edx, DWORD PTR u$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?TestBoundry@GDI@graphics@@AEAA_NHH@Z	; graphics::GDI::TestBoundry
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN1@DrawRectan

; 131  :         double xindex = static_cast<double>(u-x)/static_cast<double>(width); 

	mov	eax, DWORD PTR x$[rsp]
	mov	ecx, DWORD PTR u$2[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm0, eax
	cvtsi2sd xmm1, DWORD PTR width$[rsp]
	divsd	xmm0, xmm1
	movsdx	QWORD PTR xindex$3[rsp], xmm0

; 132  :         double yindex = static_cast<double>(v-y)/static_cast<double>(height); 

	mov	eax, DWORD PTR y$[rsp]
	mov	ecx, DWORD PTR v$1[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm0, eax
	cvtsi2sd xmm1, DWORD PTR height$[rsp]
	divsd	xmm0, xmm1
	movsdx	QWORD PTR yindex$4[rsp], xmm0

; 133  :         //rotation
; 134  : 
; 135  :         //
; 136  :         FillPixel(u,v,xindex,yindex);

	movsdx	xmm0, QWORD PTR yindex$4[rsp]
	movsdx	QWORD PTR [rsp+32], xmm0
	movsdx	xmm3, QWORD PTR xindex$3[rsp]
	mov	r8d, DWORD PTR v$1[rsp]
	mov	edx, DWORD PTR u$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?FillPixel@GDI@graphics@@AEAAXHHNN@Z	; graphics::GDI::FillPixel
$LN1@DrawRectan:

; 137  :       }
; 138  :     }

	jmp	$LN3@DrawRectan
$LN2@DrawRectan:

; 139  :   }

	jmp	$LN6@DrawRectan
$LN5@DrawRectan:

; 140  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?DrawRectangle@GDI@graphics@@QEAAXHHHH@Z ENDP		; graphics::GDI::DrawRectangle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
this$ = 16
?EndFill@GDI@graphics@@QEAAXXZ PROC			; graphics::GDI::EndFill

; 105  : void GDI::EndFill() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 106  : 
; 107  : }

	pop	rdi
	ret	0
?EndFill@GDI@graphics@@QEAAXXZ ENDP			; graphics::GDI::EndFill
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
i$1 = 32
this$ = 64
colors$ = 72
alphas$ = 80
ratios$ = 88
count$ = 96
mode$ = 104
?BeginGradientFill@GDI@graphics@@QEAAXPEBUtagRGBQUAD@@PEBN1HW4FillMode@2@@Z PROC ; graphics::GDI::BeginGradientFill

; 92   : void GDI::BeginGradientFill(const RGBQUAD* colors, const double* alphas, const double* ratios, int count, FillMode mode) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 93   :   ClearFill();

	mov	rcx, QWORD PTR this$[rsp]
	call	?ClearFill@GDI@graphics@@AEAAXXZ	; graphics::GDI::ClearFill

; 94   :   fill_.count = count;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR count$[rsp]
	mov	DWORD PTR [rax+184], ecx

; 95   :   for (int i = 0; i < fill_.count; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@BeginGradi
$LN2@BeginGradi:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@BeginGradi:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+184]
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN1@BeginGradi

; 96   :     fill_.colors[i].rgbRed   = colors[i].rgbRed;

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR colors$[rsp]
	movzx	eax, BYTE PTR [r8+rax*4+2]
	mov	BYTE PTR [rdx+rcx*4+106], al

; 97   :     fill_.colors[i].rgbGreen = colors[i].rgbGreen;

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR colors$[rsp]
	movzx	eax, BYTE PTR [r8+rax*4+1]
	mov	BYTE PTR [rdx+rcx*4+105], al

; 98   :     fill_.colors[i].rgbBlue  = colors[i].rgbBlue;

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR colors$[rsp]
	movzx	eax, BYTE PTR [r8+rax*4]
	mov	BYTE PTR [rdx+rcx*4+104], al

; 99   :     fill_.alphas[i] = alphas[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR alphas$[rsp]
	movsdx	xmm0, QWORD PTR [r8+rax*8]
	movsdx	QWORD PTR [rdx+rcx*8+120], xmm0

; 100  :     fill_.ratios[i] = ratios[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR ratios$[rsp]
	movsdx	xmm0, QWORD PTR [r8+rax*8]
	movsdx	QWORD PTR [rdx+rcx*8+152], xmm0

; 101  :   }

	jmp	$LN2@BeginGradi
$LN1@BeginGradi:

; 102  :   fill_.mode = mode;  

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR mode$[rsp]
	mov	DWORD PTR [rax+188], ecx

; 103  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?BeginGradientFill@GDI@graphics@@QEAAXPEBUtagRGBQUAD@@PEBN1HW4FillMode@2@@Z ENDP ; graphics::GDI::BeginGradientFill
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
this$ = 48
color$ = 56
alpha$ = 64
?BeginFill@GDI@graphics@@QEAAXUtagRGBQUAD@@N@Z PROC	; graphics::GDI::BeginFill

; 82   : void GDI::BeginFill(RGBQUAD color, double alpha) {

$LN3:
	movsdx	QWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 83   :   ClearFill();

	mov	rcx, QWORD PTR this$[rsp]
	call	?ClearFill@GDI@graphics@@AEAAXXZ	; graphics::GDI::ClearFill

; 84   :   fill_.count = 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+184], 1

; 85   :   fill_.colors[0].rgbRed = color.rgbRed;

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR color$[rsp+2]
	mov	BYTE PTR [rcx+rax+106], dl

; 86   :   fill_.colors[0].rgbGreen = color.rgbGreen;

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR color$[rsp+1]
	mov	BYTE PTR [rcx+rax+105], dl

; 87   :   fill_.colors[0].rgbBlue = color.rgbBlue;

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR color$[rsp]
	mov	BYTE PTR [rcx+rax+104], dl

; 88   :   fill_.alphas[0] = alpha;

	mov	eax, 8
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movsdx	xmm0, QWORD PTR alpha$[rsp]
	movsdx	QWORD PTR [rcx+rax+120], xmm0

; 89   :   fill_.mode = kSolid;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+188], 0

; 90   : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?BeginFill@GDI@graphics@@QEAAXUtagRGBQUAD@@N@Z ENDP	; graphics::GDI::BeginFill
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
this$ = 16
x$ = 24
y$ = 32
width$ = 40
height$ = 48
?SetClippingArea@GDI@graphics@@QEAAXHHHH@Z PROC		; graphics::GDI::SetClippingArea

; 75   : void GDI::SetClippingArea(int x, int y, int width, int height) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 76   :   clip_.x = x;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR x$[rsp]
	mov	DWORD PTR [rax+192], ecx

; 77   :   clip_.y = y;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR y$[rsp]
	mov	DWORD PTR [rax+196], ecx

; 78   :   clip_.width = width;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR width$[rsp]
	mov	DWORD PTR [rax+200], ecx

; 79   :   clip_.height = height;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR height$[rsp]
	mov	DWORD PTR [rax+204], ecx

; 80   : }

	pop	rdi
	ret	0
?SetClippingArea@GDI@graphics@@QEAAXHHHH@Z ENDP		; graphics::GDI::SetClippingArea
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
i$1 = 0
this$ = 32
color$ = 40
?Clear@GDI@graphics@@UEAAXUtagRGBQUAD@@@Z PROC		; graphics::GDI::Clear

; 67   : void GDI::Clear(RGBQUAD color) {

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 68   :   for (int i = 0; i < display_width_*display_height_; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@Clear
$LN2@Clear:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@Clear:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+16]
	imul	eax, DWORD PTR [rcx+20]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN1@Clear

; 69   :     back_buffer_[i].rgbRed   = color.rgbRed;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, BYTE PTR color$[rsp+2]
	mov	BYTE PTR [rcx+rax*4+2], dl

; 70   :     back_buffer_[i].rgbGreen = color.rgbGreen;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, BYTE PTR color$[rsp+1]
	mov	BYTE PTR [rcx+rax*4+1], dl

; 71   :     back_buffer_[i].rgbBlue  = color.rgbBlue;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	movzx	edx, BYTE PTR color$[rsp]
	mov	BYTE PTR [rcx+rax*4], dl

; 72   :   }

	jmp	SHORT $LN2@Clear
$LN1@Clear:

; 73   : }

	add	rsp, 16
	pop	rdi
	ret	0
?Clear@GDI@graphics@@UEAAXUtagRGBQUAD@@@Z ENDP		; graphics::GDI::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
this$ = 112
?Render@GDI@graphics@@UEAAXXZ PROC			; graphics::GDI::Render

; 57   : void GDI::Render() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+112]

; 58   :   //memset(back_buffer_,255,200*200*4);
; 59   :   //SetDIBits(dc,hbmp,0,200,back_buffer,&bitmap_info,DIB_RGB_COLORS);
; 60   :   //for (int i = 0; i < display_width_*display_height_; i++) {
; 61   :   //  frame_buffer_[i] = back_buffer_[i];
; 62   :   //}
; 63   :   memcpy(frame_buffer_,back_buffer_,display_width_*display_height_*sizeof(RGBQUAD));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+16]
	imul	eax, DWORD PTR [rcx+20]
	cdqe
	shl	rax, 2
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+88]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+96]
	call	memcpy

; 64   :   SetDIBitsToDevice(window_dc_,0,0,display_width_,display_height_,0,0,0,display_height_,frame_buffer_,&bitmap_info,DIB_RGB_COLORS);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	DWORD PTR [rsp+88], 0
	mov	QWORD PTR [rsp+80], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+96]
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+20]
	mov	DWORD PTR [rsp+64], eax
	mov	DWORD PTR [rsp+56], 0
	mov	DWORD PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+20]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR this$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	xor	r8d, r8d
	xor	edx, edx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	QWORD PTR __imp_SetDIBitsToDevice

; 65   : }

	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
?Render@GDI@graphics@@UEAAXXZ ENDP			; graphics::GDI::Render
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?Deinitialize@GDI@graphics@@QEAAXXZ PROC		; graphics::GDI::Deinitialize

; 50   : void GDI::Deinitialize() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 51   :   if (back_buffer_ != NULL)

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+88], 0
	je	SHORT $LN1@Deinitiali

; 52   :     delete [] back_buffer_;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN1@Deinitiali:

; 53   :   DeleteObject(hbmp);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+72]
	call	QWORD PTR __imp_DeleteObject

; 54   :   Graphics::Deinitialize();

	mov	rcx, QWORD PTR this$[rsp]
	call	?Deinitialize@Graphics@graphics@@QEAAXXZ ; graphics::Graphics::Deinitialize

; 55   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?Deinitialize@GDI@graphics@@QEAAXXZ ENDP		; graphics::GDI::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
$T1 = 48
tv157 = 56
this$ = 80
window_handle$ = 88
width$ = 96
height$ = 104
?Initialize@GDI@graphics@@QEAAXPEAUHWND__@@HH@Z PROC	; graphics::GDI::Initialize

; 29   : void GDI::Initialize(HWND window_handle,int width,int height) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 30   : 
; 31   :   Graphics::Initialize(window_handle,width,height);

	mov	r9d, DWORD PTR height$[rsp]
	mov	r8d, DWORD PTR width$[rsp]
	mov	rdx, QWORD PTR window_handle$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?Initialize@Graphics@graphics@@QEAAXPEAUHWND__@@HH@Z ; graphics::Graphics::Initialize

; 32   :   memset(&bitmap_info,0,sizeof(bitmap_info));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	r8d, 44					; 0000002cH
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 33   :   bitmap_info.bmiHeader.biBitCount = 32;

	mov	eax, 32					; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+38], ax

; 34   :   bitmap_info.bmiHeader.biPlanes = 1;

	mov	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+36], ax

; 35   :   bitmap_info.bmiHeader.biSize = sizeof(bitmap_info.bmiHeader);

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+24], 40			; 00000028H

; 36   :   bitmap_info.bmiHeader.biWidth = width;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR width$[rsp]
	mov	DWORD PTR [rax+28], ecx

; 37   :   bitmap_info.bmiHeader.biHeight = -height;

	mov	eax, DWORD PTR height$[rsp]
	neg	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 38   :   bitmap_info.bmiHeader.biSizeImage = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+44], 0

; 39   :   bitmap_info.bmiHeader.biCompression = BI_RGB;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+40], 0

; 40   : 
; 41   :   window_dc_ = GetDC(window_handle);//GetWindowDC(window_handle);//CreateCompatibleDC(GetDC(window_handle));

	mov	rcx, QWORD PTR window_handle$[rsp]
	call	QWORD PTR __imp_GetDC
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+80], rax

; 42   :   hbmp = CreateDIBSection(window_dc_,&bitmap_info,DIB_RGB_COLORS,reinterpret_cast<void**>(&frame_buffer_),NULL,0);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 96					; 00000060H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 24
	mov	DWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9, rax
	xor	r8d, r8d
	mov	rdx, rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+80]
	call	QWORD PTR __imp_CreateDIBSection
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+72], rax

; 43   :   
; 44   :   back_buffer_ = new RGBQUAD[display_width_*display_height_];

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+16]
	imul	eax, DWORD PTR [rcx+20]
	cdqe
	mov	QWORD PTR tv157[rsp], rax
	mov	eax, 4
	mov	rcx, QWORD PTR tv157[rsp]
	mul	rcx
	mov	rcx, -1
	cmovo	rax, rcx
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rax+88], rcx

; 45   :   // = CreateCompatibleBitmap(dc,200,200);
; 46   :   //SelectObject(dc,hbmp);
; 47   :   SetClippingArea(0,0,display_width_,display_height_);

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+20]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR this$[rsp]
	mov	r9d, DWORD PTR [rax+16]
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?SetClippingArea@GDI@graphics@@QEAAXHHHH@Z ; graphics::GDI::SetClippingArea

; 48   : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?Initialize@GDI@graphics@@QEAAXPEAUHWND__@@HH@Z ENDP	; graphics::GDI::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
this$ = 48
??1GDI@graphics@@UEAA@XZ PROC				; graphics::GDI::~GDI

; 25   : GDI::~GDI() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7GDI@graphics@@6B@
	mov	QWORD PTR [rax], rcx

; 26   : 
; 27   : }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1Graphics@graphics@@UEAA@XZ		; graphics::Graphics::~Graphics
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1GDI@graphics@@UEAA@XZ ENDP				; graphics::GDI::~GDI
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\gdi.cpp
_TEXT	SEGMENT
this$ = 48
??0GDI@graphics@@QEAA@XZ PROC				; graphics::GDI::GDI

; 16   : GDI::GDI() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0Graphics@graphics@@QEAA@XZ		; graphics::Graphics::Graphics
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7GDI@graphics@@6B@
	mov	QWORD PTR [rax], rcx

; 17   :   memset(&fill_,0,sizeof(fill_));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 104				; 00000068H
	mov	r8d, 88					; 00000058H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 18   :   back_buffer_ = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+88], 0

; 19   :   frame_buffer_ = NULL;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+96], 0

; 20   :   //int test[] = {1,4};
; 21   :   
; 22   :   //double r = interpolate_int_array(test,2,0);
; 23   : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0GDI@graphics@@QEAA@XZ ENDP				; graphics::GDI::GDI
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GGraphics@graphics@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GGraphics@graphics@@UEAAPEAXI@Z PROC			; graphics::Graphics::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]
	mov	rcx, QWORD PTR this$[rsp]
	call	??1Graphics@graphics@@UEAA@XZ		; graphics::Graphics::~Graphics
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN1@scalar
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX@Z				; operator delete
$LN1@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GGraphics@graphics@@UEAAPEAXI@Z ENDP			; graphics::Graphics::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\graphics.h
;	COMDAT ?Deinitialize@Graphics@graphics@@QEAAXXZ
_TEXT	SEGMENT
this$ = 16
?Deinitialize@Graphics@graphics@@QEAAXXZ PROC		; graphics::Graphics::Deinitialize, COMDAT

; 69   :   void Deinitialize() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 70   :   }

	pop	rdi
	ret	0
?Deinitialize@Graphics@graphics@@QEAAXXZ ENDP		; graphics::Graphics::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\graphics.h
;	COMDAT ?Initialize@Graphics@graphics@@QEAAXPEAUHWND__@@HH@Z
_TEXT	SEGMENT
this$ = 16
window_handle$ = 24
width$ = 32
height$ = 40
?Initialize@Graphics@graphics@@QEAAXPEAUHWND__@@HH@Z PROC ; graphics::Graphics::Initialize, COMDAT

; 64   :   void Initialize(HWND window_handle, int width, int height) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 65   :     window_handle_ = window_handle;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR window_handle$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 66   :     display_width_ = width;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR width$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 67   :     display_height_ = height;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR height$[rsp]
	mov	DWORD PTR [rax+20], ecx

; 68   :   }

	pop	rdi
	ret	0
?Initialize@Graphics@graphics@@QEAAXPEAUHWND__@@HH@Z ENDP ; graphics::Graphics::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\graphics.h
;	COMDAT ??1Graphics@graphics@@UEAA@XZ
_TEXT	SEGMENT
this$ = 16
??1Graphics@graphics@@UEAA@XZ PROC			; graphics::Graphics::~Graphics, COMDAT

; 63   :   virtual ~Graphics() {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7Graphics@graphics@@6B@
	mov	QWORD PTR [rax], rcx
	pop	rdi
	ret	0
??1Graphics@graphics@@UEAA@XZ ENDP			; graphics::Graphics::~Graphics
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\graphics.h
;	COMDAT ??0Graphics@graphics@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0Graphics@graphics@@QEAA@XZ PROC			; graphics::Graphics::Graphics, COMDAT

; 62   :   Graphics() {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7Graphics@graphics@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0Graphics@graphics@@QEAA@XZ ENDP			; graphics::Graphics::Graphics
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\graphics.h
;	COMDAT ?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z
_TEXT	SEGMENT
r$ = 36
a$ = 80
b$ = 88
s$ = 96
?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z PROC ; graphics::interpolate_color, COMDAT

; 52   : inline RGBQUAD interpolate_color(RGBQUAD a,RGBQUAD b,double s) {

$LN3:
	movsdx	QWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 53   :   RGBQUAD r;
; 54   :   r.rgbRed   = static_cast<BYTE>(interpolate_int(a.rgbRed,b.rgbRed,s));

	movzx	eax, BYTE PTR b$[rsp+2]
	movzx	ecx, BYTE PTR a$[rsp+2]
	movsdx	xmm2, QWORD PTR s$[rsp]
	mov	edx, eax
	call	?interpolate_int@graphics@@YANHHN@Z	; graphics::interpolate_int
	cvttsd2si rax, xmm0
	mov	BYTE PTR r$[rsp+2], al

; 55   :   r.rgbGreen = static_cast<BYTE>(interpolate_int(a.rgbGreen,b.rgbGreen,s));

	movzx	eax, BYTE PTR b$[rsp+1]
	movzx	ecx, BYTE PTR a$[rsp+1]
	movsdx	xmm2, QWORD PTR s$[rsp]
	mov	edx, eax
	call	?interpolate_int@graphics@@YANHHN@Z	; graphics::interpolate_int
	cvttsd2si rax, xmm0
	mov	BYTE PTR r$[rsp+1], al

; 56   :   r.rgbBlue  = static_cast<BYTE>(interpolate_int(a.rgbBlue,b.rgbBlue,s));

	movzx	eax, BYTE PTR b$[rsp]
	movzx	ecx, BYTE PTR a$[rsp]
	movsdx	xmm2, QWORD PTR s$[rsp]
	mov	edx, eax
	call	?interpolate_int@graphics@@YANHHN@Z	; graphics::interpolate_int
	cvttsd2si rax, xmm0
	mov	BYTE PTR r$[rsp], al

; 57   :   return r;

	mov	eax, DWORD PTR r$[rsp]

; 58   : }

	mov	edi, eax
	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?interpolate_color@graphics@@YA?AUtagRGBQUAD@@U2@0N@Z ENDP ; graphics::interpolate_color
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\graphics\graphics.h
;	COMDAT ?interpolate_int@graphics@@YANHHN@Z
_TEXT	SEGMENT
a$ = 32
b$ = 40
s$ = 48
?interpolate_int@graphics@@YANHHN@Z PROC		; graphics::interpolate_int, COMDAT

; 37   : inline double interpolate_int(int a,int b,double s) {

$LN3:
	movsdx	QWORD PTR [rsp+24], xmm2
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+32]

; 38   :   return a + s*(b-a);

	cvtsi2sd xmm0, DWORD PTR a$[rsp]
	mov	eax, DWORD PTR a$[rsp]
	mov	ecx, DWORD PTR b$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm1, eax
	movsdx	xmm2, QWORD PTR s$[rsp]
	mulsd	xmm2, xmm1
	movaps	xmm1, xmm2
	addsd	xmm0, xmm1

; 39   : }

	add	rsp, 16
	pop	rdi
	ret	0
?interpolate_int@graphics@@YANHHN@Z ENDP		; graphics::interpolate_int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = 0
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	add	rsp, 16
	pop	rdi
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = 0
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	add	rsp, 16
	pop	rdi
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
