; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?num@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::num
PUBLIC	?den@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::den
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_monotonic@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_monotonic
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?is_steady@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_steady
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	ConcRT_ProviderGuid
PUBLIC	ConcRTEventGuid
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	SchedulerEventGuid
PUBLIC	ScheduleGroupEventGuid
PUBLIC	ContextEventGuid
PUBLIC	ChoreEventGuid
PUBLIC	VirtualProcessorEventGuid
PUBLIC	LockEventGuid
PUBLIC	ResourceManagerEventGuid
PUBLIC	PPLParallelInvokeEventGuid
PUBLIC	PPLParallelForEventGuid
PUBLIC	PPLParallelForeachEventGuid
PUBLIC	AgentEventGuid
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?value@?$integral_constant@_K$0A@@std@@2_KB	; std::integral_constant<unsigned __int64,0>::value
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?value@?$integral_constant@H$0A@@std@@2HB	; std::integral_constant<int,0>::value
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?value@?$_Abs@$0GE@@std@@2_JB			; std::_Abs<100>::value
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?value@?$_Abs@$0DLJKMKAA@@std@@2_JB		; std::_Abs<1000000000>::value
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
PUBLIC	?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
PUBLIC	?value@?$_GcdX@$0GE@$0A@@std@@2_JB		; std::_GcdX<100,0>::value
PUBLIC	?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
PUBLIC	?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB	; std::_GcdX<1000000000,100>::value
PUBLIC	?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<100,1000000000>::value
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<100,1000000000>::value
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
PUBLIC	?value@?$_Abs@$00@std@@2_JB			; std::_Abs<1>::value
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_GcdX@$00$0A@@std@@2_JB		; std::_GcdX<1,0>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB		; std::_GcdX<10000000,1>::value
PUBLIC	?value@?$_GcdX@$00$00@std@@2_JB			; std::_GcdX<1,1>::value
PUBLIC	?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB		; std::_GcdX<1,10000000>::value
PUBLIC	?value@?$_Gcd@$00$00@std@@2_JB			; std::_Gcd<1,1>::value
PUBLIC	?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB		; std::_Gcd<1,10000000>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
PUBLIC	?num@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::num
PUBLIC	?den@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::den
PUBLIC	?is_monotonic@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_monotonic
PUBLIC	?is_steady@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_steady
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
PUBLIC	?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
PUBLIC	?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_nonNull
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelException
PUBLIC	?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_notInlined
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_structured
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_localCancel
PUBLIC	?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_reserved
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
PUBLIC	?value@?$_Abs@$0JIJGIA@@std@@2_JB		; std::_Abs<10000000>::value
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB		; std::_GcdX<10000000,0>::value
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_GcdX<10000000,10000000>::value
PUBLIC	?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Gcd<10000000,10000000>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0JIJGIA@@std@@2_JB DQ 0000000000989680H	; std::_Abs<10000000>::value
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_reserved
CONST	ENDS
;	COMDAT ?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_localCancel
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_structured
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB DD 0ffffffffH ; Concurrency::details::_TaskCollectionBase::_S_notInlined
CONST	ENDS
;	COMDAT ?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB DQ 000000000000000cH ; Concurrency::details::_TaskCollectionBase::_S_cancelException
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000008H ; Concurrency::details::_TaskCollectionBase::_S_nonNull
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000003H ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
CONST	ENDS
;	COMDAT ?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000002H ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000001H ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000000H ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
CONST	ENDS
;	COMDAT ?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000003H ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB DQ 0000000000000000H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_steady@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@system_clock@chrono@std@@2_NB DB 00H		; std::chrono::system_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@system_clock@chrono@std@@2_NB DB 00H	; std::chrono::system_clock::is_monotonic
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::ratio<1,10000000>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,10000000>::num
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000000,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0A@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?value@?$_Abs@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$00@std@@2_JB DQ 0000000000000001H	; std::_Abs<1>::value
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_Gcd<100,1000000000>::value
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<100,1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<1000000000,100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB DD 03H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
CONST	ENDS
;	COMDAT ?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 02H ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0A@@std@@2_JB DQ 0000000000000064H	; std::_GcdX<100,0>::value
CONST	ENDS
;	COMDAT ?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 01H ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
CONST	ENDS
;	COMDAT ?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB DD 00H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Abs<1000000000>::value
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0GE@@std@@2_JB DQ 0000000000000064H	; std::_Abs<100>::value
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@H$0A@@std@@2HB
CONST	SEGMENT
?value@?$integral_constant@H$0A@@std@@2HB DD 00H	; std::integral_constant<int,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_K$0A@@std@@2_KB
CONST	SEGMENT
?value@?$integral_constant@_K$0A@@std@@2_KB DQ 0000000000000000H ; std::integral_constant<unsigned __int64,0>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT AgentEventGuid
CONST	SEGMENT
AgentEventGuid DD 0b9b5b78cH
	DW	0713H
	DW	04898H
	DB	0a2H
	DB	01aH
	DB	0c6H
	DB	079H
	DB	049H
	DB	0dcH
	DB	0edH
	DB	07H
CONST	ENDS
;	COMDAT PPLParallelForeachEventGuid
CONST	SEGMENT
PPLParallelForeachEventGuid DD 05cb7d785H
	DW	09d66H
	DW	0465dH
	DB	0baH
	DB	0e1H
	DB	046H
	DB	011H
	DB	06H
	DB	01bH
	DB	054H
	DB	034H
CONST	ENDS
;	COMDAT PPLParallelForEventGuid
CONST	SEGMENT
PPLParallelForEventGuid DD 031c8da6bH
	DW	06165H
	DW	04042H
	DB	08bH
	DB	092H
	DB	094H
	DB	09eH
	DB	031H
	DB	05fH
	DB	04dH
	DB	084H
CONST	ENDS
;	COMDAT PPLParallelInvokeEventGuid
CONST	SEGMENT
PPLParallelInvokeEventGuid DD 0d1b5b133H
	DW	0ec3dH
	DW	049f4H
	DB	098H
	DB	0a3H
	DB	046H
	DB	04dH
	DB	01aH
	DB	09eH
	DB	046H
	DB	082H
CONST	ENDS
;	COMDAT ResourceManagerEventGuid
CONST	SEGMENT
ResourceManagerEventGuid DD 02718d25bH
	DW	05bf5H
	DW	04479H
	DB	08eH
	DB	088H
	DB	0baH
	DB	0bcH
	DB	064H
	DB	0bdH
	DB	0bfH
	DB	0caH
CONST	ENDS
;	COMDAT LockEventGuid
CONST	SEGMENT
LockEventGuid DD 079a60dc6H
	DW	05fc8H
	DW	04952H
	DB	0a4H
	DB	01cH
	DB	011H
	DB	063H
	DB	0aeH
	DB	0ecH
	DB	05eH
	DB	0b8H
CONST	ENDS
;	COMDAT VirtualProcessorEventGuid
CONST	SEGMENT
VirtualProcessorEventGuid DD 02f27805fH
	DW	01676H
	DW	04eccH
	DB	096H
	DB	0faH
	DB	07eH
	DB	0b0H
	DB	09dH
	DB	044H
	DB	030H
	DB	02fH
CONST	ENDS
;	COMDAT ChoreEventGuid
CONST	SEGMENT
ChoreEventGuid DD 07e854ec7H
	DW	0cdc4H
	DW	0405aH
	DB	0b5H
	DB	0b2H
	DB	0aaH
	DB	0f7H
	DB	0c9H
	DB	0e7H
	DB	0d4H
	DB	0cH
CONST	ENDS
;	COMDAT ContextEventGuid
CONST	SEGMENT
ContextEventGuid DD 05727a00fH
	DW	050beH
	DW	04519H
	DB	082H
	DB	056H
	DB	0f7H
	DB	069H
	DB	098H
	DB	071H
	DB	0feH
	DB	0cbH
CONST	ENDS
;	COMDAT ScheduleGroupEventGuid
CONST	SEGMENT
ScheduleGroupEventGuid DD 0e8a3bf1fH
	DW	0a86bH
	DW	04390H
	DB	09cH
	DB	060H
	DB	053H
	DB	090H
	DB	0b9H
	DB	069H
	DB	0d2H
	DB	02cH
CONST	ENDS
;	COMDAT SchedulerEventGuid
CONST	SEGMENT
SchedulerEventGuid DD 0e2091f8aH
	DW	01e0aH
	DW	04731H
	DB	084H
	DB	0a2H
	DB	0dH
	DB	0d5H
	DB	07cH
	DB	08aH
	DB	052H
	DB	061H
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ConcRTEventGuid
CONST	SEGMENT
ConcRTEventGuid DD 072b14a7dH
	DW	0704cH
	DW	0423eH
	DB	092H
	DB	0f8H
	DB	07eH
	DB	06dH
	DB	064H
	DB	0bcH
	DB	0b9H
	DB	02aH
CONST	ENDS
;	COMDAT ConcRT_ProviderGuid
CONST	SEGMENT
ConcRT_ProviderGuid DD 0f7b697a3H
	DW	04db5H
	DW	04d3bH
	DB	0beH
	DB	071H
	DB	0c4H
	DB	0d2H
	DB	084H
	DB	0e6H
	DB	059H
	DB	02fH
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_steady@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@steady_clock@chrono@std@@2_NB DB 01H		; std::chrono::steady_clock::is_steady
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?is_monotonic@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@steady_clock@chrono@std@@2_NB DB 01H	; std::chrono::steady_clock::is_monotonic
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB DQ 0000000000000001H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
CONST	SEGMENT
pal32	DD	0ffffffffH
	DD	0ffaaaaaaH
	DD	0ff545454H
	DD	0ff000000H
$SG113690 DB	'Code\emulation\gb\lcd_driver.cpp', 00H
	ORG $+7
$SG113693 DB	'Code\emulation\gb\lcd_driver.cpp', 00H
	ORG $+7
dutycycletable DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::num
CONST	ENDS
PUBLIC	??0_Ignore@std@@QEAA@XZ				; std::_Ignore::_Ignore
PUBLIC	?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z ; emulation::gb::Component::Initialize
PUBLIC	?vram@Memory@gb@emulation@@QEAAPEAEXZ		; emulation::gb::Memory::vram
PUBLIC	?oam@Memory@gb@emulation@@QEAAPEAEXZ		; emulation::gb::Memory::oam
PUBLIC	?ioports@Memory@gb@emulation@@QEAAPEAEXZ	; emulation::gb::Memory::ioports
PUBLIC	?interrupt_flag@Memory@gb@emulation@@QEAAAEAEXZ	; emulation::gb::Memory::interrupt_flag
PUBLIC	?Initialize@LCDDriver@gb@emulation@@UEAAXPEAVEmu@23@@Z ; emulation::gb::LCDDriver::Initialize
PUBLIC	?Deinitialize@LCDDriver@gb@emulation@@UEAAXXZ	; emulation::gb::LCDDriver::Deinitialize
PUBLIC	?Step@LCDDriver@gb@emulation@@QEAAXN@Z		; emulation::gb::LCDDriver::Step
PUBLIC	?Read@LCDDriver@gb@emulation@@QEAAEG@Z		; emulation::gb::LCDDriver::Read
PUBLIC	?Write@LCDDriver@gb@emulation@@QEAAXGE@Z	; emulation::gb::LCDDriver::Write
PUBLIC	?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z ; emulation::gb::LCDDriver::RenderBGLine
PUBLIC	?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z ; emulation::gb::LCDDriver::RenderWindowLine
PUBLIC	?RenderSpriteLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z ; emulation::gb::LCDDriver::RenderSpriteLine
PUBLIC	?RenderLine@LCDDriver@gb@emulation@@QEAAXXZ	; emulation::gb::LCDDriver::RenderLine
PUBLIC	?RenderAllBGTiles@LCDDriver@gb@emulation@@QEAAXXZ ; emulation::gb::LCDDriver::RenderAllBGTiles
PUBLIC	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ	; emulation::gb::Emu::memory
PUBLIC	??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QEBAXXZ ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
EXTRN	__imp_rand:PROC
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPEAX_KHPEBDH@Z:PROC			; operator new[]
EXTRN	__imp_?_Xbad_function_call@std@@YAXXZ:PROC
EXTRN	?Read8@Memory@gb@emulation@@QEAAEG@Z:PROC	; emulation::gb::Memory::Read8
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__ImageBase:BYTE
EXTRN	_fltused:DWORD
_BSS	SEGMENT
piecewise_construct DB 01H DUP (?)
allocator_arg DB 01H DUP (?)
ignore	DB	01H DUP (?)
_Tuple_alloc DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Epiecewise_construct@std@@YAXXZ DD imagerel ??__Epiecewise_construct@std@@YAXXZ
	DD	imagerel ??__Epiecewise_construct@std@@YAXXZ+43
	DD	imagerel $unwind$??__Epiecewise_construct@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eallocator_arg@std@@YAXXZ DD imagerel ??__Eallocator_arg@std@@YAXXZ
	DD	imagerel ??__Eallocator_arg@std@@YAXXZ+43
	DD	imagerel $unwind$??__Eallocator_arg@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Ignore@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+13
	DD	imagerel $unwind$??0_Ignore@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eignore@std@@YAXXZ DD imagerel ??__Eignore@std@@YAXXZ
	DD	imagerel ??__Eignore@std@@YAXXZ+39
	DD	imagerel $unwind$??__Eignore@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E_Tuple_alloc@std@@YAXXZ DD imagerel ??__E_Tuple_alloc@std@@YAXXZ
	DD	imagerel ??__E_Tuple_alloc@std@@YAXXZ+43
	DD	imagerel $unwind$??__E_Tuple_alloc@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?vram@Memory@gb@emulation@@QEAAPEAEXZ DD imagerel $LN3
	DD	imagerel $LN3+17
	DD	imagerel $unwind$?vram@Memory@gb@emulation@@QEAAPEAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?oam@Memory@gb@emulation@@QEAAPEAEXZ DD imagerel $LN3
	DD	imagerel $LN3+17
	DD	imagerel $unwind$?oam@Memory@gb@emulation@@QEAAPEAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ioports@Memory@gb@emulation@@QEAAPEAEXZ DD imagerel $LN3
	DD	imagerel $LN3+19
	DD	imagerel $unwind$?ioports@Memory@gb@emulation@@QEAAPEAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?interrupt_flag@Memory@gb@emulation@@QEAAAEAEXZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$?interrupt_flag@Memory@gb@emulation@@QEAAAEAEXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?Initialize@LCDDriver@gb@emulation@@UEAAXPEAVEmu@23@@Z DD imagerel $LN3
	DD	imagerel $LN3+283
	DD	imagerel $unwind$?Initialize@LCDDriver@gb@emulation@@UEAAXPEAVEmu@23@@Z
$pdata$?Deinitialize@LCDDriver@gb@emulation@@UEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$?Deinitialize@LCDDriver@gb@emulation@@UEAAXXZ
$pdata$?Step@LCDDriver@gb@emulation@@QEAAXN@Z DD imagerel $LN24
	DD	imagerel $LN24+1169
	DD	imagerel $unwind$?Step@LCDDriver@gb@emulation@@QEAAXN@Z
$pdata$?Read@LCDDriver@gb@emulation@@QEAAEG@Z DD imagerel $LN17
	DD	imagerel $LN17+264
	DD	imagerel $unwind$?Read@LCDDriver@gb@emulation@@QEAAEG@Z
$pdata$?Write@LCDDriver@gb@emulation@@QEAAXGE@Z DD imagerel $LN22
	DD	imagerel $LN22+920
	DD	imagerel $unwind$?Write@LCDDriver@gb@emulation@@QEAAXGE@Z
$pdata$?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z DD imagerel $LN13
	DD	imagerel $LN13+680
	DD	imagerel $unwind$?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z
$pdata$?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z DD imagerel $LN10
	DD	imagerel $LN10+694
	DD	imagerel $unwind$?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z
$pdata$?RenderSpriteLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z DD imagerel $LN19
	DD	imagerel $LN19+1016
	DD	imagerel $unwind$?RenderSpriteLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z
$pdata$?RenderLine@LCDDriver@gb@emulation@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+231
	DD	imagerel $unwind$?RenderLine@LCDDriver@gb@emulation@@QEAAXXZ
$pdata$?RenderAllBGTiles@LCDDriver@gb@emulation@@QEAAXXZ DD imagerel $LN14
	DD	imagerel $LN14+585
	DD	imagerel $unwind$?RenderAllBGTiles@LCDDriver@gb@emulation@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ DD imagerel $LN3
	DD	imagerel $LN3+19
	DD	imagerel $unwind$?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QEBAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$??0<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH@Z DD imagerel ??0<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH@Z
	DD	imagerel ??0<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH@Z+50
	DD	imagerel $unwind$??0<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH@Z
$pdata$??R<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEBAEXZ DD imagerel ??R<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEBAEXZ
	DD	imagerel ??R<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEBAEXZ+207
	DD	imagerel $unwind$??R<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEBAEXZ
$pdata$??0<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z DD imagerel ??0<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z
	DD	imagerel ??0<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z+69
	DD	imagerel $unwind$??0<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z
$pdata$??R<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEBAEXZ DD imagerel ??R<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEBAEXZ
	DD	imagerel ??R<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEBAEXZ+217
	DD	imagerel $unwind$??R<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEBAEXZ
$pdata$??0<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEAA@AEAH0@Z DD imagerel ??0<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEAA@AEAH0@Z
	DD	imagerel ??0<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEAA@AEAH0@Z+50
	DD	imagerel $unwind$??0<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEAA@AEAH0@Z
$pdata$??R<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEBAXXZ DD imagerel ??R<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEBAXXZ
	DD	imagerel ??R<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEBAXXZ+84
	DD	imagerel $unwind$??R<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEBAXXZ
$pdata$??0<lambda_77aa1e1620c765044c7d549251662d30>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z DD imagerel ??0<lambda_77aa1e1620c765044c7d549251662d30>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z
	DD	imagerel ??0<lambda_77aa1e1620c765044c7d549251662d30>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z+69
	DD	imagerel $unwind$??0<lambda_77aa1e1620c765044c7d549251662d30>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z
$pdata$??R<lambda_77aa1e1620c765044c7d549251662d30>@@QEBAEXZ DD imagerel ??R<lambda_77aa1e1620c765044c7d549251662d30>@@QEBAEXZ
	DD	imagerel ??R<lambda_77aa1e1620c765044c7d549251662d30>@@QEBAEXZ+217
	DD	imagerel $unwind$??R<lambda_77aa1e1620c765044c7d549251662d30>@@QEBAEXZ
$pdata$??0<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEAA@AEAH0@Z DD imagerel ??0<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEAA@AEAH0@Z
	DD	imagerel ??0<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEAA@AEAH0@Z+50
	DD	imagerel $unwind$??0<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEAA@AEAH0@Z
$pdata$??R<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEBAXXZ DD imagerel ??R<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEBAXXZ
	DD	imagerel ??R<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEBAXXZ+84
	DD	imagerel $unwind$??R<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEBAXXZ
pdata	ENDS
CRT$XCU	SEGMENT
piecewise_construct$initializer$ DQ FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QEBAXXZ DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ DD 010601H
	DD	07006H
xdata	ENDS
CONST	SEGMENT
?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$0 DB 06dH ; emulation::gb::LCDDriver::RenderBGLine
	DB	061H
	DB	070H
	DB	06fH
	DB	066H
	DB	066H
	DB	073H
	DB	065H
	DB	074H
	DB	00H
	ORG $+6
?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$1 DB 06cH ; emulation::gb::LCDDriver::RenderBGLine
	DB	069H
	DB	06eH
	DB	065H
	DB	06fH
	DB	066H
	DB	066H
	DB	073H
	DB	065H
	DB	074H
	DB	00H
	ORG $+1
?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$2 DB 078H ; emulation::gb::LCDDriver::RenderBGLine
	DB	00H
	ORG $+2
?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$3 DB 072H ; emulation::gb::LCDDriver::RenderBGLine
	DB	065H
	DB	061H
	DB	064H
	DB	054H
	DB	069H
	DB	06cH
	DB	065H
	DB	00H
	ORG $+3
?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$4 DB 069H ; emulation::gb::LCDDriver::RenderBGLine
	DB	06eH
	DB	063H
	DB	078H
	DB	00H
	ORG $+7
?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcFrameData DD 05H ; emulation::gb::LCDDriver::RenderBGLine
	DD	00H
	DQ	FLAT:?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcVarDesc
?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$2 DB 078H ; emulation::gb::LCDDriver::RenderWindowLine
	DB	00H
	ORG $+6
?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcVarDesc DD 0b8H ; emulation::gb::LCDDriver::RenderBGLine
	DD	010H
	DQ	FLAT:?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$4
	DD	088H
	DD	018H
	DQ	FLAT:?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$3
	DD	064H
	DD	04H
	DQ	FLAT:?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$2
	DD	044H
	DD	04H
	DQ	FLAT:?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$1
	DD	024H
	DD	04H
	DQ	FLAT:?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$0
	ORG $+240
?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$0 DB 06dH ; emulation::gb::LCDDriver::RenderWindowLine
	DB	061H
	DB	070H
	DB	06fH
	DB	066H
	DB	066H
	DB	073H
	DB	065H
	DB	074H
	DB	00H
	ORG $+6
?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$1 DB 06cH ; emulation::gb::LCDDriver::RenderWindowLine
	DB	069H
	DB	06eH
	DB	065H
	DB	06fH
	DB	066H
	DB	066H
	DB	073H
	DB	065H
	DB	074H
	DB	00H
	ORG $+5
?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$3 DB 072H ; emulation::gb::LCDDriver::RenderWindowLine
	DB	065H
	DB	061H
	DB	064H
	DB	054H
	DB	069H
	DB	06cH
	DB	065H
	DB	00H
	ORG $+3
?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$4 DB 069H ; emulation::gb::LCDDriver::RenderWindowLine
	DB	06eH
	DB	063H
	DB	078H
	DB	00H
	ORG $+7
?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcFrameData DD 05H ; emulation::gb::LCDDriver::RenderWindowLine
	DD	00H
	DQ	FLAT:?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcVarDesc
	ORG $+8
?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcVarDesc DD 0b8H ; emulation::gb::LCDDriver::RenderWindowLine
	DD	010H
	DQ	FLAT:?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$4
	DD	088H
	DD	018H
	DQ	FLAT:?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$3
	DD	064H
	DD	04H
	DQ	FLAT:?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$2
	DD	044H
	DD	04H
	DQ	FLAT:?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$1
	DD	024H
	DD	04H
	DQ	FLAT:?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcName$0
	ORG $+240
?RenderAllBGTiles@LCDDriver@gb@emulation@@QEAAXXZ$rtcName$0 DB 06dH ; emulation::gb::LCDDriver::RenderAllBGTiles
	DB	061H
	DB	070H
	DB	06fH
	DB	066H
	DB	066H
	DB	073H
	DB	065H
	DB	074H
	DB	00H
	ORG $+6
?RenderAllBGTiles@LCDDriver@gb@emulation@@QEAAXXZ$rtcName$1 DB 072H ; emulation::gb::LCDDriver::RenderAllBGTiles
	DB	065H
	DB	061H
	DB	064H
	DB	054H
	DB	069H
	DB	06cH
	DB	065H
	DB	00H
	ORG $+7
?RenderAllBGTiles@LCDDriver@gb@emulation@@QEAAXXZ$rtcVarDesc DD 048H ; emulation::gb::LCDDriver::RenderAllBGTiles
	DD	010H
	DQ	FLAT:?RenderAllBGTiles@LCDDriver@gb@emulation@@QEAAXXZ$rtcName$1
	DD	024H
	DD	04H
	DQ	FLAT:?RenderAllBGTiles@LCDDriver@gb@emulation@@QEAAXXZ$rtcName$0
	ORG $+96
?RenderAllBGTiles@LCDDriver@gb@emulation@@QEAAXXZ$rtcFrameData DD 02H ; emulation::gb::LCDDriver::RenderAllBGTiles
	DD	00H
	DQ	FLAT:?RenderAllBGTiles@LCDDriver@gb@emulation@@QEAAXXZ$rtcVarDesc
CONST	ENDS
xdata	SEGMENT
$unwind$?Initialize@LCDDriver@gb@emulation@@UEAAXPEAVEmu@23@@Z DD 022301H
	DD	0700b520fH
$unwind$?Deinitialize@LCDDriver@gb@emulation@@UEAAXXZ DD 021e01H
	DD	07006720aH
$unwind$?Step@LCDDriver@gb@emulation@@QEAAXN@Z DD 022701H
	DD	0700cd210H
$unwind$?Read@LCDDriver@gb@emulation@@QEAAEG@Z DD 022301H
	DD	0700b120fH
$unwind$?Write@LCDDriver@gb@emulation@@QEAAXGE@Z DD 022801H
	DD	070107214H
$unwind$?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z DD 032901H
	DD	0200112H
	DD	0700bH
$unwind$?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z DD 032901H
	DD	0200112H
	DD	0700bH
$unwind$?RenderSpriteLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z DD 032901H
	DD	0120112H
	DD	0700bH
$unwind$?RenderLine@LCDDriver@gb@emulation@@QEAAXXZ DD 021e01H
	DD	07006720aH
$unwind$?RenderAllBGTiles@LCDDriver@gb@emulation@@QEAAXXZ DD 032401H
	DD	012010dH
	DD	07006H
$unwind$??0<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH@Z DD 011001H
	DD	07010H
$unwind$??R<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEBAEXZ DD 021e01H
	DD	07006520aH
$unwind$??0<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z DD 011501H
	DD	07015H
$unwind$??R<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEBAEXZ DD 021e01H
	DD	07006520aH
$unwind$??0<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEAA@AEAH0@Z DD 011001H
	DD	07010H
$unwind$??R<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEBAXXZ DD 010601H
	DD	07006H
$unwind$??0<lambda_77aa1e1620c765044c7d549251662d30>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z DD 011501H
	DD	07015H
$unwind$??R<lambda_77aa1e1620c765044c7d549251662d30>@@QEBAEXZ DD 021e01H
	DD	07006520aH
$unwind$??0<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEAA@AEAH0@Z DD 011001H
	DD	07010H
$unwind$??R<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEBAXXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?interrupt_flag@Memory@gb@emulation@@QEAAAEAEXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ioports@Memory@gb@emulation@@QEAAPEAEXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?oam@Memory@gb@emulation@@QEAAPEAEXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?vram@Memory@gb@emulation@@QEAAPEAEXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E_Tuple_alloc@std@@YAXXZ DD 021501H
	DD	070021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eignore@std@@YAXXZ DD 021501H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Ignore@std@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eallocator_arg@std@@YAXXZ DD 021501H
	DD	070021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Epiecewise_construct@std@@YAXXZ DD 021501H
	DD	070021206H
xdata	ENDS
CRT$XCU	SEGMENT
allocator_arg$initializer$ DQ FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
ignore$initializer$ DQ FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_Tuple_alloc$initializer$ DQ FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
this$ = 16
??R<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEBAXXZ PROC ; <lambda_31c40d55d0841a42578b633b3d1ebf53>::operator()

; 277  :     auto incx = [&x,&lineoffset](){

	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 278  : 			  ++x;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	DWORD PTR [rcx], eax

; 279  : 			  if (x==8) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	DWORD PTR [rax], 8
	jne	SHORT $LN1@operator

; 280  : 				  x = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	DWORD PTR [rax], 0

; 281  : 				  lineoffset = (lineoffset+1)&0x1F;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	inc	eax
	and	eax, 31
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	DWORD PTR [rcx], eax
$LN1@operator:

; 282  :         }
; 283  :     };

	pop	rdi
	ret	0
??R<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEBAXXZ ENDP ; <lambda_31c40d55d0841a42578b633b3d1ebf53>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
this$ = 16
_X$ = 24
_Lineoffset$ = 32
??0<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEAA@AEAH0@Z PROC ; <lambda_31c40d55d0841a42578b633b3d1ebf53>::<lambda_31c40d55d0841a42578b633b3d1ebf53>

; 283  :     };

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _X$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Lineoffset$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEAA@AEAH0@Z ENDP ; <lambda_31c40d55d0841a42578b633b3d1ebf53>::<lambda_31c40d55d0841a42578b633b3d1ebf53>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tilemap$ = 32
tileindex$ = 40
d$1 = 41
tv82 = 44
this$ = 64
??R<lambda_77aa1e1620c765044c7d549251662d30>@@QEBAEXZ PROC ; <lambda_77aa1e1620c765044c7d549251662d30>::operator()

; 266  : 	  auto readTile = [&](){

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 267  :         uint8_t* tilemap = &emu_->memory()->vram()[lcdc_.window_tile_map ==0?0x1800:0x1C00];

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@operator
	mov	DWORD PTR tv82[rsp], 6144		; 00001800H
	jmp	SHORT $LN5@operator
$LN4@operator:
	mov	DWORD PTR tv82[rsp], 7168		; 00001c00H
$LN5@operator:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?vram@Memory@gb@emulation@@QEAAPEAEXZ	; emulation::gb::Memory::vram
	movsxd	rcx, DWORD PTR tv82[rsp]
	add	rax, rcx
	mov	QWORD PTR tilemap$[rsp], rax

; 268  : 			  auto tileindex = tilemap[(mapoffset<<5) + lineoffset];

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	shl	eax, 5
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	add	eax, DWORD PTR [rcx]
	cdqe
	mov	rcx, QWORD PTR tilemap$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR tileindex$[rsp], al

; 269  : 			  if(lcdc_.tile_data == 0) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@operator

; 270  : 				  int8_t d = tileindex;

	movzx	eax, BYTE PTR tileindex$[rsp]
	mov	BYTE PTR d$1[rsp], al

; 271  : 				  d+=128;

	movsx	eax, BYTE PTR d$1[rsp]
	add	eax, 128				; 00000080H
	mov	BYTE PTR d$1[rsp], al

; 272  : 				  tileindex = d;

	movzx	eax, BYTE PTR d$1[rsp]
	mov	BYTE PTR tileindex$[rsp], al
$LN1@operator:

; 273  : 			  }
; 274  : 			  return tileindex;

	movzx	eax, BYTE PTR tileindex$[rsp]

; 275  : 	  };

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??R<lambda_77aa1e1620c765044c7d549251662d30>@@QEBAEXZ ENDP ; <lambda_77aa1e1620c765044c7d549251662d30>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
this$ = 16
_This$ = 24
_Mapoffset$ = 32
_Lineoffset$ = 40
??0<lambda_77aa1e1620c765044c7d549251662d30>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z PROC ; <lambda_77aa1e1620c765044c7d549251662d30>::<lambda_77aa1e1620c765044c7d549251662d30>

; 275  : 	  };

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _This$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Mapoffset$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Lineoffset$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0<lambda_77aa1e1620c765044c7d549251662d30>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z ENDP ; <lambda_77aa1e1620c765044c7d549251662d30>::<lambda_77aa1e1620c765044c7d549251662d30>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
this$ = 16
??R<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEBAXXZ PROC ; <lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>::operator()

; 236  :   auto incx = [&x,&lineoffset](){

	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 237  : 			++x;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	DWORD PTR [rcx], eax

; 238  : 			if (x==8) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	DWORD PTR [rax], 8
	jne	SHORT $LN1@operator

; 239  : 				x = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	DWORD PTR [rax], 0

; 240  : 				lineoffset = (lineoffset+1)&0x1F;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	inc	eax
	and	eax, 31
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	DWORD PTR [rcx], eax
$LN1@operator:

; 241  :       }
; 242  :   };

	pop	rdi
	ret	0
??R<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEBAXXZ ENDP ; <lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
this$ = 16
_X$ = 24
_Lineoffset$ = 32
??0<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEAA@AEAH0@Z PROC ; <lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>::<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>

; 242  :   };

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _X$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Lineoffset$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEAA@AEAH0@Z ENDP ; <lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>::<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
bgtilemap$ = 32
tileindex$ = 40
d$1 = 41
tv82 = 44
this$ = 64
??R<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEBAEXZ PROC ; <lambda_27169eba417b74b6e822a35df0b2f15d>::operator()

; 225  : 	auto readTile = [&](){

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 226  : 		  uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@operator
	mov	DWORD PTR tv82[rsp], 6144		; 00001800H
	jmp	SHORT $LN5@operator
$LN4@operator:
	mov	DWORD PTR tv82[rsp], 7168		; 00001c00H
$LN5@operator:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?vram@Memory@gb@emulation@@QEAAPEAEXZ	; emulation::gb::Memory::vram
	movsxd	rcx, DWORD PTR tv82[rsp]
	add	rax, rcx
	mov	QWORD PTR bgtilemap$[rsp], rax

; 227  : 			auto tileindex = bgtilemap[(mapoffset<<5) + lineoffset];

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	shl	eax, 5
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	add	eax, DWORD PTR [rcx]
	cdqe
	mov	rcx, QWORD PTR bgtilemap$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR tileindex$[rsp], al

; 228  : 			if(lcdc_.tile_data == 0) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@operator

; 229  : 				int8_t d = tileindex;

	movzx	eax, BYTE PTR tileindex$[rsp]
	mov	BYTE PTR d$1[rsp], al

; 230  : 				d+=128;

	movsx	eax, BYTE PTR d$1[rsp]
	add	eax, 128				; 00000080H
	mov	BYTE PTR d$1[rsp], al

; 231  : 				tileindex = d;

	movzx	eax, BYTE PTR d$1[rsp]
	mov	BYTE PTR tileindex$[rsp], al
$LN1@operator:

; 232  : 			}
; 233  : 			return tileindex;

	movzx	eax, BYTE PTR tileindex$[rsp]

; 234  : 	};

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??R<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEBAEXZ ENDP ; <lambda_27169eba417b74b6e822a35df0b2f15d>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
this$ = 16
_This$ = 24
_Mapoffset$ = 32
_Lineoffset$ = 40
??0<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z PROC ; <lambda_27169eba417b74b6e822a35df0b2f15d>::<lambda_27169eba417b74b6e822a35df0b2f15d>

; 234  : 	};

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _This$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Mapoffset$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Lineoffset$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z ENDP ; <lambda_27169eba417b74b6e822a35df0b2f15d>::<lambda_27169eba417b74b6e822a35df0b2f15d>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
bgtilemap$ = 32
tileindex$ = 40
d$1 = 41
tv82 = 44
this$ = 64
??R<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEBAEXZ PROC ; <lambda_ac85dfe7c377970f7a45c79eb78810d6>::operator()

; 189  : 	auto readTile = [&](){

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 190  : 			uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@operator
	mov	DWORD PTR tv82[rsp], 6144		; 00001800H
	jmp	SHORT $LN5@operator
$LN4@operator:
	mov	DWORD PTR tv82[rsp], 7168		; 00001c00H
$LN5@operator:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?vram@Memory@gb@emulation@@QEAAPEAEXZ	; emulation::gb::Memory::vram
	movsxd	rcx, DWORD PTR tv82[rsp]
	add	rax, rcx
	mov	QWORD PTR bgtilemap$[rsp], rax

; 191  : 			auto tileindex = bgtilemap[(mapoffset<<5)];

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	shl	eax, 5
	cdqe
	mov	rcx, QWORD PTR bgtilemap$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR tileindex$[rsp], al

; 192  : 			if(lcdc_.tile_data == 1) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN1@operator

; 193  : 				int8_t d = tileindex;

	movzx	eax, BYTE PTR tileindex$[rsp]
	mov	BYTE PTR d$1[rsp], al

; 194  : 				d+=128;

	movsx	eax, BYTE PTR d$1[rsp]
	add	eax, 128				; 00000080H
	mov	BYTE PTR d$1[rsp], al

; 195  : 				tileindex = d;

	movzx	eax, BYTE PTR d$1[rsp]
	mov	BYTE PTR tileindex$[rsp], al
$LN1@operator:

; 196  : 			}
; 197  : 			return tileindex;

	movzx	eax, BYTE PTR tileindex$[rsp]

; 198  : 	};

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??R<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEBAEXZ ENDP ; <lambda_ac85dfe7c377970f7a45c79eb78810d6>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
this$ = 16
_This$ = 24
_Mapoffset$ = 32
??0<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH@Z PROC ; <lambda_ac85dfe7c377970f7a45c79eb78810d6>::<lambda_ac85dfe7c377970f7a45c79eb78810d6>

; 198  : 	};

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _This$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Mapoffset$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH@Z ENDP ; <lambda_ac85dfe7c377970f7a45c79eb78810d6>::<lambda_ac85dfe7c377970f7a45c79eb78810d6>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QEBAXXZ
_TEXT	SEGMENT
this$ = 48
??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QEBAXXZ PROC ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator(), COMDAT

; 514  : _VARIADIC_EXPAND_P1_0(_CLASS_FUNC_CLASS_0, , , , )

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN1@operator
	call	QWORD PTR __imp_?_Xbad_function_call@std@@YAXXZ
$LN1@operator:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax]
	call	QWORD PTR [rax+16]
$LN3@operator:
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QEBAXXZ ENDP ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\emu.h
;	COMDAT ?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ
_TEXT	SEGMENT
this$ = 16
?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ PROC	; emulation::gb::Emu::memory, COMDAT

; 21   :   Memory* memory() { return &memory_; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 2232				; 000008b8H
	pop	rdi
	ret	0
?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ENDP	; emulation::gb::Emu::memory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
mapoffset$ = 36
y$ = 52
x$ = 56
readTile$ = 72
i$5 = 100
tiledata$6 = 104
i$7 = 112
tileindex$8 = 116
tile$9 = 120
tv138 = 128
tv178 = 132
this$ = 160
?RenderAllBGTiles@LCDDriver@gb@emulation@@QEAAXXZ PROC	; emulation::gb::LCDDriver::RenderAllBGTiles

; 185  : void LCDDriver::RenderAllBGTiles() {

$LN14:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 144				; 00000090H
	mov	rdi, rsp
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+160]

; 186  : 	auto mapoffset = ((ly)&0xFF) >> 3;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	and	eax, 255				; 000000ffH
	sar	eax, 3
	mov	DWORD PTR mapoffset$[rsp], eax

; 187  : 	auto y = (ly) & 7;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	and	eax, 7
	mov	DWORD PTR y$[rsp], eax

; 188  : 	auto x = 0;

	mov	DWORD PTR x$[rsp], 0

; 189  : 	auto readTile = [&](){
; 190  : 			uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];
; 191  : 			auto tileindex = bgtilemap[(mapoffset<<5)];
; 192  : 			if(lcdc_.tile_data == 1) {
; 193  : 				int8_t d = tileindex;
; 194  : 				d+=128;
; 195  : 				tileindex = d;
; 196  : 			}
; 197  : 			return tileindex;
; 198  : 	};

	lea	r8, QWORD PTR mapoffset$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR readTile$[rsp]
	call	??0<lambda_ac85dfe7c377970f7a45c79eb78810d6>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH@Z ; <lambda_ac85dfe7c377970f7a45c79eb78810d6>::<lambda_ac85dfe7c377970f7a45c79eb78810d6>

; 199  : 
; 200  : 	if (lcdc_.bgdisplay == 0) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN9@RenderAllB

; 201  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR i$5[rsp], 0
	jmp	SHORT $LN8@RenderAllB
$LN7@RenderAllB:
	mov	eax, DWORD PTR i$5[rsp]
	inc	eax
	mov	DWORD PTR i$5[rsp], eax
$LN8@RenderAllB:
	cmp	DWORD PTR i$5[rsp], 256			; 00000100H
	jge	SHORT $LN6@RenderAllB

; 202  : 			colormap[((ly)<<8)+(i)] = 0;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shl	eax, 8
	add	eax, DWORD PTR i$5[rsp]
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+32]
	mov	BYTE PTR [rcx+rax], 0

; 203  : 		}

	jmp	SHORT $LN7@RenderAllB
$LN6@RenderAllB:
	jmp	$LN5@RenderAllB
$LN9@RenderAllB:

; 204  : 	} else {
; 205  : 		uint8_t* tiledata = &emu_->memory()->vram()[lcdc_.tile_data ==0?0x0800:0x0000];

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@RenderAllB
	mov	DWORD PTR tv138[rsp], 2048		; 00000800H
	jmp	SHORT $LN13@RenderAllB
$LN12@RenderAllB:
	mov	DWORD PTR tv138[rsp], 0
$LN13@RenderAllB:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?vram@Memory@gb@emulation@@QEAAPEAEXZ	; emulation::gb::Memory::vram
	movsxd	rcx, DWORD PTR tv138[rsp]
	add	rax, rcx
	mov	QWORD PTR tiledata$6[rsp], rax

; 206  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR i$7[rsp], 0
	jmp	SHORT $LN4@RenderAllB
$LN3@RenderAllB:
	mov	eax, DWORD PTR i$7[rsp]
	inc	eax
	mov	DWORD PTR i$7[rsp], eax
$LN4@RenderAllB:
	cmp	DWORD PTR i$7[rsp], 256			; 00000100H
	jge	$LN2@RenderAllB

; 207  : 			auto tileindex = (i>>3)+(ly>>3)*32;

	mov	eax, DWORD PTR i$7[rsp]
	sar	eax, 3
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+44]
	sar	ecx, 3
	imul	ecx, 32					; 00000020H
	add	eax, ecx
	mov	DWORD PTR tileindex$8[rsp], eax

; 208  : 			uint8_t* tile = &tiledata[(tileindex<<4)];

	mov	eax, DWORD PTR tileindex$8[rsp]
	shl	eax, 4
	cdqe
	mov	rcx, QWORD PTR tiledata$6[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tile$9[rsp], rax

; 209  : 			
; 210  : 			colormap[((ly)<<8)+i] = bg_pal[pixel((7-x))];

	mov	eax, DWORD PTR y$[rsp]
	add	eax, eax
	cdqe
	mov	rcx, QWORD PTR tile$9[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 7
	sub	ecx, DWORD PTR x$[rsp]
	and	ecx, 7
	sar	eax, cl
	and	eax, 1
	mov	ecx, DWORD PTR y$[rsp]
	lea	ecx, DWORD PTR [rcx+rcx+1]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR tile$9[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	DWORD PTR tv178[rsp], ecx
	mov	edx, 7
	sub	edx, DWORD PTR x$[rsp]
	and	edx, 7
	movzx	ecx, dl
	mov	edx, DWORD PTR tv178[rsp]
	sar	edx, cl
	mov	ecx, edx
	shl	ecx, 1
	and	ecx, 2
	add	eax, ecx
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+44]
	shl	ecx, 8
	add	ecx, DWORD PTR i$7[rsp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+32]
	mov	r8, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [r8+rax+48]
	mov	BYTE PTR [rdx+rcx], al

; 211  : 
; 212  : 			++x;

	mov	eax, DWORD PTR x$[rsp]
	inc	eax
	mov	DWORD PTR x$[rsp], eax

; 213  : 			if (x==8) {

	cmp	DWORD PTR x$[rsp], 8
	jne	SHORT $LN1@RenderAllB

; 214  : 				x = 0;

	mov	DWORD PTR x$[rsp], 0
$LN1@RenderAllB:

; 215  : 			}
; 216  : 		}

	jmp	$LN3@RenderAllB
$LN2@RenderAllB:
$LN5@RenderAllB:

; 217  : 	}
; 218  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:?RenderAllBGTiles@LCDDriver@gb@emulation@@QEAAXXZ$rtcFrameData
	call	_RTC_CheckStackVars
	add	rsp, 144				; 00000090H
	pop	rdi
	ret	0
?RenderAllBGTiles@LCDDriver@gb@emulation@@QEAAXXZ ENDP	; emulation::gb::LCDDriver::RenderAllBGTiles
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
cmline$ = 32
fbline$ = 40
i$1 = 48
this$ = 80
?RenderLine@LCDDriver@gb@emulation@@QEAAXXZ PROC	; emulation::gb::LCDDriver::RenderLine

; 359  : void LCDDriver::RenderLine() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 360  : 	auto cmline = &colormap[ly<<8];

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shl	eax, 8
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+32]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cmline$[rsp], rax

; 361  : 
; 362  : 	//RenderAllBGTiles();
; 363  : 	RenderBGLine(cmline);

	mov	rdx, QWORD PTR cmline$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z ; emulation::gb::LCDDriver::RenderBGLine

; 364  : 	RenderWindowLine(cmline);

	mov	rdx, QWORD PTR cmline$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z ; emulation::gb::LCDDriver::RenderWindowLine

; 365  : 	RenderSpriteLine(cmline);

	mov	rdx, QWORD PTR cmline$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?RenderSpriteLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z ; emulation::gb::LCDDriver::RenderSpriteLine

; 366  : 
; 367  : 	auto fbline = &frame_buffer[ly<<8];

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	shl	eax, 8
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	lea	rax, QWORD PTR [rcx+rax*4]
	mov	QWORD PTR fbline$[rsp], rax

; 368  :   for (int i=0;i<256;++i) //256px per line

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@RenderLine
$LN2@RenderLine:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@RenderLine:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN1@RenderLine

; 369  :    *fbline++ = pal32[*cmline++];

	mov	rax, QWORD PTR cmline$[rsp]
	movzx	eax, BYTE PTR [rax]
	lea	rcx, OFFSET FLAT:pal32
	mov	rdx, QWORD PTR fbline$[rsp]
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR [rdx], eax
	mov	rax, QWORD PTR fbline$[rsp]
	add	rax, 4
	mov	QWORD PTR fbline$[rsp], rax
	mov	rax, QWORD PTR cmline$[rsp]
	inc	rax
	mov	QWORD PTR cmline$[rsp], rax
	jmp	SHORT $LN2@RenderLine
$LN1@RenderLine:

; 370  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?RenderLine@LCDDriver@gb@emulation@@QEAAXXZ ENDP	; emulation::gb::LCDDriver::RenderLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
sprite_count$ = 32
tiledata$1 = 40
sprites$2 = 48
j$3 = 56
spritey$4 = 60
spritex$5 = 64
tile$6 = 72
y$7 = 80
pal$8 = 88
x$9 = 96
p$10 = 100
tv144 = 104
tv195 = 112
tv366 = 120
tv240 = 124
tv263 = 128
this$ = 160
cmline$ = 168
?RenderSpriteLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z PROC ; emulation::gb::LCDDriver::RenderSpriteLine

; 298  : void LCDDriver::RenderSpriteLine(uint8_t* cmline) {

$LN19:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 144				; 00000090H
	mov	rdi, rsp
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+160]

; 299  :   uint8_t sprite_count = 10;

	mov	BYTE PTR sprite_count$[rsp], 10

; 300  :   struct Sprite{
; 301  :     uint8_t y,x,tileindex;
; 302  : 
; 303  :     union {
; 304  :       struct {
; 305  :         uint8_t unused:4;
; 306  :         uint8_t pal:1;
; 307  :         uint8_t xflip:1;
; 308  :         uint8_t yflip:1;
; 309  :         uint8_t priority:1;
; 310  :         /* Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
; 311  :          (Used for both BG and Window. BG color 0 is always behind OBJ)
; 312  :   Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
; 313  :   Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
; 314  :   Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
; 315  :   Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
; 316  :   Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)
; 317  : */
; 318  :       };
; 319  :       uint8_t raw;
; 320  :     }attr;
; 321  : 
; 322  :   } ;
; 323  : 	if (lcdc_.sprite_enable == 1) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN14@RenderSpri

; 324  : 		uint8_t* tiledata = &emu_->memory()->vram()[0x0000];

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?vram@Memory@gb@emulation@@QEAAPEAEXZ	; emulation::gb::Memory::vram
	mov	ecx, 1
	imul	rcx, 0
	add	rax, rcx
	mov	QWORD PTR tiledata$1[rsp], rax

; 325  :     Sprite* sprites = (Sprite*)emu_->memory()->oam();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?oam@Memory@gb@emulation@@QEAAPEAEXZ	; emulation::gb::Memory::oam
	mov	QWORD PTR sprites$2[rsp], rax

; 326  : 
; 327  :     for (int j=0;j<40;++j) {

	mov	DWORD PTR j$3[rsp], 0
	jmp	SHORT $LN13@RenderSpri
$LN12@RenderSpri:
	mov	eax, DWORD PTR j$3[rsp]
	inc	eax
	mov	DWORD PTR j$3[rsp], eax
$LN13@RenderSpri:
	cmp	DWORD PTR j$3[rsp], 40			; 00000028H
	jge	$LN11@RenderSpri

; 328  :        int16_t spritey = sprites[j].y-16;

	movsxd	rax, DWORD PTR j$3[rsp]
	mov	rcx, QWORD PTR sprites$2[rsp]
	movzx	eax, BYTE PTR [rcx+rax*4]
	sub	eax, 16
	mov	WORD PTR spritey$4[rsp], ax

; 329  :        int16_t spritex = sprites[j].x-8;

	movsxd	rax, DWORD PTR j$3[rsp]
	mov	rcx, QWORD PTR sprites$2[rsp]
	movzx	eax, BYTE PTR [rcx+rax*4+1]
	sub	eax, 8
	mov	WORD PTR spritex$5[rsp], ax

; 330  :        if ( ly >= (spritey) && ly < (spritey+(8<<lcdc_.sprite_size))) { //same line

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	movsx	ecx, WORD PTR spritey$4[rsp]
	cmp	eax, ecx
	jl	$LN10@RenderSpri
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	movsx	ecx, WORD PTR spritey$4[rsp]
	mov	DWORD PTR tv144[rsp], ecx
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+40]
	shr	dl, 2
	and	dl, 1
	movzx	edx, dl
	mov	r8d, 8
	movzx	ecx, dl
	mov	edx, r8d
	shl	edx, cl
	mov	ecx, edx
	mov	edx, DWORD PTR tv144[rsp]
	add	edx, ecx
	mov	ecx, edx
	cmp	eax, ecx
	jge	$LN10@RenderSpri

; 331  :          if (lcdc_.sprite_size)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@RenderSpri

; 332  :            sprites[j].tileindex &= ~0x01;

	movsxd	rax, DWORD PTR j$3[rsp]
	mov	rcx, QWORD PTR sprites$2[rsp]
	movzx	eax, BYTE PTR [rcx+rax*4+2]
	and	eax, -2
	movsxd	rcx, DWORD PTR j$3[rsp]
	mov	rdx, QWORD PTR sprites$2[rsp]
	mov	BYTE PTR [rdx+rcx*4+2], al
$LN9@RenderSpri:

; 333  :           uint8_t* tile = &tiledata[(sprites[j].tileindex<<4)];

	movsxd	rax, DWORD PTR j$3[rsp]
	mov	rcx, QWORD PTR sprites$2[rsp]
	movzx	eax, BYTE PTR [rcx+rax*4+2]
	shl	eax, 4
	cdqe
	mov	rcx, QWORD PTR tiledata$1[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tile$6[rsp], rax

; 334  :           uint8_t y = ly-spritey;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	movsx	ecx, WORD PTR spritey$4[rsp]
	sub	eax, ecx
	mov	BYTE PTR y$7[rsp], al

; 335  :           uint8_t* pal = sprites[j].attr.pal == 0?obj_pal1:obj_pal2;

	movsxd	rax, DWORD PTR j$3[rsp]
	mov	rcx, QWORD PTR sprites$2[rsp]
	movzx	eax, BYTE PTR [rcx+rax*4+3]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN17@RenderSpri
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 52					; 00000034H
	mov	QWORD PTR tv195[rsp], rax
	jmp	SHORT $LN18@RenderSpri
$LN17@RenderSpri:
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR tv195[rsp], rax
$LN18@RenderSpri:
	mov	rax, QWORD PTR tv195[rsp]
	mov	QWORD PTR pal$8[rsp], rax

; 336  :           if (sprites[j].attr.yflip)

	movsxd	rax, DWORD PTR j$3[rsp]
	mov	rcx, QWORD PTR sprites$2[rsp]
	movzx	eax, BYTE PTR [rcx+rax*4+3]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@RenderSpri

; 337  :             y = ((8<<lcdc_.sprite_size)) - y;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	mov	ecx, 8
	mov	DWORD PTR tv366[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv366[rsp]
	shl	eax, cl
	movzx	ecx, BYTE PTR y$7[rsp]
	sub	eax, ecx
	mov	BYTE PTR y$7[rsp], al
$LN8@RenderSpri:

; 338  : 			     
; 339  : 			    for (int x=0;x<8;++x) {

	mov	DWORD PTR x$9[rsp], 0
	jmp	SHORT $LN7@RenderSpri
$LN6@RenderSpri:
	mov	eax, DWORD PTR x$9[rsp]
	inc	eax
	mov	DWORD PTR x$9[rsp], eax
$LN7@RenderSpri:
	cmp	DWORD PTR x$9[rsp], 8
	jge	$LN5@RenderSpri

; 340  :             uint8_t p = 0;

	mov	BYTE PTR p$10[rsp], 0

; 341  :             if (sprites[j].attr.xflip) {

	movsxd	rax, DWORD PTR j$3[rsp]
	mov	rcx, QWORD PTR sprites$2[rsp]
	movzx	eax, BYTE PTR [rcx+rax*4+3]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@RenderSpri

; 342  :               p = pixel((x));

	movzx	eax, BYTE PTR y$7[rsp]
	shl	eax, 1
	cdqe
	mov	rcx, QWORD PTR tile$6[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR x$9[rsp]
	and	ecx, 7
	sar	eax, cl
	and	eax, 1
	movzx	ecx, BYTE PTR y$7[rsp]
	lea	ecx, DWORD PTR [rcx+rcx+1]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR tile$6[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	DWORD PTR tv240[rsp], ecx
	mov	edx, DWORD PTR x$9[rsp]
	and	edx, 7
	movzx	ecx, dl
	mov	edx, DWORD PTR tv240[rsp]
	sar	edx, cl
	mov	ecx, edx
	shl	ecx, 1
	and	ecx, 2
	add	eax, ecx
	mov	BYTE PTR p$10[rsp], al

; 343  :             } else {

	jmp	SHORT $LN3@RenderSpri
$LN4@RenderSpri:

; 344  :               p = pixel((7-x));

	movzx	eax, BYTE PTR y$7[rsp]
	shl	eax, 1
	cdqe
	mov	rcx, QWORD PTR tile$6[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 7
	sub	ecx, DWORD PTR x$9[rsp]
	and	ecx, 7
	sar	eax, cl
	and	eax, 1
	movzx	ecx, BYTE PTR y$7[rsp]
	lea	ecx, DWORD PTR [rcx+rcx+1]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR tile$6[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	DWORD PTR tv263[rsp], ecx
	mov	edx, 7
	sub	edx, DWORD PTR x$9[rsp]
	and	edx, 7
	movzx	ecx, dl
	mov	edx, DWORD PTR tv263[rsp]
	sar	edx, cl
	mov	ecx, edx
	shl	ecx, 1
	and	ecx, 2
	add	eax, ecx
	mov	BYTE PTR p$10[rsp], al
$LN3@RenderSpri:

; 345  :             }
; 346  :             
; 347  :             if (((p!=0)&&((sprites[j].attr.priority==0)||(cmline[x+spritex] == bg_pal[0])))&&
; 348  : 							(x+spritex)>=0)

	movzx	eax, BYTE PTR p$10[rsp]
	test	eax, eax
	je	$LN2@RenderSpri
	movsxd	rax, DWORD PTR j$3[rsp]
	mov	rcx, QWORD PTR sprites$2[rsp]
	movzx	eax, BYTE PTR [rcx+rax*4+3]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@RenderSpri
	movsx	eax, WORD PTR spritex$5[rsp]
	mov	ecx, DWORD PTR x$9[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	mov	rcx, QWORD PTR cmline$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 1
	imul	rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx+48]
	cmp	eax, ecx
	jne	SHORT $LN2@RenderSpri
$LN1@RenderSpri:
	movsx	eax, WORD PTR spritex$5[rsp]
	mov	ecx, DWORD PTR x$9[rsp]
	add	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jl	SHORT $LN2@RenderSpri

; 349  :               cmline[x+spritex] = pal[p];

	movzx	eax, BYTE PTR p$10[rsp]
	movsx	ecx, WORD PTR spritex$5[rsp]
	mov	edx, DWORD PTR x$9[rsp]
	add	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cmline$[rsp]
	mov	r8, QWORD PTR pal$8[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
$LN2@RenderSpri:

; 350  :           }

	jmp	$LN6@RenderSpri
$LN5@RenderSpri:

; 351  : 
; 352  : 			  --sprite_count;

	movzx	eax, BYTE PTR sprite_count$[rsp]
	dec	al
	mov	BYTE PTR sprite_count$[rsp], al
$LN10@RenderSpri:

; 353  :        }
; 354  :      }

	jmp	$LN12@RenderSpri
$LN11@RenderSpri:
$LN14@RenderSpri:

; 355  : 
; 356  : 	}
; 357  : }

	add	rsp, 144				; 00000090H
	pop	rdi
	ret	0
?RenderSpriteLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z ENDP ; emulation::gb::LCDDriver::RenderSpriteLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
mapoffset$8 = 36
lineoffset$9 = 68
y$10 = 84
x$11 = 100
readTile$12 = 136
incx$13 = 184
tiledata$14 = 216
i$15 = 224
tileindex$16 = 228
tile$17 = 232
bgcolor$18 = 240
tv149 = 244
tv184 = 248
this$ = 272
cmline$ = 280
?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z PROC ; emulation::gb::LCDDriver::RenderWindowLine

; 260  : void LCDDriver::RenderWindowLine(uint8_t* cmline) {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 256				; 00000100H
	mov	rdi, rsp
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+272]

; 261  : 	if (lcdc_.window_enable == 1) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN5@RenderWind

; 262  :     auto mapoffset = ((ly-wy)&0xFF) >> 3;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	sub	eax, ecx
	and	eax, 255				; 000000ffH
	sar	eax, 3
	mov	DWORD PTR mapoffset$8[rsp], eax

; 263  : 	  auto lineoffset = 0;

	mov	DWORD PTR lineoffset$9[rsp], 0

; 264  : 	  auto y = (ly-wy) & 7;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	sub	eax, ecx
	and	eax, 7
	mov	DWORD PTR y$10[rsp], eax

; 265  : 	  auto x = 0;

	mov	DWORD PTR x$11[rsp], 0

; 266  : 	  auto readTile = [&](){
; 267  :         uint8_t* tilemap = &emu_->memory()->vram()[lcdc_.window_tile_map ==0?0x1800:0x1C00];
; 268  : 			  auto tileindex = tilemap[(mapoffset<<5) + lineoffset];
; 269  : 			  if(lcdc_.tile_data == 0) {
; 270  : 				  int8_t d = tileindex;
; 271  : 				  d+=128;
; 272  : 				  tileindex = d;
; 273  : 			  }
; 274  : 			  return tileindex;
; 275  : 	  };

	lea	r9, QWORD PTR lineoffset$9[rsp]
	lea	r8, QWORD PTR mapoffset$8[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR readTile$12[rsp]
	call	??0<lambda_77aa1e1620c765044c7d549251662d30>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z ; <lambda_77aa1e1620c765044c7d549251662d30>::<lambda_77aa1e1620c765044c7d549251662d30>

; 276  : 
; 277  :     auto incx = [&x,&lineoffset](){
; 278  : 			  ++x;
; 279  : 			  if (x==8) {
; 280  : 				  x = 0;
; 281  : 				  lineoffset = (lineoffset+1)&0x1F;
; 282  :         }
; 283  :     };

	lea	r8, QWORD PTR lineoffset$9[rsp]
	lea	rdx, QWORD PTR x$11[rsp]
	lea	rcx, QWORD PTR incx$13[rsp]
	call	??0<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEAA@AEAH0@Z ; <lambda_31c40d55d0841a42578b633b3d1ebf53>::<lambda_31c40d55d0841a42578b633b3d1ebf53>

; 284  : 
; 285  :     if ((ly >= wy)&&(wx>=7&&wx<=166)) { 

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+47]
	cmp	eax, ecx
	jl	$LN4@RenderWind
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	cmp	eax, 7
	jl	$LN4@RenderWind
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	cmp	eax, 166				; 000000a6H
	jg	$LN4@RenderWind

; 286  : 		  uint8_t* tiledata = &emu_->memory()->vram()[lcdc_.tile_data ==0?0x0800:0x0000];

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@RenderWind
	mov	DWORD PTR tv149[rsp], 2048		; 00000800H
	jmp	SHORT $LN9@RenderWind
$LN8@RenderWind:
	mov	DWORD PTR tv149[rsp], 0
$LN9@RenderWind:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?vram@Memory@gb@emulation@@QEAAPEAEXZ	; emulation::gb::Memory::vram
	movsxd	rcx, DWORD PTR tv149[rsp]
	add	rax, rcx
	mov	QWORD PTR tiledata$14[rsp], rax

; 287  : 		  for (int i=(wx-7);i<=(wx-7)+166-7;++i) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	sub	eax, 7
	mov	DWORD PTR i$15[rsp], eax
	jmp	SHORT $LN3@RenderWind
$LN2@RenderWind:
	mov	eax, DWORD PTR i$15[rsp]
	inc	eax
	mov	DWORD PTR i$15[rsp], eax
$LN3@RenderWind:
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	add	eax, 152				; 00000098H
	cmp	DWORD PTR i$15[rsp], eax
	jg	$LN1@RenderWind

; 288  : 			  auto tileindex = readTile();

	lea	rcx, QWORD PTR readTile$12[rsp]
	call	??R<lambda_77aa1e1620c765044c7d549251662d30>@@QEBAEXZ ; <lambda_77aa1e1620c765044c7d549251662d30>::operator()
	mov	BYTE PTR tileindex$16[rsp], al

; 289  : 			  uint8_t* tile = &tiledata[(tileindex<<4)];

	movzx	eax, BYTE PTR tileindex$16[rsp]
	shl	eax, 4
	cdqe
	mov	rcx, QWORD PTR tiledata$14[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tile$17[rsp], rax

; 290  :         uint8_t bgcolor = pixel((7-x));

	mov	eax, DWORD PTR y$10[rsp]
	add	eax, eax
	cdqe
	mov	rcx, QWORD PTR tile$17[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 7
	sub	ecx, DWORD PTR x$11[rsp]
	and	ecx, 7
	sar	eax, cl
	and	eax, 1
	mov	ecx, DWORD PTR y$10[rsp]
	lea	ecx, DWORD PTR [rcx+rcx+1]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR tile$17[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	DWORD PTR tv184[rsp], ecx
	mov	edx, 7
	sub	edx, DWORD PTR x$11[rsp]
	and	edx, 7
	movzx	ecx, dl
	mov	edx, DWORD PTR tv184[rsp]
	sar	edx, cl
	mov	ecx, edx
	shl	ecx, 1
	and	ecx, 2
	add	eax, ecx
	mov	BYTE PTR bgcolor$18[rsp], al

; 291  :         incx();

	lea	rcx, QWORD PTR incx$13[rsp]
	call	??R<lambda_31c40d55d0841a42578b633b3d1ebf53>@@QEBAXXZ ; <lambda_31c40d55d0841a42578b633b3d1ebf53>::operator()

; 292  :         cmline[i] = bg_pal[bgcolor];

	movzx	eax, BYTE PTR bgcolor$18[rsp]
	movsxd	rcx, DWORD PTR i$15[rsp]
	mov	rdx, QWORD PTR cmline$[rsp]
	mov	r8, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [r8+rax+48]
	mov	BYTE PTR [rdx+rcx], al

; 293  : 		  }

	jmp	$LN2@RenderWind
$LN1@RenderWind:
$LN4@RenderWind:
$LN5@RenderWind:

; 294  :     }
; 295  : 	}
; 296  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcFrameData
	call	_RTC_CheckStackVars
	add	rsp, 256				; 00000100H
	pop	rdi
	ret	0
?RenderWindowLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z ENDP ; emulation::gb::LCDDriver::RenderWindowLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
mapoffset$ = 36
lineoffset$ = 68
y$ = 84
x$ = 100
readTile$ = 136
incx$ = 184
i$8 = 212
tiledata$9 = 216
i$10 = 224
tileindex$11 = 228
tile$12 = 232
bgcolor$13 = 240
tv149 = 244
tv176 = 248
this$ = 272
cmline$ = 280
?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z PROC	; emulation::gb::LCDDriver::RenderBGLine

; 220  : void LCDDriver::RenderBGLine(uint8_t* cmline) {

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 256				; 00000100H
	mov	rdi, rsp
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+272]

; 221  : 	auto mapoffset = ((ly+scroll_y)&0xFF) >> 3;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+43]
	add	eax, ecx
	and	eax, 255				; 000000ffH
	sar	eax, 3
	mov	DWORD PTR mapoffset$[rsp], eax

; 222  : 	auto lineoffset = ((scroll_x>>3))&0x1F;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+42]
	sar	eax, 3
	and	eax, 31
	mov	DWORD PTR lineoffset$[rsp], eax

; 223  : 	auto y = (ly + scroll_y) & 7;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+43]
	add	eax, ecx
	and	eax, 7
	mov	DWORD PTR y$[rsp], eax

; 224  : 	auto x = scroll_x & 7;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+42]
	and	eax, 7
	mov	DWORD PTR x$[rsp], eax

; 225  : 	auto readTile = [&](){
; 226  : 		  uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];
; 227  : 			auto tileindex = bgtilemap[(mapoffset<<5) + lineoffset];
; 228  : 			if(lcdc_.tile_data == 0) {
; 229  : 				int8_t d = tileindex;
; 230  : 				d+=128;
; 231  : 				tileindex = d;
; 232  : 			}
; 233  : 			return tileindex;
; 234  : 	};

	lea	r9, QWORD PTR lineoffset$[rsp]
	lea	r8, QWORD PTR mapoffset$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR readTile$[rsp]
	call	??0<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEAA@PEAVLCDDriver@gb@emulation@@AEAH1@Z ; <lambda_27169eba417b74b6e822a35df0b2f15d>::<lambda_27169eba417b74b6e822a35df0b2f15d>

; 235  : 
; 236  :   auto incx = [&x,&lineoffset](){
; 237  : 			++x;
; 238  : 			if (x==8) {
; 239  : 				x = 0;
; 240  : 				lineoffset = (lineoffset+1)&0x1F;
; 241  :       }
; 242  :   };

	lea	r8, QWORD PTR lineoffset$[rsp]
	lea	rdx, QWORD PTR x$[rsp]
	lea	rcx, QWORD PTR incx$[rsp]
	call	??0<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEAA@AEAH0@Z ; <lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>::<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>

; 243  : 
; 244  : 	if (lcdc_.bgdisplay == 0) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@RenderBGLi

; 245  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR i$8[rsp], 0
	jmp	SHORT $LN7@RenderBGLi
$LN6@RenderBGLi:
	mov	eax, DWORD PTR i$8[rsp]
	inc	eax
	mov	DWORD PTR i$8[rsp], eax
$LN7@RenderBGLi:
	cmp	DWORD PTR i$8[rsp], 256			; 00000100H
	jge	SHORT $LN5@RenderBGLi

; 246  : 			cmline[i] = 0;

	movsxd	rax, DWORD PTR i$8[rsp]
	mov	rcx, QWORD PTR cmline$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 247  : 		}

	jmp	SHORT $LN6@RenderBGLi
$LN5@RenderBGLi:
	jmp	$LN4@RenderBGLi
$LN8@RenderBGLi:

; 248  : 	} else {
; 249  : 		uint8_t* tiledata = &emu_->memory()->vram()[lcdc_.tile_data ==0?0x0800:0x0000];

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@RenderBGLi
	mov	DWORD PTR tv149[rsp], 2048		; 00000800H
	jmp	SHORT $LN12@RenderBGLi
$LN11@RenderBGLi:
	mov	DWORD PTR tv149[rsp], 0
$LN12@RenderBGLi:
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?vram@Memory@gb@emulation@@QEAAPEAEXZ	; emulation::gb::Memory::vram
	movsxd	rcx, DWORD PTR tv149[rsp]
	add	rax, rcx
	mov	QWORD PTR tiledata$9[rsp], rax

; 250  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR i$10[rsp], 0
	jmp	SHORT $LN3@RenderBGLi
$LN2@RenderBGLi:
	mov	eax, DWORD PTR i$10[rsp]
	inc	eax
	mov	DWORD PTR i$10[rsp], eax
$LN3@RenderBGLi:
	cmp	DWORD PTR i$10[rsp], 256		; 00000100H
	jge	$LN1@RenderBGLi

; 251  : 			auto tileindex = readTile();

	lea	rcx, QWORD PTR readTile$[rsp]
	call	??R<lambda_27169eba417b74b6e822a35df0b2f15d>@@QEBAEXZ ; <lambda_27169eba417b74b6e822a35df0b2f15d>::operator()
	mov	BYTE PTR tileindex$11[rsp], al

; 252  : 			uint8_t* tile = &tiledata[(tileindex<<4)];

	movzx	eax, BYTE PTR tileindex$11[rsp]
	shl	eax, 4
	cdqe
	mov	rcx, QWORD PTR tiledata$9[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tile$12[rsp], rax

; 253  :       uint8_t bgcolor = pixel((7-x));

	mov	eax, DWORD PTR y$[rsp]
	add	eax, eax
	cdqe
	mov	rcx, QWORD PTR tile$12[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	ecx, 7
	sub	ecx, DWORD PTR x$[rsp]
	and	ecx, 7
	sar	eax, cl
	and	eax, 1
	mov	ecx, DWORD PTR y$[rsp]
	lea	ecx, DWORD PTR [rcx+rcx+1]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR tile$12[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	mov	DWORD PTR tv176[rsp], ecx
	mov	edx, 7
	sub	edx, DWORD PTR x$[rsp]
	and	edx, 7
	movzx	ecx, dl
	mov	edx, DWORD PTR tv176[rsp]
	sar	edx, cl
	mov	ecx, edx
	shl	ecx, 1
	and	ecx, 2
	add	eax, ecx
	mov	BYTE PTR bgcolor$13[rsp], al

; 254  :       incx();

	lea	rcx, QWORD PTR incx$[rsp]
	call	??R<lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>@@QEBAXXZ ; <lambda_7e23d3a5b8f364cdf1888ecea8b00ffd>::operator()

; 255  :       cmline[i] = bg_pal[bgcolor];

	movzx	eax, BYTE PTR bgcolor$13[rsp]
	movsxd	rcx, DWORD PTR i$10[rsp]
	mov	rdx, QWORD PTR cmline$[rsp]
	mov	r8, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [r8+rax+48]
	mov	BYTE PTR [rdx+rcx], al

; 256  : 		}

	jmp	$LN2@RenderBGLi
$LN1@RenderBGLi:
$LN4@RenderBGLi:

; 257  : 	}
; 258  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z$rtcFrameData
	call	_RTC_CheckStackVars
	add	rsp, 256				; 00000100H
	pop	rdi
	ret	0
?RenderBGLine@LCDDriver@gb@emulation@@QEAAXPEAE@Z ENDP	; emulation::gb::LCDDriver::RenderBGLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
srcaddr$1 = 32
dest$2 = 40
i$3 = 48
tv65 = 52
tv154 = 56
this$ = 80
address$ = 88
data$ = 96
?Write@LCDDriver@gb@emulation@@QEAAXGE@Z PROC		; emulation::gb::LCDDriver::Write

; 119  : void LCDDriver::Write(uint16_t address, uint8_t data) {

$LN22:
	mov	BYTE PTR [rsp+24], r8b
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 120  :   switch (address) {

	movzx	eax, WORD PTR address$[rsp]
	mov	DWORD PTR tv65[rsp], eax
	mov	eax, DWORD PTR tv65[rsp]
	sub	eax, 65344				; 0000ff40H
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 11
	ja	$LN17@Write
	movsxd	rax, DWORD PTR tv65[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN21@Write[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN16@Write:

; 121  :     case 0xFF40:
; 122  :       lcdc_.raw = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+40], cl

; 123  :       if (lcdc_.lcd_enable) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@Write

; 124  :         counter1 = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+64], 0

; 125  :         counter2 = 4;//4-7 work

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+72], 4

; 126  :         ly = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+44], 0

; 127  :         stat_.mode = 2;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	and	al, 252					; 000000fcH
	or	al, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+41], al
$LN15@Write:

; 128  :       }
; 129  :       break;

	jmp	$LN17@Write
$LN14@Write:

; 130  :     case 0xFF41:
; 131  :       stat_.raw = (data & ~0x7) | (stat_.raw&0x7);

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, -8
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+41]
	and	ecx, 7
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+41], al

; 132  :       break;

	jmp	$LN17@Write
$LN13@Write:

; 133  :     case 0xFF42:
; 134  :       scroll_y = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+43], cl

; 135  :       break;

	jmp	$LN17@Write
$LN12@Write:

; 136  :     case 0xFF43:
; 137  :       scroll_x = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+42], cl

; 138  :       break;

	jmp	$LN17@Write

; 139  :       break;

	jmp	$LN17@Write
$LN11@Write:

; 140  :     case 0xFF44:
; 141  :       ly = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+44], 0

; 142  :       break;

	jmp	$LN17@Write
$LN10@Write:

; 143  :     case 0xFF45:
; 144  :       lyc = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+45], cl

; 145  :       break;

	jmp	$LN17@Write
$LN9@Write:

; 146  :     case 0xFF46: {
; 147  :       uint16_t srcaddr = data<<8;

	movzx	eax, BYTE PTR data$[rsp]
	shl	eax, 8
	mov	WORD PTR srcaddr$1[rsp], ax

; 148  :       auto dest = emu_->memory()->oam();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?oam@Memory@gb@emulation@@QEAAPEAEXZ	; emulation::gb::Memory::oam
	mov	QWORD PTR dest$2[rsp], rax

; 149  :       for (int i=0;i<160;++i)

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN8@Write
$LN7@Write:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN8@Write:
	cmp	DWORD PTR i$3[rsp], 160			; 000000a0H
	jge	SHORT $LN6@Write

; 150  :         *dest++ = emu_->memory()->Read8(srcaddr++);

	movzx	eax, WORD PTR srcaddr$1[rsp]
	mov	WORD PTR tv154[rsp], ax
	movzx	eax, WORD PTR srcaddr$1[rsp]
	inc	ax
	mov	WORD PTR srcaddr$1[rsp], ax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	movzx	edx, WORD PTR tv154[rsp]
	mov	rcx, rax
	call	?Read8@Memory@gb@emulation@@QEAAEG@Z	; emulation::gb::Memory::Read8
	mov	rcx, QWORD PTR dest$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR dest$2[rsp]
	inc	rax
	mov	QWORD PTR dest$2[rsp], rax
	jmp	SHORT $LN7@Write
$LN6@Write:

; 151  :       break;

	jmp	$LN17@Write
$LN5@Write:

; 152  :     }
; 153  :     case 0xFF47:
; 154  :       bg_pallete_data = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+60], cl

; 155  :       bg_pal[0] = data&0x3;

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, 3
	mov	ecx, 1
	imul	rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+48], al

; 156  :       bg_pal[1] = (data>>2)&0x3;

	movzx	eax, BYTE PTR data$[rsp]
	sar	eax, 2
	and	eax, 3
	mov	ecx, 1
	imul	rcx, 1
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+48], al

; 157  :       bg_pal[2] = (data>>4)&0x3;

	movzx	eax, BYTE PTR data$[rsp]
	sar	eax, 4
	and	eax, 3
	mov	ecx, 1
	imul	rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+48], al

; 158  :       bg_pal[3] = (data>>6)&0x3;

	movzx	eax, BYTE PTR data$[rsp]
	sar	eax, 6
	and	eax, 3
	mov	ecx, 1
	imul	rcx, 3
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+48], al

; 159  :       break;

	jmp	$LN17@Write
$LN4@Write:

; 160  :     case 0xFF48:
; 161  :       obj_pallete1_data = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+61], cl

; 162  :       obj_pal1[0] = data&0x3;

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, 3
	mov	ecx, 1
	imul	rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+52], al

; 163  :       obj_pal1[1] = (data>>2)&0x3;

	movzx	eax, BYTE PTR data$[rsp]
	sar	eax, 2
	and	eax, 3
	mov	ecx, 1
	imul	rcx, 1
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+52], al

; 164  :       obj_pal1[2] = (data>>4)&0x3;

	movzx	eax, BYTE PTR data$[rsp]
	sar	eax, 4
	and	eax, 3
	mov	ecx, 1
	imul	rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+52], al

; 165  :       obj_pal1[3] = (data>>6)&0x3;

	movzx	eax, BYTE PTR data$[rsp]
	sar	eax, 6
	and	eax, 3
	mov	ecx, 1
	imul	rcx, 3
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+52], al

; 166  :       break;

	jmp	$LN17@Write
$LN3@Write:

; 167  :     case 0xFF49:
; 168  :       obj_pallete2_data = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+62], cl

; 169  :       obj_pal2[0] = data&0x3;

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, 3
	mov	ecx, 1
	imul	rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+56], al

; 170  :       obj_pal2[1] = (data>>2)&0x3;

	movzx	eax, BYTE PTR data$[rsp]
	sar	eax, 2
	and	eax, 3
	mov	ecx, 1
	imul	rcx, 1
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+56], al

; 171  :       obj_pal2[2] = (data>>4)&0x3;

	movzx	eax, BYTE PTR data$[rsp]
	sar	eax, 4
	and	eax, 3
	mov	ecx, 1
	imul	rcx, 2
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+56], al

; 172  :       obj_pal2[3] = (data>>6)&0x3;

	movzx	eax, BYTE PTR data$[rsp]
	sar	eax, 6
	and	eax, 3
	mov	ecx, 1
	imul	rcx, 3
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+56], al

; 173  :       break;

	jmp	SHORT $LN17@Write
$LN2@Write:

; 174  :     case 0xFF4A:
; 175  :       wy = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+47], cl

; 176  :       break;

	jmp	SHORT $LN17@Write
$LN1@Write:

; 177  :     case 0xFF4B:
; 178  :       wx = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+46], cl
$LN17@Write:

; 179  :       break;
; 180  :   }
; 181  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
	npad	1
$LN21@Write:
	DD	$LN16@Write
	DD	$LN14@Write
	DD	$LN13@Write
	DD	$LN12@Write
	DD	$LN11@Write
	DD	$LN10@Write
	DD	$LN9@Write
	DD	$LN5@Write
	DD	$LN4@Write
	DD	$LN3@Write
	DD	$LN2@Write
	DD	$LN1@Write
?Write@LCDDriver@gb@emulation@@QEAAXGE@Z ENDP		; emulation::gb::LCDDriver::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv65 = 0
this$ = 32
address$ = 40
?Read@LCDDriver@gb@emulation@@QEAAEG@Z PROC		; emulation::gb::LCDDriver::Read

; 90   : uint8_t LCDDriver::Read(uint16_t address) {

$LN17:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 91   : 
; 92   :   switch (address) {

	movzx	eax, WORD PTR address$[rsp]
	mov	DWORD PTR tv65[rsp], eax
	mov	eax, DWORD PTR tv65[rsp]
	sub	eax, 65344				; 0000ff40H
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 11
	ja	$LN12@Read
	movsxd	rax, DWORD PTR tv65[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN16@Read[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN11@Read:

; 93   :     case 0xFF40:
; 94   :       return lcdc_.raw;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	jmp	SHORT $LN14@Read
$LN10@Read:

; 95   :     case 0xFF41:
; 96   :       return stat_.raw;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	jmp	SHORT $LN14@Read
$LN9@Read:

; 97   :     case 0xFF42:
; 98   :       return scroll_y;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+43]
	jmp	SHORT $LN14@Read
$LN8@Read:

; 99   :     case 0xFF43:
; 100  :       return scroll_x;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+42]
	jmp	SHORT $LN14@Read
$LN7@Read:

; 101  :     case 0xFF44:
; 102  :       return ly;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	jmp	SHORT $LN14@Read
$LN6@Read:

; 103  :     case 0xFF45:
; 104  :       return lyc;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+45]
	jmp	SHORT $LN14@Read
$LN5@Read:

; 105  :     case 0xFF47:
; 106  :       return bg_pallete_data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+60]
	jmp	SHORT $LN14@Read
$LN4@Read:

; 107  :     case 0xFF48:
; 108  :       return obj_pallete1_data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+61]
	jmp	SHORT $LN14@Read
$LN3@Read:

; 109  :     case 0xFF49:
; 110  :       return obj_pallete2_data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+62]
	jmp	SHORT $LN14@Read
$LN2@Read:

; 111  :     case 0xFF4A:
; 112  :       return wy;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+47]
	jmp	SHORT $LN14@Read
$LN1@Read:

; 113  :     case 0xFF4B:
; 114  :       return wx;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+46]
	jmp	SHORT $LN14@Read
$LN12@Read:

; 115  :   }
; 116  : 	return 0;

	xor	al, al
$LN14@Read:

; 117  : }

	add	rsp, 16
	pop	rdi
	ret	0
$LN16@Read:
	DD	$LN11@Read
	DD	$LN10@Read
	DD	$LN9@Read
	DD	$LN8@Read
	DD	$LN7@Read
	DD	$LN6@Read
	DD	$LN12@Read
	DD	$LN5@Read
	DD	$LN4@Read
	DD	$LN3@Read
	DD	$LN2@Read
	DD	$LN1@Read
?Read@LCDDriver@gb@emulation@@QEAAEG@Z ENDP		; emulation::gb::LCDDriver::Read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv74 = 32
tv90 = 40
tv166 = 48
tv158 = 56
tv186 = 64
tv222 = 72
tv235 = 80
tv253 = 88
tv254 = 92
tv286 = 96
tv314 = 104
this$ = 128
dt$ = 136
?Step@LCDDriver@gb@emulation@@QEAAXN@Z PROC		; emulation::gb::LCDDriver::Step

; 31   : void LCDDriver::Step(double dt) {

$LN24:
	movsdx	QWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rdi, rsp
	mov	ecx, 28
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+128]

; 32   :   ++counter2; //line clock

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+72], rax

; 33   :   ++counter1;//screen clock

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+64]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+64], rax

; 34   : 
; 35   : 
; 36   : 	switch (stat_.mode) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	and	al, 3
	mov	BYTE PTR tv74[rsp], al
	cmp	BYTE PTR tv74[rsp], 0
	je	$LN10@Step
	cmp	BYTE PTR tv74[rsp], 1
	je	$LN5@Step
	cmp	BYTE PTR tv74[rsp], 2
	je	SHORT $LN15@Step
	cmp	BYTE PTR tv74[rsp], 3
	je	SHORT $LN12@Step
	jmp	$LN16@Step
$LN15@Step:

; 37   : 		case 2:
; 38   :       if (stat_.oam_int)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@Step

; 39   :         emu_->memory()->interrupt_flag() |= 2;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?interrupt_flag@Memory@gb@emulation@@QEAAAEAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	QWORD PTR tv90[rsp], rax
	mov	rax, QWORD PTR tv90[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 2
	mov	rcx, QWORD PTR tv90[rsp]
	mov	BYTE PTR [rcx], al
$LN14@Step:

; 40   : 			if (counter2==80)

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+72], 80			; 00000050H
	jne	SHORT $LN13@Step

; 41   : 				stat_.mode = 3;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	or	al, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+41], al
$LN13@Step:

; 42   : 			break;

	jmp	$LN16@Step
$LN12@Step:

; 43   : 		case 3:
; 44   : 		  if (counter2 == 282) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+72], 282			; 0000011aH
	jne	SHORT $LN11@Step

; 45   : 	  		RenderLine();

	mov	rcx, QWORD PTR this$[rsp]
	call	?RenderLine@LCDDriver@gb@emulation@@QEAAXXZ ; emulation::gb::LCDDriver::RenderLine

; 46   : 				stat_.mode = 0;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	and	al, 252					; 000000fcH
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+41], al
$LN11@Step:

; 47   : 
; 48   : 			}
; 49   : 			break;

	jmp	$LN16@Step
$LN10@Step:

; 50   : 		case 0:
; 51   :       if (sprite_bug_counter > 0 && lcdc_.lcd_enable == 1) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	test	eax, eax
	jle	$LN9@Step
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+40]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN9@Step

; 52   :         emu_->memory()->oam()[8+(rand()%152)] = rand()&0xFF; 

	call	QWORD PTR __imp_rand
	and	eax, 255				; 000000ffH
	mov	DWORD PTR tv166[rsp], eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?oam@Memory@gb@emulation@@QEAAPEAEXZ	; emulation::gb::Memory::oam
	mov	QWORD PTR tv158[rsp], rax
	call	QWORD PTR __imp_rand
	cdq
	mov	ecx, 152				; 00000098H
	idiv	ecx
	mov	eax, edx
	add	eax, 8
	cdqe
	mov	rcx, QWORD PTR tv158[rsp]
	mov	edx, DWORD PTR tv166[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 53   :         --sprite_bug_counter;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	dec	al
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+16], al
$LN9@Step:

; 54   :       }
; 55   :       if (stat_.hblank_int)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@Step

; 56   :         emu_->memory()->interrupt_flag() |= 2;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?interrupt_flag@Memory@gb@emulation@@QEAAAEAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	QWORD PTR tv186[rsp], rax
	mov	rax, QWORD PTR tv186[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 2
	mov	rcx, QWORD PTR tv186[rsp]
	mov	BYTE PTR [rcx], al
$LN8@Step:

; 57   : 
; 58   : 			if (counter2==456) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+72], 456			; 000001c8H
	jne	SHORT $LN7@Step

; 59   : 				stat_.mode = 2;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	and	al, 252					; 000000fcH
	or	al, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+41], al

; 60   :         if (ly == 143) 

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	cmp	eax, 143				; 0000008fH
	jne	SHORT $LN6@Step

; 61   : 					stat_.mode = 1;//vblank period

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	and	al, 252					; 000000fcH
	or	al, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+41], al
$LN6@Step:
$LN7@Step:

; 62   :       }
; 63   : 			break;

	jmp	SHORT $LN16@Step
$LN5@Step:

; 64   : 		case 1:
; 65   :         if (stat_.vblank_int)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Step

; 66   :           emu_->memory()->interrupt_flag() |= 2;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?interrupt_flag@Memory@gb@emulation@@QEAAAEAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	QWORD PTR tv222[rsp], rax
	mov	rax, QWORD PTR tv222[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 2
	mov	rcx, QWORD PTR tv222[rsp]
	mov	BYTE PTR [rcx], al
$LN4@Step:

; 67   : 				emu_->memory()->interrupt_flag() |= 1;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?interrupt_flag@Memory@gb@emulation@@QEAAAEAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	QWORD PTR tv235[rsp], rax
	mov	rax, QWORD PTR tv235[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR tv235[rsp]
	mov	BYTE PTR [rcx], al
$LN16@Step:

; 68   : 			break;
; 69   : 	}
; 70   : 
; 71   : 	
; 72   :   if (counter2 == 456) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+72], 456			; 000001c8H
	jne	$LN3@Step

; 73   : 		if (ly++ == 153 && counter2 == 456) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	mov	DWORD PTR tv253[rsp], eax
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+44]
	inc	al
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+44], al
	cmp	DWORD PTR tv253[rsp], 153		; 00000099H
	jne	SHORT $LN20@Step
	mov	DWORD PTR tv254[rsp], 1
	jmp	SHORT $LN21@Step
$LN20@Step:
	mov	DWORD PTR tv254[rsp], 0
$LN21@Step:
	cmp	DWORD PTR tv254[rsp], 0
	je	SHORT $LN2@Step
	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+72], 456			; 000001c8H
	jne	SHORT $LN2@Step

; 74   :       //if (lcdc_.lcd_enable)
; 75   : 			emu_->on_render();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, rax
	call	??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QEBAXXZ ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()

; 76   : 			stat_.mode = 2;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	and	al, 252					; 000000fcH
	or	al, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+41], al

; 77   : 			ly = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+44], 0

; 78   : 			counter1 = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+64], 0

; 79   : 			counter2 = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+72], 0
$LN2@Step:

; 80   : 		} 
; 81   : 		counter2 = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+72], 0
$LN3@Step:

; 82   : 	}
; 83   : 
; 84   :   stat_.coincidence = lyc == ly;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+45]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+44]
	cmp	eax, ecx
	jne	SHORT $LN22@Step
	mov	BYTE PTR tv286[rsp], 1
	jmp	SHORT $LN23@Step
$LN22@Step:
	mov	BYTE PTR tv286[rsp], 0
$LN23@Step:
	movzx	eax, BYTE PTR tv286[rsp]
	and	al, 1
	shl	al, 2
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+41]
	and	cl, 251					; 000000fbH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+41], al

; 85   :   if (stat_.coincidence_inr && stat_.coincidence)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@Step
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+41]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@Step

; 86   :     emu_->memory()->interrupt_flag() |= 2;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?interrupt_flag@Memory@gb@emulation@@QEAAAEAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	QWORD PTR tv314[rsp], rax
	mov	rax, QWORD PTR tv314[rsp]
	movzx	eax, BYTE PTR [rax]
	or	eax, 2
	mov	rcx, QWORD PTR tv314[rsp]
	mov	BYTE PTR [rcx], al
$LN1@Step:

; 87   : 
; 88   : }

	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
?Step@LCDDriver@gb@emulation@@QEAAXN@Z ENDP		; emulation::gb::LCDDriver::Step
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
ioports$ = 32
$T1 = 40
$T2 = 48
this$ = 80
?Deinitialize@LCDDriver@gb@emulation@@UEAAXXZ PROC	; emulation::gb::LCDDriver::Deinitialize

; 25   : void LCDDriver::Deinitialize() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rsp
	mov	ecx, 16
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+80]

; 26   :   auto ioports = emu_->memory()->ioports();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?ioports@Memory@gb@emulation@@QEAAPEAEXZ ; emulation::gb::Memory::ioports
	mov	QWORD PTR ioports$[rsp], rax

; 27   :   delete [] colormap;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	??_V@YAXPEAX@Z				; operator delete[]

; 28   :   delete [] frame_buffer;  

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR $T2[rsp], rax
	mov	rcx, QWORD PTR $T2[rsp]
	call	??_V@YAXPEAX@Z				; operator delete[]

; 29   : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?Deinitialize@LCDDriver@gb@emulation@@UEAAXXZ ENDP	; emulation::gb::LCDDriver::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
emu$ = 72
?Initialize@LCDDriver@gb@emulation@@UEAAXPEAVEmu@23@@Z PROC ; emulation::gb::LCDDriver::Initialize

; 9    : void LCDDriver::Initialize(Emu* emu) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 10   :   Component::Initialize(emu);

	mov	rdx, QWORD PTR emu$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z ; emulation::gb::Component::Initialize

; 11   :   frame_buffer = new uint32_t[256*256];

	mov	r9d, 11
	lea	r8, OFFSET FLAT:$SG113690
	mov	edx, 1
	mov	ecx, 262144				; 00040000H
	call	??_U@YAPEAX_KHPEBDH@Z			; operator new[]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rax+24], rcx

; 12   :   lcdc_.raw = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+40], 0

; 13   :   stat_.raw = 2;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+41], 2

; 14   :   ly = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+44], 0

; 15   :   lyc = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+45], 0

; 16   :   scroll_x = scroll_y = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+43], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+42], 0

; 17   :   wx = wy = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+47], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+46], 0

; 18   :   counter1 = counter2 = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+72], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+64], 0

; 19   :   vsync = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movsdx	QWORD PTR [rax+80], xmm0

; 20   :   hsync = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movsdx	QWORD PTR [rax+88], xmm0

; 21   :   sprite_bug_counter = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+16], 0

; 22   :   colormap = new uint8_t[256*256];

	mov	r9d, 22
	lea	r8, OFFSET FLAT:$SG113693
	mov	edx, 1
	mov	ecx, 65536				; 00010000H
	call	??_U@YAPEAX_KHPEBDH@Z			; operator new[]
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rax+32], rcx

; 23   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?Initialize@LCDDriver@gb@emulation@@UEAAXPEAVEmu@23@@Z ENDP ; emulation::gb::LCDDriver::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?interrupt_flag@Memory@gb@emulation@@QEAAAEAEXZ
_TEXT	SEGMENT
this$ = 16
?interrupt_flag@Memory@gb@emulation@@QEAAAEAEXZ PROC	; emulation::gb::Memory::interrupt_flag, COMDAT

; 21   :   uint8_t& interrupt_flag() {  return ioports_[0x0F]; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	eax, 1
	imul	rax, 15
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+208]
	pop	rdi
	ret	0
?interrupt_flag@Memory@gb@emulation@@QEAAAEAEXZ ENDP	; emulation::gb::Memory::interrupt_flag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?ioports@Memory@gb@emulation@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 16
?ioports@Memory@gb@emulation@@QEAAPEAEXZ PROC		; emulation::gb::Memory::ioports, COMDAT

; 19   :   uint8_t* ioports() { return ioports_; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 208				; 000000d0H
	pop	rdi
	ret	0
?ioports@Memory@gb@emulation@@QEAAPEAEXZ ENDP		; emulation::gb::Memory::ioports
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?oam@Memory@gb@emulation@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 16
?oam@Memory@gb@emulation@@QEAAPEAEXZ PROC		; emulation::gb::Memory::oam, COMDAT

; 18   :   uint8_t* oam() { return oam_; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	pop	rdi
	ret	0
?oam@Memory@gb@emulation@@QEAAPEAEXZ ENDP		; emulation::gb::Memory::oam
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?vram@Memory@gb@emulation@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 16
?vram@Memory@gb@emulation@@QEAAPEAEXZ PROC		; emulation::gb::Memory::vram, COMDAT

; 17   : 	uint8_t* vram() { return vram_; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	pop	rdi
	ret	0
?vram@Memory@gb@emulation@@QEAAPEAEXZ ENDP		; emulation::gb::Memory::vram
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\gb.h
;	COMDAT ?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z
_TEXT	SEGMENT
this$ = 16
emu$ = 24
?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z PROC ; emulation::gb::Component::Initialize, COMDAT

; 28   :   virtual void Initialize(Emu* emu) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 29   :     emu_ = emu;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR emu$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 30   :   }

	pop	rdi
	ret	0
?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z ENDP ; emulation::gb::Component::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$yc	SEGMENT
$T1 = 0
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 137  : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	add	rsp, 16
	pop	rdi
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$yc	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 130  : const _Ignore ignore;

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:ignore
	call	??0_Ignore@std@@QEAA@XZ			; std::_Ignore::_Ignore
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0_Ignore@std@@QEAA@XZ PROC				; std::_Ignore::_Ignore, COMDAT

; 120  : 	_Ignore()

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 121  : 		{	// construct
; 122  : 		}

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0_Ignore@std@@QEAA@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = 0
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	add	rsp, 16
	pop	rdi
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = 0
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	add	rsp, 16
	pop	rdi
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
