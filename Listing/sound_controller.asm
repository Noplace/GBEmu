; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?num@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::num
PUBLIC	?den@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::den
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_monotonic@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_monotonic
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?is_steady@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_steady
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	ConcRT_ProviderGuid
PUBLIC	ConcRTEventGuid
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	SchedulerEventGuid
PUBLIC	ScheduleGroupEventGuid
PUBLIC	ContextEventGuid
PUBLIC	ChoreEventGuid
PUBLIC	VirtualProcessorEventGuid
PUBLIC	LockEventGuid
PUBLIC	ResourceManagerEventGuid
PUBLIC	PPLParallelInvokeEventGuid
PUBLIC	PPLParallelForEventGuid
PUBLIC	PPLParallelForeachEventGuid
PUBLIC	AgentEventGuid
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?value@?$integral_constant@_K$0A@@std@@2_KB	; std::integral_constant<unsigned __int64,0>::value
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB		; std::_GcdX<10000000,1>::value
PUBLIC	?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB		; std::_GcdX<1,10000000>::value
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?value@?$integral_constant@H$0A@@std@@2HB	; std::integral_constant<int,0>::value
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB		; std::_Gcd<1,10000000>::value
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?num@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::num
PUBLIC	?den@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::den
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?value@?$_Abs@$0GE@@std@@2_JB			; std::_Abs<100>::value
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?value@?$_Abs@$0DLJKMKAA@@std@@2_JB		; std::_Abs<1000000000>::value
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
PUBLIC	?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
PUBLIC	?value@?$_GcdX@$0GE@$0A@@std@@2_JB		; std::_GcdX<100,0>::value
PUBLIC	?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
PUBLIC	?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB	; std::_GcdX<1000000000,100>::value
PUBLIC	?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<100,1000000000>::value
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<100,1000000000>::value
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?value@?$_Abs@$00@std@@2_JB			; std::_Abs<1>::value
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_GcdX@$00$0A@@std@@2_JB		; std::_GcdX<1,0>::value
PUBLIC	?value@?$_GcdX@$00$00@std@@2_JB			; std::_GcdX<1,1>::value
PUBLIC	?value@?$_Gcd@$00$00@std@@2_JB			; std::_Gcd<1,1>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
PUBLIC	?is_monotonic@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_monotonic
PUBLIC	?is_steady@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_steady
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
PUBLIC	?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
PUBLIC	?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_nonNull
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelException
PUBLIC	?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_notInlined
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_structured
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_localCancel
PUBLIC	?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_reserved
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
PUBLIC	?value@?$_Abs@$0JIJGIA@@std@@2_JB		; std::_Abs<10000000>::value
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB		; std::_GcdX<10000000,0>::value
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_GcdX<10000000,10000000>::value
PUBLIC	?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Gcd<10000000,10000000>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0JIJGIA@@std@@2_JB DQ 0000000000989680H	; std::_Abs<10000000>::value
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_reserved
CONST	ENDS
;	COMDAT ?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_localCancel
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_structured
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB DD 0ffffffffH ; Concurrency::details::_TaskCollectionBase::_S_notInlined
CONST	ENDS
;	COMDAT ?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB DQ 000000000000000cH ; Concurrency::details::_TaskCollectionBase::_S_cancelException
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000008H ; Concurrency::details::_TaskCollectionBase::_S_nonNull
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000003H ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
CONST	ENDS
;	COMDAT ?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000002H ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000001H ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000000H ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
CONST	ENDS
;	COMDAT ?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000003H ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB DQ 0000000000000000H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_steady@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@system_clock@chrono@std@@2_NB DB 00H		; std::chrono::system_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@system_clock@chrono@std@@2_NB DB 00H	; std::chrono::system_clock::is_monotonic
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0A@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?value@?$_Abs@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$00@std@@2_JB DQ 0000000000000001H	; std::_Abs<1>::value
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_Gcd<100,1000000000>::value
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<100,1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<1000000000,100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB DD 03H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
CONST	ENDS
;	COMDAT ?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 02H ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0A@@std@@2_JB DQ 0000000000000064H	; std::_GcdX<100,0>::value
CONST	ENDS
;	COMDAT ?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 01H ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
CONST	ENDS
;	COMDAT ?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB DD 00H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Abs<1000000000>::value
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0GE@@std@@2_JB DQ 0000000000000064H	; std::_Abs<100>::value
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::ratio<1,10000000>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,10000000>::num
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,10000000>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@H$0A@@std@@2HB
CONST	SEGMENT
?value@?$integral_constant@H$0A@@std@@2HB DD 00H	; std::integral_constant<int,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000000,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_K$0A@@std@@2_KB
CONST	SEGMENT
?value@?$integral_constant@_K$0A@@std@@2_KB DQ 0000000000000000H ; std::integral_constant<unsigned __int64,0>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT AgentEventGuid
CONST	SEGMENT
AgentEventGuid DD 0b9b5b78cH
	DW	0713H
	DW	04898H
	DB	0a2H
	DB	01aH
	DB	0c6H
	DB	079H
	DB	049H
	DB	0dcH
	DB	0edH
	DB	07H
CONST	ENDS
;	COMDAT PPLParallelForeachEventGuid
CONST	SEGMENT
PPLParallelForeachEventGuid DD 05cb7d785H
	DW	09d66H
	DW	0465dH
	DB	0baH
	DB	0e1H
	DB	046H
	DB	011H
	DB	06H
	DB	01bH
	DB	054H
	DB	034H
CONST	ENDS
;	COMDAT PPLParallelForEventGuid
CONST	SEGMENT
PPLParallelForEventGuid DD 031c8da6bH
	DW	06165H
	DW	04042H
	DB	08bH
	DB	092H
	DB	094H
	DB	09eH
	DB	031H
	DB	05fH
	DB	04dH
	DB	084H
CONST	ENDS
;	COMDAT PPLParallelInvokeEventGuid
CONST	SEGMENT
PPLParallelInvokeEventGuid DD 0d1b5b133H
	DW	0ec3dH
	DW	049f4H
	DB	098H
	DB	0a3H
	DB	046H
	DB	04dH
	DB	01aH
	DB	09eH
	DB	046H
	DB	082H
CONST	ENDS
;	COMDAT ResourceManagerEventGuid
CONST	SEGMENT
ResourceManagerEventGuid DD 02718d25bH
	DW	05bf5H
	DW	04479H
	DB	08eH
	DB	088H
	DB	0baH
	DB	0bcH
	DB	064H
	DB	0bdH
	DB	0bfH
	DB	0caH
CONST	ENDS
;	COMDAT LockEventGuid
CONST	SEGMENT
LockEventGuid DD 079a60dc6H
	DW	05fc8H
	DW	04952H
	DB	0a4H
	DB	01cH
	DB	011H
	DB	063H
	DB	0aeH
	DB	0ecH
	DB	05eH
	DB	0b8H
CONST	ENDS
;	COMDAT VirtualProcessorEventGuid
CONST	SEGMENT
VirtualProcessorEventGuid DD 02f27805fH
	DW	01676H
	DW	04eccH
	DB	096H
	DB	0faH
	DB	07eH
	DB	0b0H
	DB	09dH
	DB	044H
	DB	030H
	DB	02fH
CONST	ENDS
;	COMDAT ChoreEventGuid
CONST	SEGMENT
ChoreEventGuid DD 07e854ec7H
	DW	0cdc4H
	DW	0405aH
	DB	0b5H
	DB	0b2H
	DB	0aaH
	DB	0f7H
	DB	0c9H
	DB	0e7H
	DB	0d4H
	DB	0cH
CONST	ENDS
;	COMDAT ContextEventGuid
CONST	SEGMENT
ContextEventGuid DD 05727a00fH
	DW	050beH
	DW	04519H
	DB	082H
	DB	056H
	DB	0f7H
	DB	069H
	DB	098H
	DB	071H
	DB	0feH
	DB	0cbH
CONST	ENDS
;	COMDAT ScheduleGroupEventGuid
CONST	SEGMENT
ScheduleGroupEventGuid DD 0e8a3bf1fH
	DW	0a86bH
	DW	04390H
	DB	09cH
	DB	060H
	DB	053H
	DB	090H
	DB	0b9H
	DB	069H
	DB	0d2H
	DB	02cH
CONST	ENDS
;	COMDAT SchedulerEventGuid
CONST	SEGMENT
SchedulerEventGuid DD 0e2091f8aH
	DW	01e0aH
	DW	04731H
	DB	084H
	DB	0a2H
	DB	0dH
	DB	0d5H
	DB	07cH
	DB	08aH
	DB	052H
	DB	061H
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ConcRTEventGuid
CONST	SEGMENT
ConcRTEventGuid DD 072b14a7dH
	DW	0704cH
	DW	0423eH
	DB	092H
	DB	0f8H
	DB	07eH
	DB	06dH
	DB	064H
	DB	0bcH
	DB	0b9H
	DB	02aH
CONST	ENDS
;	COMDAT ConcRT_ProviderGuid
CONST	SEGMENT
ConcRT_ProviderGuid DD 0f7b697a3H
	DW	04db5H
	DW	04d3bH
	DB	0beH
	DB	071H
	DB	0c4H
	DB	0d2H
	DB	084H
	DB	0e6H
	DB	059H
	DB	02fH
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_steady@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@steady_clock@chrono@std@@2_NB DB 01H		; std::chrono::steady_clock::is_steady
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?is_monotonic@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@steady_clock@chrono@std@@2_NB DB 01H	; std::chrono::steady_clock::is_monotonic
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB DQ 0000000000000001H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
CONST	SEGMENT
$SG113694 DB	'Code\emulation\gb\sound_controller.cpp', 00H
	ORG $+1
$SG113695 DB	'Code\emulation\gb\sound_controller.cpp', 00H
	ORG $+1
dutycycletable DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
clockspeed DQ	04150000000000000r		; 4.1943e+006
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::num
CONST	ENDS
PUBLIC	??0_Ignore@std@@QEAA@XZ				; std::_Ignore::_Ignore
PUBLIC	?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z ; emulation::gb::Component::Initialize
PUBLIC	?ioports@Memory@gb@emulation@@QEAAPEAEXZ	; emulation::gb::Memory::ioports
PUBLIC	?set_sample_rate@Component@synth@audio@@QEAAXI@Z ; audio::synth::Component::set_sample_rate
PUBLIC	?soundlength_ms@SoundLengthWaveDutyRegister@gb@emulation@@QEAAMXZ ; emulation::gb::SoundLengthWaveDutyRegister::soundlength_ms
PUBLIC	?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z ; emulation::gb::SoundController::Initialize
PUBLIC	?Deinitialize@SoundController@gb@emulation@@UEAAXXZ ; emulation::gb::SoundController::Deinitialize
PUBLIC	?Reset@SoundController@gb@emulation@@UEAAXXZ	; emulation::gb::SoundController::Reset
PUBLIC	?Step@SoundController@gb@emulation@@QEAAXN@Z	; emulation::gb::SoundController::Step
PUBLIC	?Read@SoundController@gb@emulation@@QEAAEG@Z	; emulation::gb::SoundController::Read
PUBLIC	?Write@SoundController@gb@emulation@@QEAAXGE@Z	; emulation::gb::SoundController::Write
PUBLIC	?Initialize@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXPEAV234@@Z ; emulation::gb::SoundController::<unnamed-type-channel1>::Initialize
PUBLIC	?LengthTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXXZ ; emulation::gb::SoundController::<unnamed-type-channel1>::LengthTick
PUBLIC	?SampleTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAEXZ ; emulation::gb::SoundController::<unnamed-type-channel1>::SampleTick
PUBLIC	?Initialize@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXPEAV234@@Z ; emulation::gb::SoundController::<unnamed-type-channel2>::Initialize
PUBLIC	?LengthTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXXZ ; emulation::gb::SoundController::<unnamed-type-channel2>::LengthTick
PUBLIC	?SampleTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAEXZ ; emulation::gb::SoundController::<unnamed-type-channel2>::SampleTick
PUBLIC	?Initialize@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXPEAV234@@Z ; emulation::gb::SoundController::<unnamed-type-channel3>::Initialize
PUBLIC	?LengthTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXXZ ; emulation::gb::SoundController::<unnamed-type-channel3>::LengthTick
PUBLIC	?SampleTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAEXZ ; emulation::gb::SoundController::<unnamed-type-channel3>::SampleTick
PUBLIC	?Initialize@<unnamed-type-channel4>@SoundController@gb@emulation@@QEAAXPEAV234@@Z ; emulation::gb::SoundController::<unnamed-type-channel4>::Initialize
PUBLIC	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ	; emulation::gb::Emu::memory
PUBLIC	??$SafeDelete@VInterface@output@audio@@@@YAXPEAPEAVInterface@output@audio@@@Z ; SafeDelete<audio::output::Interface>
PUBLIC	__real@00000000
PUBLIC	__real@3b800000
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40e00000
PUBLIC	__real@40e5888000000000
PUBLIC	__real@40f9999a
PUBLIC	__real@41700000
PUBLIC	__real@42800000
PUBLIC	__real@447a0000
PUBLIC	__real@46fffe00
PUBLIC	__real@49000000
PUBLIC	__real@bf800000
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	memset:PROC
EXTRN	__imp_powf:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp_srand:PROC
EXTRN	??2@YAPEAX_KHPEBDH@Z:PROC			; operator new
EXTRN	??3@YAXPEAXHPEBDH@Z:PROC			; operator delete
EXTRN	__imp__time64:PROC
EXTRN	??0DirectSound@output@audio@@QEAA@XZ:PROC	; audio::output::DirectSound::DirectSound
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	?noiseseed@synth@audio@@3IA:DWORD		; audio::synth::noiseseed
EXTRN	__ImageBase:BYTE
EXTRN	_fltused:DWORD
_BSS	SEGMENT
piecewise_construct DB 01H DUP (?)
allocator_arg DB 01H DUP (?)
ignore	DB	01H DUP (?)
_Tuple_alloc DB	01H DUP (?)
_BSS	ENDS
;	COMDAT ?sbuf@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4PAFA
_BSS	SEGMENT
?sbuf@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4PAFA DW 02274H DUP (?) ; `emulation::gb::SoundController::Step'::`37'::sbuf
_BSS	ENDS
;	COMDAT ?sindex@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4HA
_BSS	SEGMENT
?sindex@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4HA DD 01H DUP (?) ; `emulation::gb::SoundController::Step'::`37'::sindex
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Epiecewise_construct@std@@YAXXZ DD imagerel ??__Epiecewise_construct@std@@YAXXZ
	DD	imagerel ??__Epiecewise_construct@std@@YAXXZ+43
	DD	imagerel $unwind$??__Epiecewise_construct@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eallocator_arg@std@@YAXXZ DD imagerel ??__Eallocator_arg@std@@YAXXZ
	DD	imagerel ??__Eallocator_arg@std@@YAXXZ+43
	DD	imagerel $unwind$??__Eallocator_arg@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Ignore@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+13
	DD	imagerel $unwind$??0_Ignore@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eignore@std@@YAXXZ DD imagerel ??__Eignore@std@@YAXXZ
	DD	imagerel ??__Eignore@std@@YAXXZ+39
	DD	imagerel $unwind$??__Eignore@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E_Tuple_alloc@std@@YAXXZ DD imagerel ??__E_Tuple_alloc@std@@YAXXZ
	DD	imagerel ??__E_Tuple_alloc@std@@YAXXZ+43
	DD	imagerel $unwind$??__E_Tuple_alloc@std@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$time DD	imagerel time
	DD	imagerel time+47
	DD	imagerel $unwind$time
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ioports@Memory@gb@emulation@@QEAAPEAEXZ DD imagerel $LN3
	DD	imagerel $LN3+19
	DD	imagerel $unwind$?ioports@Memory@gb@emulation@@QEAAPEAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?set_sample_rate@Component@synth@audio@@QEAAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?set_sample_rate@Component@synth@audio@@QEAAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?soundlength_ms@SoundLengthWaveDutyRegister@gb@emulation@@QEAAMXZ DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$?soundlength_ms@SoundLengthWaveDutyRegister@gb@emulation@@QEAAMXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z DD imagerel $LN6
	DD	imagerel $LN6+407
	DD	imagerel $unwind$?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dtor$0@?0??Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z@4HA DD imagerel ?dtor$0@?0??Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z@4HA
	DD	imagerel ?dtor$0@?0??Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z@4HA+53
	DD	imagerel $unwind$?dtor$0@?0??Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?Deinitialize@SoundController@gb@emulation@@UEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?Deinitialize@SoundController@gb@emulation@@UEAAXXZ
$pdata$?Reset@SoundController@gb@emulation@@UEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+459
	DD	imagerel $unwind$?Reset@SoundController@gb@emulation@@UEAAXXZ
$pdata$?Step@SoundController@gb@emulation@@QEAAXN@Z DD imagerel $LN14
	DD	imagerel $LN14+1671
	DD	imagerel $unwind$?Step@SoundController@gb@emulation@@QEAAXN@Z
$pdata$?Read@SoundController@gb@emulation@@QEAAEG@Z DD imagerel $LN28
	DD	imagerel $LN28+980
	DD	imagerel $unwind$?Read@SoundController@gb@emulation@@QEAAEG@Z
$pdata$?Write@SoundController@gb@emulation@@QEAAXGE@Z DD imagerel $LN44
	DD	imagerel $LN44+2100
	DD	imagerel $unwind$?Write@SoundController@gb@emulation@@QEAAXGE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXPEAV234@@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$?Initialize@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXPEAV234@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?LengthTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+144
	DD	imagerel $unwind$?LengthTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SampleTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAEXZ DD imagerel $LN6
	DD	imagerel $LN6+223
	DD	imagerel $unwind$?SampleTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXPEAV234@@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$?Initialize@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXPEAV234@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?LengthTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+147
	DD	imagerel $unwind$?LengthTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SampleTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAEXZ DD imagerel $LN6
	DD	imagerel $LN6+224
	DD	imagerel $unwind$?SampleTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXPEAV234@@Z DD imagerel $LN3
	DD	imagerel $LN3+130
	DD	imagerel $unwind$?Initialize@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXPEAV234@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?LengthTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+156
	DD	imagerel $unwind$?LengthTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SampleTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAEXZ DD imagerel $LN7
	DD	imagerel $LN7+226
	DD	imagerel $unwind$?SampleTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Initialize@<unnamed-type-channel4>@SoundController@gb@emulation@@QEAAXPEAV234@@Z DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$?Initialize@<unnamed-type-channel4>@SoundController@gb@emulation@@QEAAXPEAV234@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ DD imagerel $LN3
	DD	imagerel $LN3+19
	DD	imagerel $unwind$?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$SafeDelete@VInterface@output@audio@@@@YAXPEAPEAVInterface@output@audio@@@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??$SafeDelete@VInterface@output@audio@@@@YAXPEAPEAVInterface@output@audio@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??R<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z DD imagerel ??R<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z
	DD	imagerel ??R<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z+302
	DD	imagerel $unwind$??R<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z
$pdata$?<helper_func_cdecl>@<lambda_3ece7da5f758d55a88d025c1273884e8>@@CAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z DD imagerel ?<helper_func_cdecl>@<lambda_3ece7da5f758d55a88d025c1273884e8>@@CAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z
	DD	imagerel ?<helper_func_cdecl>@<lambda_3ece7da5f758d55a88d025c1273884e8>@@CAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z+58
	DD	imagerel $unwind$?<helper_func_cdecl>@<lambda_3ece7da5f758d55a88d025c1273884e8>@@CAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z
$pdata$??B<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAP6AXAEATVolumeEnvelope@gb@emulation@@AEAM@ZXZ DD imagerel ??B<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAP6AXAEATVolumeEnvelope@gb@emulation@@AEAM@ZXZ
	DD	imagerel ??B<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAP6AXAEATVolumeEnvelope@gb@emulation@@AEAM@ZXZ+15
	DD	imagerel $unwind$??B<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAP6AXAEATVolumeEnvelope@gb@emulation@@AEAM@ZXZ
pdata	ENDS
CRT$XCU	SEGMENT
piecewise_construct$initializer$ DQ FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@49000000
CONST	SEGMENT
__real@49000000 DD 049000000r			; 524288
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@40f9999a
CONST	SEGMENT
__real@40f9999a DD 040f9999ar			; 7.8
CONST	ENDS
;	COMDAT __real@40e5888000000000
CONST	SEGMENT
__real@40e5888000000000 DQ 040e5888000000000r	; 44100
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3b800000
CONST	SEGMENT
__real@3b800000 DD 03b800000r			; 0.00390625
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$SafeDelete@VInterface@output@audio@@@@YAXPEAPEAVInterface@output@audio@@@Z DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@<unnamed-type-channel4>@SoundController@gb@emulation@@QEAAXPEAV234@@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SampleTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAEXZ DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?LengthTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXXZ DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXPEAV234@@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SampleTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAEXZ DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?LengthTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXXZ DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXPEAV234@@Z DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SampleTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAEXZ DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?LengthTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXXZ DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXPEAV234@@Z DD 010b01H
	DD	0700bH
xdata	ENDS
CONST	SEGMENT
?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z$rtcName$0 DB 074H ; emulation::gb::SoundController::Initialize
	DB	00H
	ORG $+6
?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z$rtcVarDesc DD 028H ; emulation::gb::SoundController::Initialize
	DD	08H
	DQ	FLAT:?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z$rtcName$0
	ORG $+48
?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z$rtcFrameData DD 01H ; emulation::gb::SoundController::Initialize
	DD	00H
	DQ	FLAT:?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z$rtcVarDesc
$cppxdata$?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z
	DD	048H
	DD	00H
	DD	01H
?Step@SoundController@gb@emulation@@QEAAXN@Z$rtcName$0 DB 065H ; emulation::gb::SoundController::Step
	DB	06eH
	DB	076H
	DB	065H
	DB	06cH
	DB	06fH
	DB	070H
	DB	065H
	DB	054H
	DB	069H
	DB	063H
	DB	06bH
	DB	00H
	ORG $+11
?Step@SoundController@gb@emulation@@QEAAXN@Z$rtcVarDesc DD 024H ; emulation::gb::SoundController::Step
	DD	01H
	DQ	FLAT:?Step@SoundController@gb@emulation@@QEAAXN@Z$rtcName$0
	ORG $+48
?Step@SoundController@gb@emulation@@QEAAXN@Z$rtcFrameData DD 01H ; emulation::gb::SoundController::Step
	DD	00H
	DQ	FLAT:?Step@SoundController@gb@emulation@@QEAAXN@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?soundlength_ms@SoundLengthWaveDutyRegister@gb@emulation@@QEAAMXZ DD 021e01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?set_sample_rate@Component@synth@audio@@QEAAXI@Z DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ioports@Memory@gb@emulation@@QEAAPEAEXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z DD 010b01H
	DD	0700bH
xdata	ENDS
xdata	SEGMENT
$unwind$time DD	021e01H
	DD	07006320aH
$unwind$?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z DD 022c11H
	DD	0700bb20fH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z
$stateUnwindMap$?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z@4HA
$ip2state$?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z DD imagerel ?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z
	DD	0ffffffffH
	DD	imagerel ?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z+123
	DD	00H
	DD	imagerel ?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z+167
	DD	0ffffffffH
$unwind$?dtor$0@?0??Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
$unwind$?Deinitialize@SoundController@gb@emulation@@UEAAXXZ DD 021e01H
	DD	07006320aH
$unwind$?Reset@SoundController@gb@emulation@@UEAAXXZ DD 021e01H
	DD	07006320aH
$unwind$?Step@SoundController@gb@emulation@@QEAAXN@Z DD 022401H
	DD	0700cb210H
$unwind$?Read@SoundController@gb@emulation@@QEAAEG@Z DD 022301H
	DD	0700b120fH
$unwind$?Write@SoundController@gb@emulation@@QEAAXGE@Z DD 022801H
	DD	070109214H
$unwind$??R<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z DD 022801H
	DD	070101214H
$unwind$?<helper_func_cdecl>@<lambda_3ece7da5f758d55a88d025c1273884e8>@@CAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z DD 022301H
	DD	0700b320fH
$unwind$??B<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAP6AXAEATVolumeEnvelope@gb@emulation@@AEAM@ZXZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E_Tuple_alloc@std@@YAXXZ DD 021501H
	DD	070021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eignore@std@@YAXXZ DD 021501H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Ignore@std@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eallocator_arg@std@@YAXXZ DD 021501H
	DD	070021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Epiecewise_construct@std@@YAXXZ DD 021501H
	DD	070021206H
xdata	ENDS
CRT$XCU	SEGMENT
allocator_arg$initializer$ DQ FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
ignore$initializer$ DQ FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_Tuple_alloc$initializer$ DQ FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.cpp
_TEXT	SEGMENT
this$ = 16
??B<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAP6AXAEATVolumeEnvelope@gb@emulation@@AEAM@ZXZ PROC ; <lambda_3ece7da5f758d55a88d025c1273884e8>::operator void (__cdecl*)(emulation::gb::VolumeEnvelope & __ptr64,float & __ptr64)

; 87   :   };

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	lea	rax, OFFSET FLAT:?<helper_func_cdecl>@<lambda_3ece7da5f758d55a88d025c1273884e8>@@CAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z ; <lambda_3ece7da5f758d55a88d025c1273884e8>::<helper_func_cdecl>
	pop	rdi
	ret	0
??B<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAP6AXAEATVolumeEnvelope@gb@emulation@@AEAM@ZXZ ENDP ; <lambda_3ece7da5f758d55a88d025c1273884e8>::operator void (__cdecl*)(emulation::gb::VolumeEnvelope & __ptr64,float & __ptr64)
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.cpp
_TEXT	SEGMENT
envreg$ = 48
counter$ = 56
?<helper_func_cdecl>@<lambda_3ece7da5f758d55a88d025c1273884e8>@@CAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z PROC ; <lambda_3ece7da5f758d55a88d025c1273884e8>::<helper_func_cdecl>

; 87   :   };

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]
	mov	r8, QWORD PTR counter$[rsp]
	mov	rdx, QWORD PTR envreg$[rsp]
	xor	ecx, ecx
	call	??R<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z ; <lambda_3ece7da5f758d55a88d025c1273884e8>::operator()
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?<helper_func_cdecl>@<lambda_3ece7da5f758d55a88d025c1273884e8>@@CAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z ENDP ; <lambda_3ece7da5f758d55a88d025c1273884e8>::<helper_func_cdecl>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.cpp
_TEXT	SEGMENT
env_step_ms$ = 0
this$ = 32
envreg$ = 40
counter$ = 48
??R<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z PROC ; <lambda_3ece7da5f758d55a88d025c1273884e8>::operator()

; 77   :   auto envelopeTick = [](VolumeEnvelope& envreg,real_t& counter){

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 78   :     float env_step_ms = envreg.env_sweep/64.0f*1000.0f;

	mov	rax, QWORD PTR envreg$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	al, 7
	movzx	eax, al
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@42800000
	mulss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR env_step_ms$[rsp], xmm0

; 79   : 
; 80   :     if (env_step_ms != 0 && counter >= env_step_ms) {

	movss	xmm0, DWORD PTR env_step_ms$[rsp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	jp	SHORT $LN6@operator
	je	$LN3@operator
$LN6@operator:
	mov	rax, QWORD PTR counter$[rsp]
	movss	xmm0, DWORD PTR [rax]
	comiss	xmm0, DWORD PTR env_step_ms$[rsp]
	jb	$LN3@operator

; 81   :         if (envreg.direction && envreg.vol<0xF)

	mov	rax, QWORD PTR envreg$[rsp]
	movzx	eax, BYTE PTR [rax]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@operator
	mov	rax, QWORD PTR envreg$[rsp]
	movzx	eax, BYTE PTR [rax]
	shr	al, 4
	and	al, 15
	movzx	eax, al
	cmp	eax, 15
	jge	SHORT $LN2@operator

; 82   :           ++envreg.vol;

	mov	rax, QWORD PTR envreg$[rsp]
	movzx	eax, BYTE PTR [rax]
	shr	al, 4
	and	al, 15
	inc	al
	and	al, 15
	shl	al, 4
	mov	rcx, QWORD PTR envreg$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	and	cl, 15
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR envreg$[rsp]
	mov	BYTE PTR [rcx], al
$LN2@operator:

; 83   :         if (!envreg.direction && envreg.vol>0)

	mov	rax, QWORD PTR envreg$[rsp]
	movzx	eax, BYTE PTR [rax]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@operator
	mov	rax, QWORD PTR envreg$[rsp]
	movzx	eax, BYTE PTR [rax]
	shr	al, 4
	and	al, 15
	movzx	eax, al
	test	eax, eax
	jle	SHORT $LN1@operator

; 84   :           --envreg.vol;

	mov	rax, QWORD PTR envreg$[rsp]
	movzx	eax, BYTE PTR [rax]
	shr	al, 4
	and	al, 15
	dec	al
	and	al, 15
	shl	al, 4
	mov	rcx, QWORD PTR envreg$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	and	cl, 15
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR envreg$[rsp]
	mov	BYTE PTR [rcx], al
$LN1@operator:

; 85   :       counter = 0;

	mov	rax, QWORD PTR counter$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax], xmm0
$LN3@operator:

; 86   :     }
; 87   :   };

	add	rsp, 16
	pop	rdi
	ret	0
??R<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z ENDP ; <lambda_3ece7da5f758d55a88d025c1273884e8>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\wincore\types.h
;	COMDAT ??$SafeDelete@VInterface@output@audio@@@@YAXPEAPEAVInterface@output@audio@@@Z
_TEXT	SEGMENT
$T1 = 32
ppInterfaceToDelete$ = 64
??$SafeDelete@VInterface@output@audio@@@@YAXPEAPEAVInterface@output@audio@@@Z PROC ; SafeDelete<audio::output::Interface>, COMDAT

; 37   : inline void SafeDelete(Interface **ppInterfaceToDelete) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rsp
	mov	ecx, 12
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+64]

; 38   :     if (*ppInterfaceToDelete != NULL) {

	mov	rax, QWORD PTR ppInterfaceToDelete$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN1@SafeDelete

; 39   :         delete (*ppInterfaceToDelete);

	mov	rax, QWORD PTR ppInterfaceToDelete$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	??3@YAXPEAX@Z				; operator delete

; 40   :         (*ppInterfaceToDelete) = NULL;

	mov	rax, QWORD PTR ppInterfaceToDelete$[rsp]
	mov	QWORD PTR [rax], 0
$LN1@SafeDelete:

; 41   :     }
; 42   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$SafeDelete@VInterface@output@audio@@@@YAXPEAPEAVInterface@output@audio@@@Z ENDP ; SafeDelete<audio::output::Interface>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\emu.h
;	COMDAT ?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ
_TEXT	SEGMENT
this$ = 16
?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ PROC	; emulation::gb::Emu::memory, COMDAT

; 21   :   Memory* memory() { return &memory_; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 2232				; 000008b8H
	pop	rdi
	ret	0
?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ENDP	; emulation::gb::Emu::memory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.h
;	COMDAT ?Initialize@<unnamed-type-channel4>@SoundController@gb@emulation@@QEAAXPEAV234@@Z
_TEXT	SEGMENT
this$ = 16
sc$ = 24
?Initialize@<unnamed-type-channel4>@SoundController@gb@emulation@@QEAAXPEAV234@@Z PROC ; emulation::gb::SoundController::<unnamed-type-channel4>::Initialize, COMDAT

; 254  :     void Initialize(SoundController* sc) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 255  :       sc_ = sc;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR sc$[rsp]
	mov	QWORD PTR [rax], rcx

; 256  : 			envelope.raw = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+8], 0

; 257  :     }

	pop	rdi
	ret	0
?Initialize@<unnamed-type-channel4>@SoundController@gb@emulation@@QEAAXPEAV234@@Z ENDP ; emulation::gb::SoundController::<unnamed-type-channel4>::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.h
;	COMDAT ?SampleTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAEXZ
_TEXT	SEGMENT
tv78 = 0
tv79 = 4
this$ = 32
?SampleTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAEXZ PROC ; emulation::gb::SoundController::<unnamed-type-channel3>::SampleTick, COMDAT

; 227  :     uint8_t SampleTick() {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 228  : 			if (!enabled) return 0;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+35]
	test	eax, eax
	jne	SHORT $LN2@SampleTick
	xor	al, al
	jmp	$LN3@SampleTick
$LN2@SampleTick:

; 229  : 			if ((sc_->nr24_ & 0x80)&&freqcounter-- == 0) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+96]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	$LN1@SampleTick
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, WORD PTR [rax+28]
	mov	DWORD PTR tv78[rsp], eax
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, WORD PTR [rax+28]
	dec	ax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+28], ax
	cmp	DWORD PTR tv78[rsp], 0
	jne	SHORT $LN5@SampleTick
	mov	DWORD PTR tv79[rsp], 1
	jmp	SHORT $LN6@SampleTick
$LN5@SampleTick:
	mov	DWORD PTR tv79[rsp], 0
$LN6@SampleTick:
	cmp	DWORD PTR tv79[rsp], 0
	je	SHORT $LN1@SampleTick

; 230  : 				sample = sc_->wavram[playback_counter];

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+20]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+rcx+102]
	mov	BYTE PTR [rdx+34], al

; 231  : 				playback_counter = (playback_counter + 1) & 0x1F;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+20]
	inc	eax
	and	eax, 31
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+20], al

; 232  : 				freqcounter = freqcounterload;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, WORD PTR [rcx+30]
	mov	WORD PTR [rax+28], cx
$LN1@SampleTick:

; 233  : 			}
; 234  :       return sample;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+34]
$LN3@SampleTick:

; 235  :     }

	add	rsp, 16
	pop	rdi
	ret	0
?SampleTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAEXZ ENDP ; emulation::gb::SoundController::<unnamed-type-channel3>::SampleTick
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.h
;	COMDAT ?LengthTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXXZ
_TEXT	SEGMENT
tv75 = 0
tv76 = 4
this$ = 32
?LengthTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXXZ PROC ; emulation::gb::SoundController::<unnamed-type-channel3>::LengthTick, COMDAT

; 220  : 		void LengthTick() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 221  : 			if ((sc_->nr34_ & 0x40) && lengthcounter-- == 0) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+101]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN1@LengthTick
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	mov	DWORD PTR tv75[rsp], eax
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	dec	al
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+33], al
	cmp	DWORD PTR tv75[rsp], 0
	jne	SHORT $LN4@LengthTick
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN5@LengthTick
$LN4@LengthTick:
	mov	DWORD PTR tv76[rsp], 0
$LN5@LengthTick:
	cmp	DWORD PTR tv76[rsp], 0
	je	SHORT $LN1@LengthTick

; 222  : 				sc_->nr34_ &= ~0x80;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+101]
	btr	eax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rcx+101], al

; 223  : 				enabled = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+35], 0
$LN1@LengthTick:

; 224  : 			}
; 225  : 		}

	add	rsp, 16
	pop	rdi
	ret	0
?LengthTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXXZ ENDP ; emulation::gb::SoundController::<unnamed-type-channel3>::LengthTick
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.h
;	COMDAT ?Initialize@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXPEAV234@@Z
_TEXT	SEGMENT
this$ = 16
sc$ = 24
?Initialize@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXPEAV234@@Z PROC ; emulation::gb::SoundController::<unnamed-type-channel3>::Initialize, COMDAT

; 206  :     void Initialize(SoundController* sc) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 207  :       playback_counter = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+20], 0

; 208  :       freqcounter=0;

	xor	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+28], ax

; 209  : 			freqcounterload =0;

	xor	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+30], ax

; 210  : 			vol=0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+16], xmm0

; 211  : 			lengthcounter=0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+33], 0

; 212  :       sc_ = sc;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR sc$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 213  :       wavsample = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+24], xmm0

; 214  :       enabled = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+35], 0

; 215  :       freqcounter = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+28], ax

; 216  :       sample = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+34], 0

; 217  : 			envelope.raw = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 218  :     }

	pop	rdi
	ret	0
?Initialize@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXPEAV234@@Z ENDP ; emulation::gb::SoundController::<unnamed-type-channel3>::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.h
;	COMDAT ?SampleTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAEXZ
_TEXT	SEGMENT
tv75 = 0
tv76 = 4
this$ = 32
?SampleTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAEXZ PROC ; emulation::gb::SoundController::<unnamed-type-channel2>::SampleTick, COMDAT

; 185  :     uint8_t SampleTick() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 186  : 			if ((sc_->nr24_ & 0x80)&&freqcounter-- == 0) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+96]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	$LN1@SampleTick
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, WORD PTR [rax+18]
	mov	DWORD PTR tv75[rsp], eax
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, WORD PTR [rax+18]
	dec	ax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+18], ax
	cmp	DWORD PTR tv75[rsp], 0
	jne	SHORT $LN4@SampleTick
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN5@SampleTick
$LN4@SampleTick:
	mov	DWORD PTR tv76[rsp], 0
$LN5@SampleTick:
	cmp	DWORD PTR tv76[rsp], 0
	je	SHORT $LN1@SampleTick

; 187  : 				sample = dutycycletable[wavepatternduty|wavepatterncounter];

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+2]
	or	eax, ecx
	cdqe
	lea	rcx, OFFSET FLAT:dutycycletable
	mov	rdx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdx+22], al

; 188  : 				wavepatterncounter = (wavepatterncounter +1 ) % 8;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+2]
	inc	eax
	cdq
	and	edx, 7
	add	eax, edx
	and	eax, 7
	sub	eax, edx
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+2], al

; 189  : 				freqcounter = freqcounterload;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+18], cx
$LN1@SampleTick:

; 190  : 			}
; 191  :       return sample;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+22]

; 192  :     }

	add	rsp, 16
	pop	rdi
	ret	0
?SampleTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAEXZ ENDP ; emulation::gb::SoundController::<unnamed-type-channel2>::SampleTick
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.h
;	COMDAT ?LengthTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXXZ
_TEXT	SEGMENT
tv75 = 0
tv76 = 4
this$ = 32
?LengthTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXXZ PROC ; emulation::gb::SoundController::<unnamed-type-channel2>::LengthTick, COMDAT

; 178  : 		void LengthTick() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 179  : 			if ((sc_->nr24_ & 0x40) && lengthcounter-- == 0) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+96]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN1@LengthTick
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+21]
	mov	DWORD PTR tv75[rsp], eax
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+21]
	dec	al
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+21], al
	cmp	DWORD PTR tv75[rsp], 0
	jne	SHORT $LN4@LengthTick
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN5@LengthTick
$LN4@LengthTick:
	mov	DWORD PTR tv76[rsp], 0
$LN5@LengthTick:
	cmp	DWORD PTR tv76[rsp], 0
	je	SHORT $LN1@LengthTick

; 180  : 				sc_->nr24_ &= ~0x80;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+96]
	btr	eax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rcx+96], al
$LN1@LengthTick:

; 181  : 			}
; 182  : 		}

	add	rsp, 16
	pop	rdi
	ret	0
?LengthTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXXZ ENDP ; emulation::gb::SoundController::<unnamed-type-channel2>::LengthTick
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.h
;	COMDAT ?Initialize@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXPEAV234@@Z
_TEXT	SEGMENT
this$ = 16
sc$ = 24
?Initialize@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXPEAV234@@Z PROC ; emulation::gb::SoundController::<unnamed-type-channel2>::Initialize, COMDAT

; 169  :     void Initialize(SoundController* sc) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 170  :       sc_ = sc;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR sc$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 171  :       wavepatterncounter = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+2], 0

; 172  :       wavepatternduty = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+1], 0

; 173  :       freqcounter = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+18], ax

; 174  :       sample = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+22], 0

; 175  : 			envelope.raw = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 176  :     }

	pop	rdi
	ret	0
?Initialize@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXPEAV234@@Z ENDP ; emulation::gb::SoundController::<unnamed-type-channel2>::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.h
;	COMDAT ?SampleTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAEXZ
_TEXT	SEGMENT
tv75 = 0
tv76 = 4
this$ = 32
?SampleTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAEXZ PROC ; emulation::gb::SoundController::<unnamed-type-channel1>::SampleTick, COMDAT

; 152  :     uint8_t SampleTick() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 153  : 			if ((sc_->nr14_ & 0x80)&&freqcounter-- == 0) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+92]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	$LN1@SampleTick
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, WORD PTR [rax+10]
	mov	DWORD PTR tv75[rsp], eax
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, WORD PTR [rax+10]
	dec	ax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+10], ax
	cmp	DWORD PTR tv75[rsp], 0
	jne	SHORT $LN4@SampleTick
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN5@SampleTick
$LN4@SampleTick:
	mov	DWORD PTR tv76[rsp], 0
$LN5@SampleTick:
	cmp	DWORD PTR tv76[rsp], 0
	je	SHORT $LN1@SampleTick

; 154  : 				sample = dutycycletable[wavepatternduty|wavepatterncounter];

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+13]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+14]
	or	eax, ecx
	cdqe
	lea	rcx, OFFSET FLAT:dutycycletable
	mov	rdx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdx+17], al

; 155  : 				wavepatterncounter = (wavepatterncounter +1 ) % 8;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+14]
	inc	eax
	cdq
	and	edx, 7
	add	eax, edx
	and	eax, 7
	sub	eax, edx
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+14], al

; 156  : 				freqcounter = freqcounterload;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, WORD PTR [rcx+8]
	mov	WORD PTR [rax+10], cx
$LN1@SampleTick:

; 157  : 			}
; 158  :       return sample;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+17]

; 159  : 
; 160  :     }

	add	rsp, 16
	pop	rdi
	ret	0
?SampleTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAEXZ ENDP ; emulation::gb::SoundController::<unnamed-type-channel1>::SampleTick
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.h
;	COMDAT ?LengthTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXXZ
_TEXT	SEGMENT
tv75 = 0
tv76 = 4
this$ = 32
?LengthTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXXZ PROC ; emulation::gb::SoundController::<unnamed-type-channel1>::LengthTick, COMDAT

; 145  : 		void LengthTick() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 146  : 			if ((sc_->nr14_ & 0x40) && lengthcounter-- == 0) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+92]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN1@LengthTick
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	mov	DWORD PTR tv75[rsp], eax
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	dec	al
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+16], al
	cmp	DWORD PTR tv75[rsp], 0
	jne	SHORT $LN4@LengthTick
	mov	DWORD PTR tv76[rsp], 1
	jmp	SHORT $LN5@LengthTick
$LN4@LengthTick:
	mov	DWORD PTR tv76[rsp], 0
$LN5@LengthTick:
	cmp	DWORD PTR tv76[rsp], 0
	je	SHORT $LN1@LengthTick

; 147  : 				sc_->nr14_ &= ~0x80;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rax+92]
	btr	eax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rcx+92], al
$LN1@LengthTick:

; 148  : 			}
; 149  : 		}

	add	rsp, 16
	pop	rdi
	ret	0
?LengthTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXXZ ENDP ; emulation::gb::SoundController::<unnamed-type-channel1>::LengthTick
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.h
;	COMDAT ?Initialize@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXPEAV234@@Z
_TEXT	SEGMENT
this$ = 16
sc$ = 24
?Initialize@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXPEAV234@@Z PROC ; emulation::gb::SoundController::<unnamed-type-channel1>::Initialize, COMDAT

; 136  :     void Initialize(SoundController* sc) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 137  :       sc_ = sc;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR sc$[rsp]
	mov	QWORD PTR [rax], rcx

; 138  :       wavepatterncounter = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+14], 0

; 139  :       wavepatternduty = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+13], 0

; 140  :       freqcounter = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+10], ax

; 141  :       sample = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+17], 0

; 142  : 			envelope.raw = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+12], 0

; 143  :     }

	pop	rdi
	ret	0
?Initialize@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXPEAV234@@Z ENDP ; emulation::gb::SoundController::<unnamed-type-channel1>::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.cpp
_TEXT	SEGMENT
index$1 = 32
x$2 = 36
x$3 = 40
x$4 = 44
x$5 = 48
r$6 = 52
s$7 = 56
tv93 = 60
tv256 = 64
tv269 = 68
tv349 = 72
this$ = 96
address$ = 104
data$ = 112
?Write@SoundController@gb@emulation@@QEAAXGE@Z PROC	; emulation::gb::SoundController::Write

; 258  : void SoundController::Write(uint16_t address, uint8_t data) {

$LN44:
	mov	BYTE PTR [rsp+24], r8b
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, rsp
	mov	ecx, 20
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+96]

; 259  :   ioports[address-0xFF10] = data;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	movzx	edx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 260  :   if (address>=0xFF30 && address<=0xFF3F) {

	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 65328				; 0000ff30H
	jl	SHORT $LN38@Write
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 65343				; 0000ff3fH
	jg	SHORT $LN38@Write

; 261  :      int index = (address & 0x0F)<<1;

	movzx	eax, WORD PTR address$[rsp]
	and	eax, 15
	shl	eax, 1
	mov	DWORD PTR index$1[rsp], eax

; 262  :      wavram[index] = data>>4;

	movzx	eax, BYTE PTR data$[rsp]
	sar	eax, 4
	movsxd	rcx, DWORD PTR index$1[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+102], al

; 263  :      wavram[index+1] = data&0xF;

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, 15
	mov	ecx, DWORD PTR index$1[rsp]
	inc	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rdx+rcx+102], al
$LN38@Write:

; 264  :   }
; 265  : 
; 266  :   switch (address) {

	movzx	eax, WORD PTR address$[rsp]
	mov	DWORD PTR tv93[rsp], eax
	mov	eax, DWORD PTR tv93[rsp]
	sub	eax, 65296				; 0000ff10H
	mov	DWORD PTR tv93[rsp], eax
	cmp	DWORD PTR tv93[rsp], 22
	ja	$LN36@Write
	movsxd	rax, DWORD PTR tv93[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN43@Write[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN35@Write:

; 267  :     case 0xFF10:
; 268  :       nr10_.raw = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+88], cl

; 269  :       if (nr10_.sweep_shift == 0)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+88]
	and	al, 7
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN34@Write

; 270  :         channel1freqsweep = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+252], xmm0

; 271  :       else

	jmp	SHORT $LN33@Write
$LN34@Write:

; 272  :         channel1freqsweep = 0;//channel1freq/(powf(2,float(nr10_.sweep_shift)));

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+252], xmm0
$LN33@Write:

; 273  :       if (nr10_.incdec)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+88]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN32@Write

; 274  :         channel1freqsweep *= -1;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+252]
	mulss	xmm0, DWORD PTR __real@bf800000
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+252], xmm0
$LN32@Write:

; 275  :       break;

	jmp	$LN36@Write
$LN31@Write:

; 276  :     case 0xFF11:
; 277  :       nr11_.raw = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+89], cl

; 278  :       channel1.wavepatternduty = (data&0xC0)>>3;

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, 192				; 000000c0H
	sar	eax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+157], al

; 279  :       channel1.lengthcounterload = 64 - (data&0x3F);

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, 63					; 0000003fH
	mov	ecx, 64					; 00000040H
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+159], al

; 280  :       break;

	jmp	$LN36@Write
$LN30@Write:

; 281  :     case 0xFF12:
; 282  :       nr12_.raw = data;    

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+90], cl

; 283  :       break;

	jmp	$LN36@Write
$LN29@Write:

; 284  :     case 0xFF13:
; 285  :       nr13_ = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+91], cl

; 286  :       break;

	jmp	$LN36@Write
$LN28@Write:

; 287  :     case 0xFF14: {
; 288  :       nr14_ = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+92], cl

; 289  :       uint32_t x = nr13_;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+91]
	mov	DWORD PTR x$2[rsp], eax

; 290  :       x |= (nr14_&0x7)<<8;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+92]
	and	eax, 7
	shl	eax, 8
	mov	ecx, DWORD PTR x$2[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x$2[rsp], eax

; 291  :       channel1.freqcounterload = 2048-x;

	mov	eax, 2048				; 00000800H
	sub	eax, DWORD PTR x$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+152], ax

; 292  : 
; 293  :       //channel1freq = 131072.0f/(2048-x);
; 294  :       if (nr14_ & 0x80) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+92]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN27@Write

; 295  :         nr52_ |= 0x01;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+282]
	or	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+282], al

; 296  :         channel1envcounterms = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+256], xmm0

; 297  :         channel1sweepcounterms = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+248], xmm0

; 298  :         //channel1soundlengthcounter = 0;
; 299  :         channel1.envelope.raw = nr12_.raw;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+90]
	mov	BYTE PTR [rax+156], cl

; 300  : 
; 301  :         channel1.freqcounter = channel1.freqcounterload;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, WORD PTR [rcx+152]
	mov	WORD PTR [rax+154], cx

; 302  :         channel1.lengthcounter = channel1.lengthcounterload;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+159]
	mov	BYTE PTR [rax+160], cl
$LN27@Write:

; 303  :       }
; 304  :       break;

	jmp	$LN36@Write
$LN26@Write:

; 305  :     }
; 306  : 
; 307  : 
; 308  :     case 0xFF16:
; 309  :       nr21_.raw = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+93], cl

; 310  :       channel2.wavepatternduty = (data&0xC0)>>3;

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, 192				; 000000c0H
	sar	eax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+169], al

; 311  :       channel2.lengthcounterload = 64 - (data&0x3F);

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, 63					; 0000003fH
	mov	ecx, 64					; 00000040H
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+188], al

; 312  :       break;

	jmp	$LN36@Write
$LN25@Write:

; 313  :     case 0xFF17:
; 314  :       nr22_.raw = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+94], cl

; 315  :       break;

	jmp	$LN36@Write
$LN24@Write:

; 316  :     case 0xFF18:
; 317  :       nr23_ = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+95], cl

; 318  :       break;

	jmp	$LN36@Write
$LN23@Write:

; 319  :     case 0xFF19: {
; 320  :       nr24_ = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+96], cl

; 321  :       uint32_t x = nr23_;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+95]
	mov	DWORD PTR x$3[rsp], eax

; 322  :       x |= (nr24_&0x7)<<8;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+96]
	and	eax, 7
	shl	eax, 8
	mov	ecx, DWORD PTR x$3[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x$3[rsp], eax

; 323  : 			channel2.freqcounterload = 2048-x;

	mov	eax, 2048				; 00000800H
	sub	eax, DWORD PTR x$3[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+184], ax

; 324  :       //channel2freq = 131072.0f/(2048-x);
; 325  :       if (nr24_ & 0x80) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+96]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN22@Write

; 326  :         nr52_ |= 0x01;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+282]
	or	eax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+282], al

; 327  :         channel2envcounterms = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+260], xmm0

; 328  :         channel2.envelope.raw = nr22_.raw;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+94]
	mov	BYTE PTR [rax+168], cl

; 329  : 
; 330  :         channel2.freqcounter = channel2.freqcounterload;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, WORD PTR [rcx+184]
	mov	WORD PTR [rax+186], cx

; 331  :         channel2.lengthcounter = channel2.lengthcounterload;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+188]
	mov	BYTE PTR [rax+189], cl
$LN22@Write:

; 332  :       }
; 333  :       break;

	jmp	$LN36@Write
$LN21@Write:

; 334  :     }
; 335  : 
; 336  :     case 0xFF1A:
; 337  :       nr30_ = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+97], cl

; 338  :       channel3.enabled = (nr30_&0x80)==0x80;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+97]
	and	eax, 128				; 00000080H
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN41@Write
	mov	DWORD PTR tv256[rsp], 1
	jmp	SHORT $LN42@Write
$LN41@Write:
	mov	DWORD PTR tv256[rsp], 0
$LN42@Write:
	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR tv256[rsp]
	mov	BYTE PTR [rax+227], cl

; 339  :       break;

	jmp	$LN36@Write
$LN20@Write:

; 340  :     case 0xFF1B:
; 341  :       nr31_ = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+98], cl

; 342  : 			channel3.lengthcounterload = 256 - data;

	movzx	eax, BYTE PTR data$[rsp]
	mov	ecx, 256				; 00000100H
	sub	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+224], al

; 343  :       break;

	jmp	$LN36@Write
$LN19@Write:

; 344  :     case 0xFF1C:
; 345  :       nr32_ = data;  

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+99], cl

; 346  :       switch ((nr32_ & 0x60)>>5) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+99]
	and	eax, 96					; 00000060H
	sar	eax, 5
	mov	DWORD PTR tv269[rsp], eax
	cmp	DWORD PTR tv269[rsp], 0
	je	SHORT $LN16@Write
	cmp	DWORD PTR tv269[rsp], 1
	je	SHORT $LN15@Write
	cmp	DWORD PTR tv269[rsp], 2
	je	SHORT $LN14@Write
	cmp	DWORD PTR tv269[rsp], 3
	je	SHORT $LN13@Write
	jmp	SHORT $LN17@Write
$LN16@Write:

; 347  :         case 0x0:channel3.vol = 0; break;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+208], xmm0
	jmp	SHORT $LN17@Write
$LN15@Write:

; 348  :         case 0x1:channel3.vol = 1.0f; break;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rax+208], xmm0
	jmp	SHORT $LN17@Write
$LN14@Write:

; 349  :         case 0x2:channel3.vol = 0.5f; break;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [rax+208], xmm0
	jmp	SHORT $LN17@Write
$LN13@Write:

; 350  :         case 0x3:channel3.vol = 0.25f; break;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [rax+208], xmm0
$LN17@Write:

; 351  :       }
; 352  :       break;

	jmp	$LN36@Write
$LN12@Write:

; 353  :     case 0xFF1D:
; 354  :       nr33_ = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+100], cl

; 355  :       break;

	jmp	$LN36@Write
$LN11@Write:

; 356  :     case 0xFF1E: {
; 357  :       nr34_ = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+101], cl

; 358  :       uint32_t x = nr33_;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+100]
	mov	DWORD PTR x$4[rsp], eax

; 359  :       x |= (nr34_&0x7)<<8;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+101]
	and	eax, 7
	shl	eax, 8
	mov	ecx, DWORD PTR x$4[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x$4[rsp], eax

; 360  : 			channel3.freqcounterload = 2048-x;

	mov	eax, 2048				; 00000800H
	sub	eax, DWORD PTR x$4[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+222], ax

; 361  :       //if (nr34_&0x40)
; 362  :         //channel3.soundlength_ms = 1000.0f * (256.0f-nr31_)*(1/256.0f);
; 363  :       if ((nr34_&0x80)&&(nr30_&0x80)) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+101]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	$LN10@Write
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+97]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	$LN10@Write

; 364  :         nr52_ |= 0x04;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+282]
	or	eax, 4
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+282], al

; 365  :         channel3.lengthcounter = channel3.lengthcounterload;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+224]
	mov	BYTE PTR [rax+225], cl

; 366  :         channel3.freqcounter = channel3.freqcounterload;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, WORD PTR [rcx+222]
	mov	WORD PTR [rax+220], cx

; 367  :         channel3.playback_counter = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+212], 0

; 368  :         channel3.enabled = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+227], 1

; 369  :         memset(&ioports[0x30],0,16);

	mov	eax, 1
	imul	rax, 48					; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+16]
	mov	r8d, 16
	xor	edx, edx
	mov	rcx, rax
	call	memset
$LN10@Write:

; 370  :       }
; 371  :       break;

	jmp	$LN36@Write
$LN9@Write:

; 372  :     }
; 373  : 
; 374  :     case 0xFF20:
; 375  :       nr41_.raw = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+134], cl

; 376  :       break;

	jmp	$LN36@Write
$LN8@Write:

; 377  :     case 0xFF21:
; 378  :       nr42_.raw = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+135], cl

; 379  :       break;

	jmp	$LN36@Write
$LN7@Write:

; 380  :     case 0xFF22:
; 381  :       nr43_ = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+136], cl

; 382  :       break;

	jmp	$LN36@Write
$LN6@Write:

; 383  :     case 0xFF23: {
; 384  :       nr44_ = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+137], cl

; 385  :       uint32_t x = nr43_;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	mov	DWORD PTR x$5[rsp], eax

; 386  :       x |= (nr44_&0x7)<<8;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	and	eax, 7
	shl	eax, 8
	mov	ecx, DWORD PTR x$5[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x$5[rsp], eax

; 387  :       float r = float(nr43_&0x7);

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	and	eax, 7
	cvtsi2ss xmm0, eax
	movss	DWORD PTR r$6[rsp], xmm0

; 388  :       float s = float((nr43_&0xF0)>>4);

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+136]
	and	eax, 240				; 000000f0H
	sar	eax, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR s$7[rsp], xmm0

; 389  :       channel4freq = 524288.0f/r/powf(2.0,s+1);

	movss	xmm0, DWORD PTR __real@49000000
	divss	xmm0, DWORD PTR r$6[rsp]
	movss	DWORD PTR tv349[rsp], xmm0
	movss	xmm1, DWORD PTR s$7[rsp]
	addss	xmm1, DWORD PTR __real@3f800000
	movss	xmm0, DWORD PTR __real@40000000
	call	QWORD PTR __imp_powf
	movss	xmm1, DWORD PTR tv349[rsp]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+264], xmm0

; 390  :       if (nr24_ & 0x80) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+96]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN5@Write

; 391  :         nr52_ |= 0x08;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+282]
	or	eax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+282], al

; 392  :         channel4envcounterms = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+268], xmm0

; 393  :         channel4polycounterms = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+272], xmm0

; 394  :         channel4soundlengthcounter = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+276], xmm0

; 395  :         channel4.envelope.raw = nr42_.raw;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+135]
	mov	BYTE PTR [rax+240], cl
$LN5@Write:

; 396  :       }
; 397  :       break;

	jmp	SHORT $LN36@Write
$LN4@Write:

; 398  :     }
; 399  : 
; 400  :     case 0xFF24:
; 401  :       nr50_.raw = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+280], cl

; 402  :       break;

	jmp	SHORT $LN36@Write
$LN3@Write:

; 403  :     case 0xFF25:
; 404  :       nr51_.raw = data;

	mov	rax, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax+281], cl

; 405  :       break;

	jmp	SHORT $LN36@Write
$LN2@Write:

; 406  :     case 0xFF26:
; 407  :       nr52_ = (data&0xF0) | (nr52_&0x0F);

	movzx	eax, BYTE PTR data$[rsp]
	and	eax, 240				; 000000f0H
	mov	rcx, QWORD PTR this$[rsp]
	movzx	ecx, BYTE PTR [rcx+282]
	and	ecx, 15
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+282], al

; 408  :       if ((nr52_&0x80)==0)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+282]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN1@Write

; 409  :         Reset();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+16]
$LN1@Write:
$LN36@Write:

; 410  :       break;
; 411  :  
; 412  :   }
; 413  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
	npad	3
$LN43@Write:
	DD	$LN35@Write
	DD	$LN31@Write
	DD	$LN30@Write
	DD	$LN29@Write
	DD	$LN28@Write
	DD	$LN36@Write
	DD	$LN26@Write
	DD	$LN25@Write
	DD	$LN24@Write
	DD	$LN23@Write
	DD	$LN21@Write
	DD	$LN20@Write
	DD	$LN19@Write
	DD	$LN12@Write
	DD	$LN11@Write
	DD	$LN36@Write
	DD	$LN9@Write
	DD	$LN8@Write
	DD	$LN7@Write
	DD	$LN6@Write
	DD	$LN4@Write
	DD	$LN3@Write
	DD	$LN2@Write
?Write@SoundController@gb@emulation@@QEAAXGE@Z ENDP	; emulation::gb::SoundController::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.cpp
_TEXT	SEGMENT
tv75 = 0
this$ = 32
address$ = 40
?Read@SoundController@gb@emulation@@QEAAEG@Z PROC	; emulation::gb::SoundController::Read

; 203  : uint8_t SoundController::Read(uint16_t address) {

$LN28:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 204  : 
; 205  :   if (address>=0xFF30 && address<=0xFF3F)

	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 65328				; 0000ff30H
	jl	SHORT $LN24@Read
	movzx	eax, WORD PTR address$[rsp]
	cmp	eax, 65343				; 0000ff3fH
	jg	SHORT $LN24@Read

; 206  :     return ioports[address-0xFF10];

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	movzx	eax, BYTE PTR [rcx+rax]
	jmp	$LN25@Read
$LN24@Read:

; 207  : 
; 208  :   switch (address) {

	movzx	eax, WORD PTR address$[rsp]
	mov	DWORD PTR tv75[rsp], eax
	mov	eax, DWORD PTR tv75[rsp]
	sub	eax, 65296				; 0000ff10H
	mov	DWORD PTR tv75[rsp], eax
	cmp	DWORD PTR tv75[rsp], 22
	ja	$LN22@Read
	movsxd	rax, DWORD PTR tv75[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN27@Read[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN21@Read:

; 209  :     case 0xFF10:
; 210  :       ioports[address-0xFF10] = nr10_.raw;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+88]
	mov	BYTE PTR [rcx+rax], dl
$LN20@Read:

; 211  :     case 0xFF11:
; 212  :       ioports[address-0xFF10] = nr11_.raw;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+89]
	mov	BYTE PTR [rcx+rax], dl
$LN19@Read:

; 213  :     case 0xFF12:
; 214  :       ioports[address-0xFF10] = nr12_.raw;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+90]
	mov	BYTE PTR [rcx+rax], dl
$LN18@Read:

; 215  :     case 0xFF13:
; 216  :       ioports[address-0xFF10] = nr13_;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+91]
	mov	BYTE PTR [rcx+rax], dl
$LN17@Read:

; 217  :     case 0xFF14:
; 218  :       ioports[address-0xFF10] = nr14_;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+92]
	mov	BYTE PTR [rcx+rax], dl
$LN16@Read:

; 219  :     case 0xFF16:
; 220  :       ioports[address-0xFF10] = nr21_.raw;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+93]
	mov	BYTE PTR [rcx+rax], dl
$LN15@Read:

; 221  :     case 0xFF17:
; 222  :       ioports[address-0xFF10] = nr22_.raw;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+94]
	mov	BYTE PTR [rcx+rax], dl
$LN14@Read:

; 223  :     case 0xFF18:
; 224  :       ioports[address-0xFF10] = nr23_;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+95]
	mov	BYTE PTR [rcx+rax], dl
$LN13@Read:

; 225  :     case 0xFF19:
; 226  :       ioports[address-0xFF10] = nr24_;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+96]
	mov	BYTE PTR [rcx+rax], dl
$LN12@Read:

; 227  : 
; 228  :     case 0xFF1A:
; 229  :       ioports[address-0xFF10] = nr30_;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+97]
	mov	BYTE PTR [rcx+rax], dl
$LN11@Read:

; 230  :     case 0xFF1B:
; 231  :       ioports[address-0xFF10] = nr31_;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+98]
	mov	BYTE PTR [rcx+rax], dl
$LN10@Read:

; 232  :     case 0xFF1C:
; 233  :       ioports[address-0xFF10] = nr32_;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+99]
	mov	BYTE PTR [rcx+rax], dl
$LN9@Read:

; 234  :     case 0xFF1D:
; 235  :       ioports[address-0xFF10] = nr33_;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+100]
	mov	BYTE PTR [rcx+rax], dl
$LN8@Read:

; 236  :     case 0xFF1E:
; 237  :       ioports[address-0xFF10] = nr34_;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+101]
	mov	BYTE PTR [rcx+rax], dl
$LN7@Read:

; 238  : 
; 239  :     case 0xFF20:
; 240  :       ioports[address-0xFF10] = nr41_.raw;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+134]
	mov	BYTE PTR [rcx+rax], dl
$LN6@Read:

; 241  :     case 0xFF21:
; 242  :       ioports[address-0xFF10] = nr42_.raw;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+135]
	mov	BYTE PTR [rcx+rax], dl
$LN5@Read:

; 243  :     case 0xFF22:
; 244  :       ioports[address-0xFF10] = nr43_;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+136]
	mov	BYTE PTR [rcx+rax], dl
$LN4@Read:

; 245  :     case 0xFF23:
; 246  :       ioports[address-0xFF10] = nr44_;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+137]
	mov	BYTE PTR [rcx+rax], dl
$LN3@Read:

; 247  : 
; 248  :     case 0xFF24:
; 249  :       ioports[address-0xFF10] = nr50_.raw;

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+280]
	mov	BYTE PTR [rcx+rax], dl
$LN2@Read:

; 250  :     case 0xFF25:
; 251  :       ioports[address-0xFF10] = nr51_.raw; 

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+281]
	mov	BYTE PTR [rcx+rax], dl
$LN1@Read:

; 252  :     case 0xFF26:
; 253  :       ioports[address-0xFF10] = nr52_; 

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR [rdx+282]
	mov	BYTE PTR [rcx+rax], dl
$LN22@Read:

; 254  :   }
; 255  : 	return ioports[address-0xFF10];

	movzx	eax, WORD PTR address$[rsp]
	sub	eax, 65296				; 0000ff10H
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	movzx	eax, BYTE PTR [rcx+rax]
$LN25@Read:

; 256  : }

	add	rsp, 16
	pop	rdi
	ret	0
	npad	2
$LN27@Read:
	DD	$LN21@Read
	DD	$LN20@Read
	DD	$LN19@Read
	DD	$LN18@Read
	DD	$LN17@Read
	DD	$LN22@Read
	DD	$LN16@Read
	DD	$LN15@Read
	DD	$LN14@Read
	DD	$LN13@Read
	DD	$LN12@Read
	DD	$LN11@Read
	DD	$LN10@Read
	DD	$LN9@Read
	DD	$LN8@Read
	DD	$LN22@Read
	DD	$LN7@Read
	DD	$LN6@Read
	DD	$LN5@Read
	DD	$LN4@Read
	DD	$LN3@Read
	DD	$LN2@Read
	DD	$LN1@Read
?Read@SoundController@gb@emulation@@QEAAEG@Z ENDP	; emulation::gb::SoundController::Read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.cpp
_TEXT	SEGMENT
envelopeTick$ = 36
sweep_time_ms$4 = 52
channel1_sample$5 = 56
channel2_sample$6 = 60
channel3_sample$7 = 64
channel4_sample$8 = 68
sample_left$9 = 72
sample_right$10 = 76
$T11 = 80
tv130 = 84
tv131 = 88
this$ = 112
dt$ = 120
?Step@SoundController@gb@emulation@@QEAAXN@Z PROC	; emulation::gb::SoundController::Step

; 72   : void SoundController::Step(double dt) {

$LN14:
	movsdx	QWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+112]

; 73   :   if ((nr52_&0x80)==0)

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+282]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN9@Step

; 74   :     return;

	jmp	$LN10@Step
$LN9@Step:

; 75   : 
; 76   : 
; 77   :   auto envelopeTick = [](VolumeEnvelope& envreg,real_t& counter){
; 78   :     float env_step_ms = envreg.env_sweep/64.0f*1000.0f;
; 79   : 
; 80   :     if (env_step_ms != 0 && counter >= env_step_ms) {
; 81   :         if (envreg.direction && envreg.vol<0xF)
; 82   :           ++envreg.vol;
; 83   :         if (!envreg.direction && envreg.vol>0)
; 84   :           --envreg.vol;
; 85   :       counter = 0;
; 86   :     }
; 87   :   };

	lea	rax, QWORD PTR $T11[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb

; 88   : 
; 89   : 
; 90   : 
; 91   :   if ((maincounter & 0x3) == 0) {// its like every 32/8 because 8 samples in duty cycle

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+138]
	and	eax, 3
	test	eax, eax
	jne	SHORT $LN8@Step

; 92   :       channel1.SampleTick();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 144				; 00000090H
	mov	rcx, rax
	call	?SampleTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAEXZ ; emulation::gb::SoundController::<unnamed-type-channel1>::SampleTick

; 93   : 			channel2.SampleTick();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 168				; 000000a8H
	mov	rcx, rax
	call	?SampleTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAEXZ ; emulation::gb::SoundController::<unnamed-type-channel2>::SampleTick
$LN8@Step:

; 94   :   }
; 95   : 
; 96   : 	if ((maincounter & 0x1) == 0) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+138]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN7@Step

; 97   :       channel3.SampleTick();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 192				; 000000c0H
	mov	rcx, rax
	call	?SampleTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAEXZ ; emulation::gb::SoundController::<unnamed-type-channel3>::SampleTick
$LN7@Step:

; 98   :   }
; 99   : 
; 100  : 	maincounter = (maincounter+1) & 0x1F;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+138]
	inc	eax
	and	eax, 31
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+138], al

; 101  : 
; 102  :   if (ulencounterclock++ == 16384) { //256hz from original cpu speed

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	mov	DWORD PTR tv130[rsp], eax
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+139]
	inc	al
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+139], al
	cmp	DWORD PTR tv130[rsp], 16384		; 00004000H
	jne	SHORT $LN12@Step
	mov	DWORD PTR tv131[rsp], 1
	jmp	SHORT $LN13@Step
$LN12@Step:
	mov	DWORD PTR tv131[rsp], 0
$LN13@Step:
	cmp	DWORD PTR tv131[rsp], 0
	je	SHORT $LN6@Step

; 103  : 		channel1.LengthTick();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 144				; 00000090H
	mov	rcx, rax
	call	?LengthTick@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXXZ ; emulation::gb::SoundController::<unnamed-type-channel1>::LengthTick

; 104  : 		channel2.LengthTick();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 168				; 000000a8H
	mov	rcx, rax
	call	?LengthTick@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXXZ ; emulation::gb::SoundController::<unnamed-type-channel2>::LengthTick

; 105  : 		channel3.LengthTick();

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 192				; 000000c0H
	mov	rcx, rax
	call	?LengthTick@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXXZ ; emulation::gb::SoundController::<unnamed-type-channel3>::LengthTick

; 106  : 		ulencounterclock = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+139], 0
$LN6@Step:

; 107  :   }
; 108  : 
; 109  :   //channel1
; 110  :   //if (nr14_ & 0x80)
; 111  :   {
; 112  :     channel1sweepcounterms += float(dt);

	cvtsd2ss xmm0, QWORD PTR dt$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+248]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+248], xmm0

; 113  :     real_t sweep_time_ms = nr10_.sweep_time *7.8f;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+88]
	shr	al, 4
	and	al, 7
	movzx	eax, al
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@40f9999a
	movss	DWORD PTR sweep_time_ms$4[rsp], xmm0

; 114  :     if (channel1sweepcounterms >= sweep_time_ms) {

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR [rax+248]
	comiss	xmm0, DWORD PTR sweep_time_ms$4[rsp]
	jb	SHORT $LN5@Step

; 115  :       //channel1freq = channel1freq + channel1freqsweep;
; 116  :       channel1sweepcounterms = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+248], xmm0
$LN5@Step:

; 117  :     }
; 118  :     //X(t) = X(t-1) +/- X(t-1)/2^n
; 119  : 
; 120  :     channel1envcounterms += float(dt);

	cvtsd2ss xmm0, QWORD PTR dt$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+256]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+256], xmm0

; 121  :     envelopeTick(channel1.envelope,channel1envcounterms);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 256				; 00000100H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 156				; 0000009cH
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR envelopeTick$[rsp]
	call	??R<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z ; <lambda_3ece7da5f758d55a88d025c1273884e8>::operator()

; 122  : 
; 123  : 
; 124  :   }
; 125  : 
; 126  :   //channel2
; 127  :   //if (nr24_ & 0x80)
; 128  :   {
; 129  :     channel2envcounterms += float(dt);

	cvtsd2ss xmm0, QWORD PTR dt$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+260]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+260], xmm0

; 130  :     envelopeTick(channel2.envelope,channel2envcounterms);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 260				; 00000104H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 168				; 000000a8H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR envelopeTick$[rsp]
	call	??R<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z ; <lambda_3ece7da5f758d55a88d025c1273884e8>::operator()

; 131  : 
; 132  :   }
; 133  :   
; 134  :   //channel3
; 135  :   //real_t wavsample = 0;
; 136  :  // static int wavindex = 0;
; 137  :   {
; 138  :     //static real_t wavsamplecount = 0;
; 139  :     //channel3.Tick(float(dt));
; 140  : 
; 141  :   }
; 142  : 
; 143  :   //channel4
; 144  :  // real_t noisesample = 0;
; 145  :   //if (nr44_ & 0x80)
; 146  :   {
; 147  : 
; 148  :     //channel4polycounterms += float(dt);
; 149  :     //static bool alt = false;
; 150  :     //real_t noisetimems = 1000.0f/channel4freq;
; 151  :     //if (channel4polycounterms >= noisetimems) {
; 152  :       //noisesample = (alt*(rand()%255))/255.0f;
; 153  :    //   alt = !alt;
; 154  :    //   channel4polycounterms = 0;
; 155  :    // }
; 156  :     channel4envcounterms += float(dt);

	cvtsd2ss xmm0, QWORD PTR dt$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+268]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+268], xmm0

; 157  :     envelopeTick(channel4.envelope,channel4envcounterms);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 268				; 0000010cH
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, 240				; 000000f0H
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR envelopeTick$[rsp]
	call	??R<lambda_3ece7da5f758d55a88d025c1273884e8>@@QEBAXAEATVolumeEnvelope@gb@emulation@@AEAM@Z ; <lambda_3ece7da5f758d55a88d025c1273884e8>::operator()

; 158  : 
; 159  :     channel4soundlengthcounter += float(dt);

	cvtsd2ss xmm0, QWORD PTR dt$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+276]
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+276], xmm0

; 160  :     if (nr44_ & 0x40) {

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN4@Step

; 161  :       if (channel4soundlengthcounter >= nr41_.soundlength_ms()) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 134				; 00000086H
	mov	rcx, rax
	call	?soundlength_ms@SoundLengthWaveDutyRegister@gb@emulation@@QEAAMXZ ; emulation::gb::SoundLengthWaveDutyRegister::soundlength_ms
	mov	rax, QWORD PTR this$[rsp]
	movss	xmm1, DWORD PTR [rax+276]
	comiss	xmm1, xmm0
	jb	SHORT $LN3@Step

; 162  :         nr44_ &= ~0x80;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+137]
	btr	eax, 7
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+137], al
$LN3@Step:
$LN4@Step:

; 163  :       }
; 164  :     }
; 165  :   }
; 166  : 
; 167  :   ++sample_counter;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+32]
	inc	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 168  :   if (sample_counter >= sample_ratio)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	cmp	DWORD PTR [rax+32], ecx
	jb	$LN2@Step

; 169  :   {
; 170  : 
; 171  :     //osc1.Tick(osc1.get_increment(channel1freq))* (channel1env.vol / 15.0f);//
; 172  :     auto channel1_sample = ((channel1.sample) * (channel1.envelope.vol / 15.0f));

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+161]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+156]
	shr	al, 4
	and	al, 15
	movzx	eax, al
	cvtsi2ss xmm1, eax
	divss	xmm1, DWORD PTR __real@41700000
	mulss	xmm0, xmm1
	movss	DWORD PTR channel1_sample$5[rsp], xmm0

; 173  :     auto channel2_sample = ((channel2.sample) * (channel2.envelope.vol / 15.0f));//osc2.Tick(osc2.get_increment(channel2freq)) * (channel2env.vol / 15.0f);

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+190]
	cvtsi2ss xmm0, eax
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+168]
	shr	al, 4
	and	al, 15
	movzx	eax, al
	cvtsi2ss xmm1, eax
	divss	xmm1, DWORD PTR __real@41700000
	mulss	xmm0, xmm1
	movss	DWORD PTR channel2_sample$6[rsp], xmm0

; 174  : 
; 175  :     auto channel3_sample = channel3.sample / 15.0f; 

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+226]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR channel3_sample$7[rsp], xmm0

; 176  : 		channel3_sample = (channel3_sample)*channel3.vol;

	mov	rax, QWORD PTR this$[rsp]
	movss	xmm0, DWORD PTR channel3_sample$7[rsp]
	mulss	xmm0, DWORD PTR [rax+208]
	movss	DWORD PTR channel3_sample$7[rsp], xmm0

; 177  : 
; 178  :     auto channel4_sample = 0;//noise.Tick(osc2.get_increment(channel4freq)) * (channel4env.vol / 15.0f);

	mov	DWORD PTR channel4_sample$8[rsp], 0

; 179  :     //wavsamplecount = 0;
; 180  :     auto sample_left = ((nr51_.ch1so1 * channel1_sample)+(nr51_.ch2so1 * channel2_sample)+(nr51_.ch3so1 * channel3_sample)+(nr51_.ch4so1 * channel4_sample));

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+281]
	and	al, 1
	movzx	eax, al
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR channel1_sample$5[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+281]
	shr	al, 1
	and	al, 1
	movzx	eax, al
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR channel2_sample$6[rsp]
	addss	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+281]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR channel3_sample$7[rsp]
	addss	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+281]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	imul	eax, DWORD PTR channel4_sample$8[rsp]
	cvtsi2ss xmm1, eax
	addss	xmm0, xmm1
	movss	DWORD PTR sample_left$9[rsp], xmm0

; 181  :     auto sample_right = ((nr51_.ch1so2 * channel1_sample)+(nr51_.ch2so2 * channel2_sample)+(nr51_.ch3so2 * channel3_sample)+(nr51_.ch4so2 * channel4_sample));

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+281]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR channel1_sample$5[rsp]
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+281]
	shr	al, 5
	and	al, 1
	movzx	eax, al
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR channel2_sample$6[rsp]
	addss	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+281]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR channel3_sample$7[rsp]
	addss	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+281]
	shr	al, 7
	and	al, 1
	movzx	eax, al
	imul	eax, DWORD PTR channel4_sample$8[rsp]
	cvtsi2ss xmm1, eax
	addss	xmm0, xmm1
	movss	DWORD PTR sample_right$10[rsp], xmm0

; 182  : 		
; 183  : 		sample_left = ((sample_left*2.0f)-1) * 0.25f * 32767.0f;

	movss	xmm0, DWORD PTR sample_left$9[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@3e800000
	mulss	xmm0, DWORD PTR __real@46fffe00
	movss	DWORD PTR sample_left$9[rsp], xmm0

; 184  : 		sample_right = ((sample_right*2.0f)-1) * 0.25f * 32767.0f;

	movss	xmm0, DWORD PTR sample_right$10[rsp]
	mulss	xmm0, DWORD PTR __real@40000000
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@3e800000
	mulss	xmm0, DWORD PTR __real@46fffe00
	movss	DWORD PTR sample_right$10[rsp], xmm0

; 185  :     sample_left *= nr50_.so1vol / 7.0f;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+280]
	and	al, 7
	movzx	eax, al
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@40e00000
	movss	xmm1, DWORD PTR sample_left$9[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR sample_left$9[rsp], xmm0

; 186  :     sample_right *= nr50_.so2vol / 7.0f;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+280]
	shr	al, 4
	and	al, 7
	movzx	eax, al
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@40e00000
	movss	xmm1, DWORD PTR sample_right$10[rsp]
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR sample_right$10[rsp], xmm0

; 187  : 
; 188  :     static short sbuf[8820]= {0,0};
; 189  :     static int sindex = 0;
; 190  :     sbuf[sindex++] = short(sample_left);

	cvttss2si eax, DWORD PTR sample_left$9[rsp]
	movsxd	rcx, DWORD PTR ?sindex@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4HA
	lea	rdx, OFFSET FLAT:?sbuf@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4PAFA
	mov	WORD PTR [rdx+rcx*2], ax
	mov	eax, DWORD PTR ?sindex@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4HA
	inc	eax
	mov	DWORD PTR ?sindex@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4HA, eax

; 191  :     sbuf[sindex++] = short(sample_right); 

	cvttss2si eax, DWORD PTR sample_right$10[rsp]
	movsxd	rcx, DWORD PTR ?sindex@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4HA
	lea	rdx, OFFSET FLAT:?sbuf@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4PAFA
	mov	WORD PTR [rdx+rcx*2], ax
	mov	eax, DWORD PTR ?sindex@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4HA
	inc	eax
	mov	DWORD PTR ?sindex@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4HA, eax

; 192  :     sample_counter -= sample_ratio;   

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	eax, DWORD PTR [rax+32]
	sub	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 193  : 
; 194  :     if (sindex == 8820) {

	cmp	DWORD PTR ?sindex@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4HA, 8820 ; 00002274H
	jne	SHORT $LN1@Step

; 195  :       output->Write(sbuf,8820<<1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax]
	mov	r8d, 17640				; 000044e8H
	lea	rdx, OFFSET FLAT:?sbuf@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4PAFA
	call	QWORD PTR [rax+48]

; 196  :       sindex = 0;

	mov	DWORD PTR ?sindex@?CF@??Step@SoundController@gb@emulation@@QEAAXN@Z@4HA, 0
$LN1@Step:
$LN2@Step:
$LN10@Step:

; 197  :     }
; 198  :   }
; 199  : 
; 200  :   
; 201  : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:?Step@SoundController@gb@emulation@@QEAAXN@Z$rtcFrameData
	call	_RTC_CheckStackVars
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
?Step@SoundController@gb@emulation@@QEAAXN@Z ENDP	; emulation::gb::SoundController::Step
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.cpp
_TEXT	SEGMENT
this$ = 48
?Reset@SoundController@gb@emulation@@UEAAXXZ PROC	; emulation::gb::SoundController::Reset

; 32   : void SoundController::Reset() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 33   :   channel1sweepcounterms = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+248], xmm0

; 34   :   channel1freqsweep = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+252], xmm0

; 35   :   channel1envcounterms = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+256], xmm0

; 36   :   channel2envcounterms = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+260], xmm0

; 37   : 
; 38   :   
; 39   :   channel4freq = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+264], xmm0

; 40   :   channel4envcounterms = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+268], xmm0

; 41   :   channel4polycounterms = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+272], xmm0

; 42   :   channel4soundlengthcounter = 0;

	mov	rax, QWORD PTR this$[rsp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [rax+276], xmm0

; 43   :  
; 44   :   channel1.Initialize(this);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 144				; 00000090H
	mov	rdx, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?Initialize@<unnamed-type-channel1>@SoundController@gb@emulation@@QEAAXPEAV234@@Z ; emulation::gb::SoundController::<unnamed-type-channel1>::Initialize

; 45   : 	channel2.Initialize(this);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 168				; 000000a8H
	mov	rdx, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?Initialize@<unnamed-type-channel2>@SoundController@gb@emulation@@QEAAXPEAV234@@Z ; emulation::gb::SoundController::<unnamed-type-channel2>::Initialize

; 46   :   channel3.Initialize(this);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 192				; 000000c0H
	mov	rdx, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?Initialize@<unnamed-type-channel3>@SoundController@gb@emulation@@QEAAXPEAV234@@Z ; emulation::gb::SoundController::<unnamed-type-channel3>::Initialize

; 47   : 	channel4.Initialize(this);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 232				; 000000e8H
	mov	rdx, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?Initialize@<unnamed-type-channel4>@SoundController@gb@emulation@@QEAAXPEAV234@@Z ; emulation::gb::SoundController::<unnamed-type-channel4>::Initialize

; 48   :   
; 49   :   nr10_.raw = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+88], 0

; 50   :   nr11_.raw = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+89], 0

; 51   :   nr12_.raw = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+90], 0

; 52   :   nr13_ = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+91], 0

; 53   :   nr14_ = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+92], 0

; 54   :   nr21_.raw = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+93], 0

; 55   :   nr22_.raw = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+94], 0

; 56   :   nr23_ = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+95], 0

; 57   :   nr24_ = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+96], 0

; 58   :   nr30_ = nr31_ = nr32_ = nr33_ = nr34_ = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+101], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+100], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+99], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+98], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+97], 0

; 59   :   memset(wavram,0,sizeof(wavram));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 102				; 00000066H
	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 60   : 
; 61   :   nr41_.raw = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+134], 0

; 62   :   nr42_.raw = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+135], 0

; 63   :   nr43_ = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+136], 0

; 64   :   nr44_ = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+137], 0

; 65   : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Reset@SoundController@gb@emulation@@UEAAXXZ ENDP	; emulation::gb::SoundController::Reset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.cpp
_TEXT	SEGMENT
this$ = 48
?Deinitialize@SoundController@gb@emulation@@UEAAXXZ PROC ; emulation::gb::SoundController::Deinitialize

; 67   : void SoundController::Deinitialize() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 68   :   output->Deinitialize(); 

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax]
	call	QWORD PTR [rax+8]

; 69   :   SafeDelete(&output);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??$SafeDelete@VInterface@output@audio@@@@YAXPEAPEAVInterface@output@audio@@@Z ; SafeDelete<audio::output::Interface>

; 70   : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Deinitialize@SoundController@gb@emulation@@UEAAXXZ ENDP ; emulation::gb::SoundController::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.cpp
_TEXT	SEGMENT
t$ = 40
$T4 = 56
$T5 = 64
$T6 = 72
tv129 = 80
this$ = 112
emu$ = 120
?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z PROC ; emulation::gb::SoundController::Initialize

; 11   : void SoundController::Initialize(Emu* emu) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rdi, rsp
	mov	ecx, 24
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+112]
	mov	QWORD PTR $T6[rsp], -2

; 12   :   Component::Initialize(emu);

	mov	rdx, QWORD PTR emu$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z ; emulation::gb::Component::Initialize

; 13   : 	ioports = emu_->memory()->ioports();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?memory@Emu@gb@emulation@@QEAAPEAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	rcx, rax
	call	?ioports@Memory@gb@emulation@@QEAAPEAEXZ ; emulation::gb::Memory::ioports
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 14   :   output = new audio::output::DirectSound();

	mov	r9d, 14
	lea	r8, OFFSET FLAT:$SG113694
	mov	edx, 1
	mov	ecx, 104				; 00000068H
	call	??2@YAPEAX_KHPEBDH@Z			; operator new
	mov	QWORD PTR $T5[rsp], rax
	cmp	QWORD PTR $T5[rsp], 0
	je	SHORT $LN3@Initialize
	mov	rcx, QWORD PTR $T5[rsp]
	call	??0DirectSound@output@audio@@QEAA@XZ	; audio::output::DirectSound::DirectSound
	mov	QWORD PTR tv129[rsp], rax
	jmp	SHORT $LN4@Initialize
$LN3@Initialize:
	mov	QWORD PTR tv129[rsp], 0
$LN4@Initialize:
	mov	rax, QWORD PTR tv129[rsp]
	mov	QWORD PTR $T4[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR $T4[rsp]
	mov	QWORD PTR [rax+24], rcx

; 15   :   output->Initialize(44100,2,16);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, QWORD PTR [rax]
	mov	r9b, 16
	mov	r8b, 2
	mov	edx, 44100				; 0000ac44H
	call	QWORD PTR [rax]

; 16   :   sample_counter = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+32], 0

; 17   :   sample_ratio = uint32_t(clockspeed / 44100);

	movsdx	xmm0, QWORD PTR clockspeed
	divsd	xmm0, QWORD PTR __real@40e5888000000000
	cvttsd2si rax, xmm0
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 18   :   noise.set_sample_rate(44100);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	edx, 44100				; 0000ac44H
	mov	rcx, rax
	call	?set_sample_rate@Component@synth@audio@@QEAAXI@Z ; audio::synth::Component::set_sample_rate

; 19   :   nr50_.raw = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+280], 0

; 20   :   nr51_.raw = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+281], 0

; 21   :   nr52_ = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+282], 0

; 22   :   maincounter = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+138], 0

; 23   :   ulencounterclock = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+139], 0

; 24   :   time_t t;
; 25   :   time(&t);

	lea	rcx, QWORD PTR t$[rsp]
	call	time

; 26   :   srand((int)t);

	mov	ecx, DWORD PTR t$[rsp]
	call	QWORD PTR __imp_srand

; 27   : 
; 28   :   audio::synth::noiseseed = rand();

	call	QWORD PTR __imp_rand
	mov	DWORD PTR ?noiseseed@synth@audio@@3IA, eax ; audio::synth::noiseseed

; 29   :   Reset();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+16]

; 30   : }

	mov	rcx, rsp
	lea	rdx, OFFSET FLAT:?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z$rtcFrameData
	call	_RTC_CheckStackVars
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
?Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z ENDP ; emulation::gb::SoundController::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
text$x	SEGMENT
t$ = 40
$T4 = 56
$T5 = 64
$T6 = 72
tv129 = 80
this$ = 112
emu$ = 120
?dtor$0@?0??Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z@4HA PROC ; `emulation::gb::SoundController::Initialize'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
	mov	r9d, 14
	lea	r8, OFFSET FLAT:$SG113695
	mov	edx, 1
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAXHPEBDH@Z			; operator delete
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0??Initialize@SoundController@gb@emulation@@UEAAXPEAVEmu@23@@Z@4HA ENDP ; `emulation::gb::SoundController::Initialize'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\sound_controller.h
;	COMDAT ?soundlength_ms@SoundLengthWaveDutyRegister@gb@emulation@@QEAAMXZ
_TEXT	SEGMENT
this$ = 32
?soundlength_ms@SoundLengthWaveDutyRegister@gb@emulation@@QEAAMXZ PROC ; emulation::gb::SoundLengthWaveDutyRegister::soundlength_ms, COMDAT

; 34   :  real_t soundlength_ms() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+32]

; 35   :    return 1000.0f*(64-soundlength)*(1.0f/256.0f) ;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	al, 63					; 0000003fH
	movzx	eax, al
	mov	ecx, 64					; 00000040H
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR __real@447a0000
	mulss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3b800000

; 36   :  }

	add	rsp, 16
	pop	rdi
	ret	0
?soundlength_ms@SoundLengthWaveDutyRegister@gb@emulation@@QEAAMXZ ENDP ; emulation::gb::SoundLengthWaveDutyRegister::soundlength_ms
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\audio\synth\quadrangular_wave.h
;	COMDAT ?set_sample_rate@Component@synth@audio@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 16
sample_rate$ = 24
?set_sample_rate@Component@synth@audio@@QEAAXI@Z PROC	; audio::synth::Component::set_sample_rate, COMDAT

; 73   :   void set_sample_rate(uint32_t sample_rate) { 

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 74   :     sample_rate_ = sample_rate; 

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR sample_rate$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 75   :     sample_time_ms_ = (1000.0f/sample_rate_);

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+12]
	cvtsi2ss xmm0, rax
	movss	xmm1, DWORD PTR __real@447a0000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR this$[rsp]
	movss	DWORD PTR [rax+8], xmm0

; 76   :   }

	pop	rdi
	ret	0
?set_sample_rate@Component@synth@audio@@QEAAXI@Z ENDP	; audio::synth::Component::set_sample_rate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?ioports@Memory@gb@emulation@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 16
?ioports@Memory@gb@emulation@@QEAAPEAEXZ PROC		; emulation::gb::Memory::ioports, COMDAT

; 19   :   uint8_t* ioports() { return ioports_; }

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 208				; 000000d0H
	pop	rdi
	ret	0
?ioports@Memory@gb@emulation@@QEAAPEAEXZ ENDP		; emulation::gb::Memory::ioports
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\gb.h
;	COMDAT ?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z
_TEXT	SEGMENT
this$ = 16
emu$ = 24
?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z PROC ; emulation::gb::Component::Initialize, COMDAT

; 28   :   virtual void Initialize(Emu* emu) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 29   :     emu_ = emu;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR emu$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 30   :   }

	pop	rdi
	ret	0
?Initialize@Component@gb@emulation@@UEAAXPEAVEmu@23@@Z ENDP ; emulation::gb::Component::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 132  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+48]

; 133  :     return _time64(_Time);

	mov	rcx, QWORD PTR _Time$[rsp]
	call	QWORD PTR __imp__time64

; 134  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$yc	SEGMENT
$T1 = 0
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 137  : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	add	rsp, 16
	pop	rdi
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$yc	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 130  : const _Ignore ignore;

	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rsp
	mov	ecx, 8
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:ignore
	call	??0_Ignore@std@@QEAA@XZ			; std::_Ignore::_Ignore
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0_Ignore@std@@QEAA@XZ PROC				; std::_Ignore::_Ignore, COMDAT

; 120  : 	_Ignore()

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi

; 121  : 		{	// construct
; 122  : 		}

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0_Ignore@std@@QEAA@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = 0
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	add	rsp, 16
	pop	rdi
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = 0
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	rdi
	sub	rsp, 16
	mov	rdi, rsp
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	add	rsp, 16
	pop	rdi
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
