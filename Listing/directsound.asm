; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

	TITLE	C:\Users\Khalid\Documents\GitHub\GBEmu\Solution\Code\audio2\directsound.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??0Interface@output@audio@@QAE@XZ		; audio::output::Interface::Interface
PUBLIC	??0DirectSound@output@audio@@QAE@XZ		; audio::output::DirectSound::DirectSound
PUBLIC	??1DirectSound@output@audio@@QAE@XZ		; audio::output::DirectSound::~DirectSound
PUBLIC	?Initialize@DirectSound@output@audio@@UAEHIEE@Z	; audio::output::DirectSound::Initialize
PUBLIC	?Deinitialize@DirectSound@output@audio@@UAEHXZ	; audio::output::DirectSound::Deinitialize
PUBLIC	?Play@DirectSound@output@audio@@UAEHXZ		; audio::output::DirectSound::Play
PUBLIC	?Stop@DirectSound@output@audio@@UAEHXZ		; audio::output::DirectSound::Stop
PUBLIC	?GetBytesBuffered@DirectSound@output@audio@@UAEIXZ ; audio::output::DirectSound::GetBytesBuffered
PUBLIC	?GetCursors@DirectSound@output@audio@@UAEXAAI0@Z ; audio::output::DirectSound::GetCursors
PUBLIC	?Write@DirectSound@output@audio@@UAEHPAXI@Z	; audio::output::DirectSound::Write
PUBLIC	?BeginWrite@DirectSound@output@audio@@UAEHAAI@Z	; audio::output::DirectSound::BeginWrite
PUBLIC	?EndWrite@DirectSound@output@audio@@UAEHPAX@Z	; audio::output::DirectSound::EndWrite
PUBLIC	??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z ; SafeRelease<IDirectSoundBuffer>
PUBLIC	??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z ; SafeRelease<IDirectSound8>
PUBLIC	??_7Interface@output@audio@@6B@			; audio::output::Interface::`vftable'
PUBLIC	??_7DirectSound@output@audio@@6B@		; audio::output::DirectSound::`vftable'
PUBLIC	??_R4Interface@output@audio@@6B@		; audio::output::Interface::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVInterface@output@audio@@@8		; audio::output::Interface `RTTI Type Descriptor'
PUBLIC	??_R3Interface@output@audio@@8			; audio::output::Interface::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Interface@output@audio@@8			; audio::output::Interface::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Interface@output@audio@@8		; audio::output::Interface::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4DirectSound@output@audio@@6B@		; audio::output::DirectSound::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDirectSound@output@audio@@@8		; audio::output::DirectSound `RTTI Type Descriptor'
PUBLIC	??_R3DirectSound@output@audio@@8		; audio::output::DirectSound::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DirectSound@output@audio@@8		; audio::output::DirectSound::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DirectSound@output@audio@@8	; audio::output::DirectSound::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3fd999999999999a
PUBLIC	__real@46feb000
PUBLIC	__real@47000000
PUBLIC	__real@c6feb000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__purecall:PROC
EXTRN	_memset:PROC
EXTRN	_DirectSoundCreate8@12:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	_DSDEVID_DefaultPlayback:BYTE
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c6feb000
CONST	SEGMENT
__real@c6feb000 DD 0c6feb000r			; -32600
CONST	ENDS
;	COMDAT __real@47000000
CONST	SEGMENT
__real@47000000 DD 047000000r			; 32768
CONST	ENDS
;	COMDAT __real@46feb000
CONST	SEGMENT
__real@46feb000 DD 046feb000r			; 32600
CONST	ENDS
;	COMDAT __real@3fd999999999999a
CONST	SEGMENT
__real@3fd999999999999a DQ 03fd999999999999ar	; 0.4
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@DirectSound@output@audio@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DirectSound@output@audio@@8 DD FLAT:??_R0?AVDirectSound@output@audio@@@8 ; audio::output::DirectSound::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DirectSound@output@audio@@8
rdata$r	ENDS
;	COMDAT ??_R2DirectSound@output@audio@@8
rdata$r	SEGMENT
??_R2DirectSound@output@audio@@8 DD FLAT:??_R1A@?0A@EA@DirectSound@output@audio@@8 ; audio::output::DirectSound::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Interface@output@audio@@8
rdata$r	ENDS
;	COMDAT ??_R3DirectSound@output@audio@@8
rdata$r	SEGMENT
??_R3DirectSound@output@audio@@8 DD 00H			; audio::output::DirectSound::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2DirectSound@output@audio@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDirectSound@output@audio@@@8
_DATA	SEGMENT
??_R0?AVDirectSound@output@audio@@@8 DD FLAT:??_7type_info@@6B@ ; audio::output::DirectSound `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDirectSound@output@audio@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DirectSound@output@audio@@6B@
rdata$r	SEGMENT
??_R4DirectSound@output@audio@@6B@ DD 00H		; audio::output::DirectSound::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDirectSound@output@audio@@@8
	DD	FLAT:??_R3DirectSound@output@audio@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Interface@output@audio@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Interface@output@audio@@8 DD FLAT:??_R0?AVInterface@output@audio@@@8 ; audio::output::Interface::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Interface@output@audio@@8
rdata$r	ENDS
;	COMDAT ??_R2Interface@output@audio@@8
rdata$r	SEGMENT
??_R2Interface@output@audio@@8 DD FLAT:??_R1A@?0A@EA@Interface@output@audio@@8 ; audio::output::Interface::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Interface@output@audio@@8
rdata$r	SEGMENT
??_R3Interface@output@audio@@8 DD 00H			; audio::output::Interface::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Interface@output@audio@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVInterface@output@audio@@@8
_DATA	SEGMENT
??_R0?AVInterface@output@audio@@@8 DD FLAT:??_7type_info@@6B@ ; audio::output::Interface `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVInterface@output@audio@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Interface@output@audio@@6B@
rdata$r	SEGMENT
??_R4Interface@output@audio@@6B@ DD 00H			; audio::output::Interface::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVInterface@output@audio@@@8
	DD	FLAT:??_R3Interface@output@audio@@8
rdata$r	ENDS
;	COMDAT ??_7DirectSound@output@audio@@6B@
CONST	SEGMENT
??_7DirectSound@output@audio@@6B@ DD FLAT:??_R4DirectSound@output@audio@@6B@ ; audio::output::DirectSound::`vftable'
	DD	FLAT:?Initialize@DirectSound@output@audio@@UAEHIEE@Z
	DD	FLAT:?Deinitialize@DirectSound@output@audio@@UAEHXZ
	DD	FLAT:?Play@DirectSound@output@audio@@UAEHXZ
	DD	FLAT:?Stop@DirectSound@output@audio@@UAEHXZ
	DD	FLAT:?GetBytesBuffered@DirectSound@output@audio@@UAEIXZ
	DD	FLAT:?GetCursors@DirectSound@output@audio@@UAEXAAI0@Z
	DD	FLAT:?Write@DirectSound@output@audio@@UAEHPAXI@Z
	DD	FLAT:?BeginWrite@DirectSound@output@audio@@UAEHAAI@Z
	DD	FLAT:?EndWrite@DirectSound@output@audio@@UAEHPAX@Z
CONST	ENDS
;	COMDAT ??_7Interface@output@audio@@6B@
CONST	SEGMENT
??_7Interface@output@audio@@6B@ DD FLAT:??_R4Interface@output@audio@@6B@ ; audio::output::Interface::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio2\directsound.cpp
_TEXT	SEGMENT
_v$1 = -12						; size = 4
_i$2 = -8						; size = 4
_dests$ = -4						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_nsamples$ = 16						; size = 4
?clamp@output@audio@@YAXPAXPBMH@Z PROC			; audio::output::clamp

; 263  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 264  :   int16_t *dests = (int16_t *)dest;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dests$[ebp], eax

; 265  : 
; 266  :   for (int32_t i=0; i < nsamples; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN5@clamp
$LN4@clamp:
	mov	ecx, DWORD PTR _i$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$2[ebp], ecx
$LN5@clamp:
	mov	edx, DWORD PTR _i$2[ebp]
	cmp	edx, DWORD PTR _nsamples$[ebp]
	jge	SHORT $LN3@clamp

; 267  :   {
; 268  :     float v = src[i] * 32768.0f;

	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	mulss	xmm0, DWORD PTR __real@47000000
	movss	DWORD PTR _v$1[ebp], xmm0

; 269  :     if (v >  32600.0f) v =  32600.0f;

	movss	xmm0, DWORD PTR _v$1[ebp]
	comiss	xmm0, DWORD PTR __real@46feb000
	jbe	SHORT $LN2@clamp
	movss	xmm0, DWORD PTR __real@46feb000
	movss	DWORD PTR _v$1[ebp], xmm0
$LN2@clamp:

; 270  :     if (v < -32600.0f) v = -32600.0f;

	movss	xmm0, DWORD PTR __real@c6feb000
	comiss	xmm0, DWORD PTR _v$1[ebp]
	jbe	SHORT $LN1@clamp
	movss	xmm0, DWORD PTR __real@c6feb000
	movss	DWORD PTR _v$1[ebp], xmm0
$LN1@clamp:

; 271  :     dests[i] = (int16_t)v;

	cvttss2si edx, DWORD PTR _v$1[ebp]
	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _dests$[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 272  :   }

	jmp	SHORT $LN4@clamp
$LN3@clamp:

; 273  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?clamp@output@audio@@YAXPAXPBMH@Z ENDP			; audio::output::clamp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\wincore\types.h
;	COMDAT ??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z
_TEXT	SEGMENT
_ppInterfaceToRelease$ = 8				; size = 4
??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z PROC ; SafeRelease<IDirectSound8>, COMDAT

; 27   : inline void SafeRelease(Interface **ppInterfaceToRelease) {

	push	ebp
	mov	ebp, esp
	push	esi

; 28   :     if (*ppInterfaceToRelease != NULL) {

	mov	eax, DWORD PTR _ppInterfaceToRelease$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SafeReleas

; 29   :         (*ppInterfaceToRelease)->Release();

	mov	ecx, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 30   :         (*ppInterfaceToRelease) = NULL;

	mov	ecx, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	DWORD PTR [ecx], 0
$LN2@SafeReleas:

; 31   :     }
; 32   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z ENDP ; SafeRelease<IDirectSound8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\wincore\types.h
;	COMDAT ??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z
_TEXT	SEGMENT
_ppInterfaceToRelease$ = 8				; size = 4
??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z PROC ; SafeRelease<IDirectSoundBuffer>, COMDAT

; 27   : inline void SafeRelease(Interface **ppInterfaceToRelease) {

	push	ebp
	mov	ebp, esp
	push	esi

; 28   :     if (*ppInterfaceToRelease != NULL) {

	mov	eax, DWORD PTR _ppInterfaceToRelease$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SafeReleas

; 29   :         (*ppInterfaceToRelease)->Release();

	mov	ecx, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 30   :         (*ppInterfaceToRelease) = NULL;

	mov	ecx, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	DWORD PTR [ecx], 0
$LN2@SafeReleas:

; 31   :     }
; 32   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z ENDP ; SafeRelease<IDirectSoundBuffer>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio2\directsound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_data_pointer$ = 8					; size = 4
?EndWrite@DirectSound@output@audio@@UAEHPAX@Z PROC	; audio::output::DirectSound::EndWrite
; _this$ = ecx

; 276  : int DirectSound::EndWrite(void* data_pointer) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 
; 278  :   /*auto dest_buf=(uint8_t*)buf1;
; 279  :   auto dw=len1;
; 280  : 
; 281  :   auto src_buf=(float*)data_pointer;
; 282  :   while (dw) { 
; 283  :     float v = *src_buf++;
; 284  :     v *= 32768.0f; // * vol;
; 285  :     if (v >  32600.0f) v =  32600.0f;
; 286  :     if (v < -32600.0f) v = -32600.0f;
; 287  :     *dest_buf++ = (short)v;
; 288  :     dw--;
; 289  :   }
; 290  : 
; 291  :   if(buf2)  {
; 292  :     dest_buf=(uint8_t*)buf2;
; 293  :     dw=len2;
; 294  :     while(dw) {
; 295  :       float v = *src_buf++;
; 296  :       v *= 32768.0f; // * vol;
; 297  :       if (v >  32600.0f) v =  32600.0f;
; 298  :       if (v < -32600.0f) v = -32600.0f;
; 299  :       *dest_buf++ = (short)v;
; 300  :     dw--;
; 301  :     }
; 302  :   }*/
; 303  : 
; 304  :     if (buf1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN4@EndWrite

; 305  :       clamp(buf1, (float*)data_pointer, len1/2);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	shr	edx, 1
	push	edx
	mov	eax, DWORD PTR _data_pointer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?clamp@output@audio@@YAXPAXPBMH@Z	; audio::output::clamp
	add	esp, 12					; 0000000cH
$LN4@EndWrite:

; 306  :     if (buf2)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN3@EndWrite

; 307  :       clamp(buf2, (float*)data_pointer + len1/2, len2/2);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	shr	edx, 1
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	shr	ecx, 1
	mov	edx, DWORD PTR _data_pointer$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	?clamp@output@audio@@YAXPAXPBMH@Z	; audio::output::clamp
	add	esp, 12					; 0000000cH
$LN3@EndWrite:

; 308  : 
; 309  :   if (secondary_buffer->Unlock(buf1, len1, buf2, len2)==DS_OK)

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+76]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN2@EndWrite

; 310  :     return S_OK;

	xor	eax, eax
	jmp	SHORT $LN5@EndWrite

; 311  :   else

	jmp	SHORT $LN5@EndWrite
$LN2@EndWrite:

; 312  :     return S_FALSE;

	mov	eax, 1
$LN5@EndWrite:

; 313  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?EndWrite@DirectSound@output@audio@@UAEHPAX@Z ENDP	; audio::output::DirectSound::EndWrite
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio2\directsound.cpp
_TEXT	SEGMENT
_hr$1 = -24						; size = 4
_nwrite$ = -20						; size = 4
_curpos$ = -12						; size = 4
_this$ = -4						; size = 4
_samples$ = 8						; size = 4
?BeginWrite@DirectSound@output@audio@@UAEHAAI@Z PROC	; audio::output::DirectSound::BeginWrite
; _this$ = ecx

; 227  : int DirectSound::BeginWrite(uint32_t& samples) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 228  :    DWORD curpos;
; 229  :   int32_t nwrite = 0;

	mov	DWORD PTR _nwrite$[ebp], 0
$LN9@BeginWrite:

; 230  :   for (;;) {
; 231  :     HRESULT hr = secondary_buffer->GetCurrentPosition(&curpos, 0);

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _curpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+16]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$1[ebp], eax

; 232  :     if (hr == S_OK)

	cmp	DWORD PTR _hr$1[ebp], 0
	jne	$LN7@BeginWrite

; 233  :     {
; 234  :       // find out how many bytes to write
; 235  :       curpos &= ~31u;

	mov	ecx, DWORD PTR _curpos$[ebp]
	and	ecx, -32				; ffffffe0H
	mov	DWORD PTR _curpos$[ebp], ecx

; 236  :       if (curpos == last_cursor_pos)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _curpos$[ebp]
	cmp	eax, DWORD PTR [edx+60]
	jne	SHORT $LN6@BeginWrite

; 237  :         return S_FALSE;

	mov	eax, 1
	jmp	$LN10@BeginWrite
$LN6@BeginWrite:

; 238  : 
; 239  :       nwrite = curpos - last_cursor_pos;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _curpos$[ebp]
	sub	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _nwrite$[ebp], edx

; 240  :       if (nwrite < 0)

	jns	SHORT $LN5@BeginWrite

; 241  :         nwrite += buffer_size_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nwrite$[ebp]
	add	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _nwrite$[ebp], ecx
$LN5@BeginWrite:

; 242  : 
; 243  :       hr = secondary_buffer->Lock(last_cursor_pos, nwrite, &buf1, &len1, &buf2, &len2, 0);

	mov	esi, esp
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _nwrite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+44]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$1[ebp], eax
$LN7@BeginWrite:

; 244  :     }
; 245  : 
; 246  :     if (hr == S_OK)

	cmp	DWORD PTR _hr$1[ebp], 0
	jne	SHORT $LN4@BeginWrite

; 247  :       break;

	jmp	SHORT $LN8@BeginWrite
	jmp	SHORT $LN3@BeginWrite
$LN4@BeginWrite:

; 248  :     else if (hr == DSERR_BUFFERLOST)

	cmp	DWORD PTR _hr$1[ebp], -2005401450	; 88780096H
	jne	SHORT $LN2@BeginWrite

; 249  :       secondary_buffer->Restore();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+80]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 250  :     else

	jmp	SHORT $LN3@BeginWrite
$LN2@BeginWrite:

; 251  :       return S_FALSE;

	mov	eax, 1
	jmp	SHORT $LN10@BeginWrite
$LN3@BeginWrite:

; 252  :   }

	jmp	$LN9@BeginWrite
$LN8@BeginWrite:

; 253  : 
; 254  :   // we got the lock
; 255  :   last_cursor_pos = curpos;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _curpos$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 256  :   //g_dsound.bufcnt += nwrite;
; 257  :   samples = nwrite / 4;

	mov	eax, DWORD PTR _nwrite$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	edx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR [edx], eax

; 258  :   return S_OK;

	xor	eax, eax
$LN10@BeginWrite:

; 259  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@BeginWrite
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN14@BeginWrite:
	DD	1
	DD	$LN13@BeginWrite
$LN13@BeginWrite:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN12@BeginWrite
$LN12@BeginWrite:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
?BeginWrite@DirectSound@output@audio@@UAEHAAI@Z ENDP	; audio::output::DirectSound::BeginWrite
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio2\directsound.cpp
_TEXT	SEGMENT
$T1 = -96						; size = 1
$T2 = -95						; size = 1
$T3 = -94						; size = 1
$T4 = -93						; size = 1
_src_buf$ = -92						; size = 4
_len$ = -88						; size = 4
_dest_buf$ = -84					; size = 4
_buf_size2$ = -76					; size = 4
_buf_size1$ = -64					; size = 4
_write_cursor$ = -52					; size = 4
_play_cursor$ = -40					; size = 4
_hr$ = -32						; size = 4
_buf_ptr2$ = -24					; size = 4
_buf_ptr1$ = -12					; size = 4
_this$ = -4						; size = 4
_data_pointer$ = 8					; size = 4
_size_bytes$ = 12					; size = 4
?Write@DirectSound@output@audio@@UAEHPAXI@Z PROC	; audio::output::DirectSound::Write
; _this$ = ecx

; 139  : int DirectSound::Write(void* data_pointer, uint32_t size_bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	BYTE PTR $T4[ebp], 0
	mov	BYTE PTR $T2[ebp], 0
	mov	BYTE PTR $T3[ebp], 0
	mov	BYTE PTR $T1[ebp], 0
$LN12@Write:

; 140  :   LPVOID buf_ptr1, buf_ptr2;
; 141  :   HRESULT hr;
; 142  :   DWORD play_cursor,write_cursor;
; 143  :   DWORD buf_size1,buf_size2; 
; 144  : 
; 145  :   for (;;) {
; 146  :     hr = secondary_buffer->GetCurrentPosition(&play_cursor,&write_cursor);

	mov	esi, esp
	lea	eax, DWORD PTR _write_cursor$[ebp]
	push	eax
	lea	ecx, DWORD PTR _play_cursor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+16]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 147  :     if (hr == S_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	jne	SHORT $LN10@Write

; 148  :     {
; 149  :       hr = secondary_buffer->Lock(write_cursor,size_bytes,&buf_ptr1,&buf_size1,&buf_ptr2,&buf_size2,0);

	mov	esi, esp
	push	0
	mov	BYTE PTR $T4[ebp], 1
	lea	edx, DWORD PTR _buf_size2$[ebp]
	push	edx
	mov	BYTE PTR $T3[ebp], 1
	lea	eax, DWORD PTR _buf_ptr2$[ebp]
	push	eax
	mov	BYTE PTR $T2[ebp], 1
	lea	ecx, DWORD PTR _buf_size1$[ebp]
	push	ecx
	mov	BYTE PTR $T1[ebp], 1
	lea	edx, DWORD PTR _buf_ptr1$[ebp]
	push	edx
	mov	eax, DWORD PTR _size_bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _write_cursor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+44]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
$LN10@Write:

; 150  :     }
; 151  : 
; 152  :     if (hr == S_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	jne	SHORT $LN9@Write

; 153  :       break;

	jmp	SHORT $LN11@Write
	jmp	SHORT $LN8@Write
$LN9@Write:

; 154  :     else if (hr == DSERR_BUFFERLOST)

	cmp	DWORD PTR _hr$[ebp], -2005401450	; 88780096H
	jne	SHORT $LN7@Write

; 155  :       secondary_buffer->Restore();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [eax]
	mov	esi, esp
	push	edx
	mov	ecx, DWORD PTR [eax+80]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 156  :     else

	jmp	SHORT $LN8@Write
$LN7@Write:

; 157  :       return S_FALSE;

	mov	eax, 1
	jmp	$LN13@Write
$LN8@Write:

; 158  :   }  

	jmp	$LN12@Write
$LN11@Write:

; 159  : 
; 160  :   auto dest_buf=(uint8_t*)buf_ptr1;

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN15@Write
	push	OFFSET $LN16@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN15@Write:
	mov	edx, DWORD PTR _buf_ptr1$[ebp]
	mov	DWORD PTR _dest_buf$[ebp], edx

; 161  :   auto len=buf_size1;

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN17@Write
	push	OFFSET $LN18@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN17@Write:
	mov	eax, DWORD PTR _buf_size1$[ebp]
	mov	DWORD PTR _len$[ebp], eax

; 162  : 
; 163  :   auto src_buf=(uint8_t*)data_pointer;

	mov	ecx, DWORD PTR _data_pointer$[ebp]
	mov	DWORD PTR _src_buf$[ebp], ecx
$LN5@Write:

; 164  :   while(len) {*dest_buf++=*src_buf++;len--;}

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN4@Write
	mov	edx, DWORD PTR _dest_buf$[ebp]
	mov	eax, DWORD PTR _src_buf$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _dest_buf$[ebp]
	add	edx, 1
	mov	DWORD PTR _dest_buf$[ebp], edx
	mov	eax, DWORD PTR _src_buf$[ebp]
	add	eax, 1
	mov	DWORD PTR _src_buf$[ebp], eax
	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	jmp	SHORT $LN5@Write
$LN4@Write:

; 165  : 
; 166  :   if(buf_ptr2)  {

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN19@Write
	push	OFFSET $LN20@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN19@Write:
	cmp	DWORD PTR _buf_ptr2$[ebp], 0
	je	SHORT $LN3@Write

; 167  :     dest_buf=(uint8_t*)buf_ptr2;

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN21@Write
	push	OFFSET $LN20@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN21@Write:
	mov	edx, DWORD PTR _buf_ptr2$[ebp]
	mov	DWORD PTR _dest_buf$[ebp], edx

; 168  :     len=buf_size2;

	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN22@Write
	push	OFFSET $LN23@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN22@Write:
	mov	eax, DWORD PTR _buf_size2$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN2@Write:

; 169  :     while(len) {*dest_buf++=*src_buf++;len--;}

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN3@Write
	mov	ecx, DWORD PTR _dest_buf$[ebp]
	mov	edx, DWORD PTR _src_buf$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _dest_buf$[ebp]
	add	ecx, 1
	mov	DWORD PTR _dest_buf$[ebp], ecx
	mov	edx, DWORD PTR _src_buf$[ebp]
	add	edx, 1
	mov	DWORD PTR _src_buf$[ebp], edx
	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN2@Write
$LN3@Write:

; 170  :   }
; 171  : 
; 172  :   secondary_buffer->Unlock(buf_ptr1,buf_size1,buf_ptr2,buf_size2);

	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN24@Write
	push	OFFSET $LN23@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN24@Write:
	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN25@Write
	push	OFFSET $LN20@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN25@Write:
	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN26@Write
	push	OFFSET $LN18@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN26@Write:
	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN27@Write
	push	OFFSET $LN16@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN27@Write:
	mov	esi, esp
	mov	ecx, DWORD PTR _buf_size2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf_ptr2$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf_size1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf_ptr1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+76]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 173  :   return S_OK;

	xor	eax, eax
$LN13@Write:

; 174  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN31@Write
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN31@Write:
	DD	6
	DD	$LN30@Write
$LN30@Write:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN16@Write
	DD	-64					; ffffffc0H
	DD	4
	DD	$LN18@Write
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN20@Write
	DD	-76					; ffffffb4H
	DD	4
	DD	$LN23@Write
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN28@Write
	DD	-52					; ffffffccH
	DD	4
	DD	$LN29@Write
$LN29@Write:
	DB	119					; 00000077H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
$LN28@Write:
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
$LN23@Write:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	50					; 00000032H
	DB	0
$LN20@Write:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	50					; 00000032H
	DB	0
$LN18@Write:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	49					; 00000031H
	DB	0
$LN16@Write:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	49					; 00000031H
	DB	0
?Write@DirectSound@output@audio@@UAEHPAXI@Z ENDP	; audio::output::DirectSound::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio2\directsound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_play$ = 8						; size = 4
_write$ = 12						; size = 4
?GetCursors@DirectSound@output@audio@@UAEXAAI0@Z PROC	; audio::output::DirectSound::GetCursors
; _this$ = ecx

; 134  : void DirectSound::GetCursors(uint32_t& play, uint32_t& write) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 135  :   secondary_buffer->GetCurrentPosition((LPDWORD)&play,(LPDWORD)&write);

	mov	esi, esp
	mov	eax, DWORD PTR _write$[ebp]
	push	eax
	mov	ecx, DWORD PTR _play$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+16]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 136  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetCursors@DirectSound@output@audio@@UAEXAAI0@Z ENDP	; audio::output::DirectSound::GetCursors
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio2\directsound.cpp
_TEXT	SEGMENT
_cwrite$ = -24						; size = 4
_cplay$ = -12						; size = 4
_this$ = -4						; size = 4
?GetBytesBuffered@DirectSound@output@audio@@UAEIXZ PROC	; audio::output::DirectSound::GetBytesBuffered
; _this$ = ecx

; 121  : uint32_t DirectSound::GetBytesBuffered() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 122  :  unsigned long cplay,cwrite;
; 123  : 
; 124  :  if(last_write_cursor==0xffffffff) return 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+64], -1
	jne	SHORT $LN3@GetBytesBu
	xor	eax, eax
	jmp	SHORT $LN4@GetBytesBu
$LN3@GetBytesBu:

; 125  : 
; 126  :  secondary_buffer->GetCurrentPosition(&cplay,&cwrite);

	mov	esi, esp
	lea	ecx, DWORD PTR _cwrite$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cplay$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+16]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 127  : 
; 128  :  if(cplay>buffer_size_) return buffer_size_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cplay$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jbe	SHORT $LN2@GetBytesBu
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	jmp	SHORT $LN4@GetBytesBu
$LN2@GetBytesBu:

; 129  : 
; 130  :  if(cplay<last_write_cursor) return last_write_cursor-cplay;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cplay$[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	jae	SHORT $LN1@GetBytesBu
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	sub	eax, DWORD PTR _cplay$[ebp]
	jmp	SHORT $LN4@GetBytesBu
$LN1@GetBytesBu:

; 131  :  return (buffer_size_-cplay)+last_write_cursor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	sub	eax, DWORD PTR _cplay$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+64]
$LN4@GetBytesBu:

; 132  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@GetBytesBu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN9@GetBytesBu:
	DD	2
	DD	$LN8@GetBytesBu
$LN8@GetBytesBu:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN6@GetBytesBu
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN7@GetBytesBu
$LN7@GetBytesBu:
	DB	99					; 00000063H
	DB	119					; 00000077H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
$LN6@GetBytesBu:
	DB	99					; 00000063H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	0
?GetBytesBuffered@DirectSound@output@audio@@UAEIXZ ENDP	; audio::output::DirectSound::GetBytesBuffered
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio2\directsound.cpp
_TEXT	SEGMENT
_hr$1 = -12						; size = 4
_hr$2 = -8						; size = 4
_this$ = -4						; size = 4
?Stop@DirectSound@output@audio@@UAEHXZ PROC		; audio::output::DirectSound::Stop
; _this$ = ecx

; 109  : int DirectSound::Stop() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 110  :   if (secondary_buffer != nullptr) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN4@Stop

; 111  :     auto hr = secondary_buffer->Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	mov	eax, DWORD PTR [edx+72]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$2[ebp], eax

; 112  :     if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$2[ebp], 0
	jge	SHORT $LN4@Stop
	mov	eax, 1
	jmp	SHORT $LN5@Stop
$LN4@Stop:

; 113  :   }
; 114  :   if (primary_buffer != nullptr) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN2@Stop

; 115  :     auto hr = primary_buffer->Stop();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax]
	mov	esi, esp
	push	edx
	mov	ecx, DWORD PTR [eax+72]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$1[ebp], eax

; 116  :     if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$1[ebp], 0
	jge	SHORT $LN2@Stop
	mov	eax, 1
	jmp	SHORT $LN5@Stop
$LN2@Stop:

; 117  :   }
; 118  :   return S_OK;

	xor	eax, eax
$LN5@Stop:

; 119  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Stop@DirectSound@output@audio@@UAEHXZ ENDP		; audio::output::DirectSound::Stop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio2\directsound.cpp
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
?Play@DirectSound@output@audio@@UAEHXZ PROC		; audio::output::DirectSound::Play
; _this$ = ecx

; 100  : int DirectSound::Play() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 101  :   auto hr = primary_buffer->Play(0,0,DSBPLAY_LOOPING);

	mov	esi, esp
	push	1
	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 102  :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN2@Play
	mov	eax, 1
	jmp	SHORT $LN3@Play
$LN2@Play:

; 103  :   hr = secondary_buffer->Play(0,0,DSBPLAY_LOOPING);

	mov	esi, esp
	push	1
	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 104  :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Play
	mov	eax, 1
	jmp	SHORT $LN3@Play
$LN1@Play:

; 105  :   hr = secondary_buffer->SetCurrentPosition(0);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 106  :   return hr;

	mov	eax, DWORD PTR _hr$[ebp]
$LN3@Play:

; 107  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Play@DirectSound@output@audio@@UAEHXZ ENDP		; audio::output::DirectSound::Play
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio2\directsound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Deinitialize@DirectSound@output@audio@@UAEHXZ PROC	; audio::output::DirectSound::Deinitialize
; _this$ = ecx

; 92   : int DirectSound::Deinitialize() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 93   :   Stop();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 94   :   SafeRelease(&secondary_buffer);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	call	??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z ; SafeRelease<IDirectSoundBuffer>
	add	esp, 4

; 95   :   SafeRelease(&primary_buffer);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	call	??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z ; SafeRelease<IDirectSoundBuffer>
	add	esp, 4

; 96   :   SafeRelease(&ds8);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	call	??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z ; SafeRelease<IDirectSound8>
	add	esp, 4

; 97   :   return S_OK;

	xor	eax, eax

; 98   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Deinitialize@DirectSound@output@audio@@UAEHXZ ENDP	; audio::output::DirectSound::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio2\directsound.cpp
_TEXT	SEGMENT
tv417 = -84						; size = 8
tv415 = -76						; size = 4
tv412 = -70						; size = 2
tv410 = -68						; size = 8
tv406 = -60						; size = 4
_dsbd$ = -52						; size = 36
_hr$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_sample_rate$ = 8					; size = 4
_channels$ = 12						; size = 1
_bits$ = 16						; size = 1
?Initialize@DirectSound@output@audio@@UAEHIEE@Z PROC	; audio::output::DirectSound::Initialize
; _this$ = ecx

; 35   : int DirectSound::Initialize(uint32_t sample_rate, uint8_t channels, uint8_t bits) {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 36   :   last_write_cursor=0xffffffff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], -1

; 37   :   HRESULT hr = DirectSoundCreate8(&DSDEVID_DefaultPlayback,&ds8,nullptr);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	push	OFFSET _DSDEVID_DefaultPlayback
	call	_DirectSoundCreate8@12
	mov	DWORD PTR _hr$[ebp], eax

; 38   :   if (FAILED(hr)) {

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN7@Initialize

; 39   :     Deinitialize();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 40   :     return S_FALSE;

	mov	eax, 1
	jmp	$LN8@Initialize
$LN7@Initialize:

; 41   :   }
; 42   :   hr = ds8->SetCooperativeLevel((HWND)window_handle_,DSSCL_PRIORITY);

	mov	esi, esp
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+24]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 43   :   if (FAILED(hr)) {

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN5@Initialize

; 44   :     hr = ds8->SetCooperativeLevel((HWND)window_handle_,DSSCL_NORMAL);  

	mov	esi, esp
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+24]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 45   :     if (FAILED(hr)) {

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN5@Initialize

; 46   :       return S_FALSE;

	mov	eax, 1
	jmp	$LN8@Initialize
$LN5@Initialize:

; 47   :     }
; 48   :   }
; 49   : 
; 50   :   DSBUFFERDESC dsbd;
; 51   : 	ZeroMemory(&dsbd,sizeof(DSBUFFERDESC));

	push	36					; 00000024H
	push	0
	lea	ecx, DWORD PTR _dsbd$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 52   : 	dsbd.dwSize        = sizeof(DSBUFFERDESC);

	mov	DWORD PTR _dsbd$[ebp], 36		; 00000024H

; 53   : 	dsbd.dwFlags       = DSBCAPS_PRIMARYBUFFER;

	mov	DWORD PTR _dsbd$[ebp+4], 1

; 54   : 	dsbd.dwBufferBytes = 0;

	mov	DWORD PTR _dsbd$[ebp+8], 0

; 55   : 	dsbd.lpwfxFormat   = NULL;

	mov	DWORD PTR _dsbd$[ebp+16], 0

; 56   : 
; 57   : 
; 58   : 	hr = ds8->CreateSoundBuffer(&dsbd,&primary_buffer,nullptr) ;

	mov	esi, esp
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	lea	eax, DWORD PTR _dsbd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 59   :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN4@Initialize
	mov	eax, 1
	jmp	$LN8@Initialize
$LN4@Initialize:

; 60   : 
; 61   : 	ZeroMemory( &wave_format_, sizeof(WAVEFORMATEX) ); 

	push	18					; 00000012H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 62   : 	wave_format_.wFormatTag      = (WORD) WAVE_FORMAT_PCM; 

	mov	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+4], dx

; 63   : 	wave_format_.nChannels       =  channels; 

	movzx	cx, BYTE PTR _channels$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+6], cx

; 64   : 	wave_format_.nSamplesPerSec  = sample_rate; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _sample_rate$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 65   : 	wave_format_.wBitsPerSample  = (WORD) bits; 

	movzx	dx, BYTE PTR _bits$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], dx

; 66   : 	wave_format_.nBlockAlign     = (WORD) ((wave_format_.wBitsPerSample >> 3) * wave_format_.nChannels);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+18]
	sar	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+6]
	imul	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+16], dx

; 67   : 	wave_format_.nAvgBytesPerSec = (DWORD) (wave_format_.nSamplesPerSec * wave_format_.nBlockAlign);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+16]
	mov	eax, DWORD PTR _this$[ebp]
	imul	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 68   :   wave_format_.cbSize = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+20], dx

; 69   : 	hr = primary_buffer->SetFormat(&wave_format_);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+56]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 70   :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN3@Initialize
	mov	eax, 1
	jmp	$LN8@Initialize
$LN3@Initialize:

; 71   : 
; 72   : 
; 73   :   if (buffer_size_ == 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $LN2@Initialize

; 74   :     buffer_size_ = uint32_t(wave_format_.nBlockAlign * wave_format_.nSamplesPerSec * 0.4); //400ms

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv406[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv406[ebp]
	mov	eax, DWORD PTR tv406[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mulsd	xmm0, QWORD PTR __real@3fd999999999999a
	movsd	QWORD PTR tv410[ebp], xmm0
	fld	QWORD PTR tv410[ebp]
	fnstcw	WORD PTR tv412[ebp]
	movzx	eax, WORD PTR tv412[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv415[ebp], eax
	fldcw	WORD PTR tv415[ebp]
	fistp	QWORD PTR tv417[ebp]
	fldcw	WORD PTR tv412[ebp]
	mov	ecx, DWORD PTR tv417[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx
$LN2@Initialize:

; 75   : 
; 76   : 
; 77   : 	ZeroMemory( &dsbd, sizeof(DSBUFFERDESC) );

	push	36					; 00000024H
	push	0
	lea	eax, DWORD PTR _dsbd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 78   : 	dsbd.dwSize        = sizeof(DSBUFFERDESC);

	mov	DWORD PTR _dsbd$[ebp], 36		; 00000024H

; 79   : 	dsbd.dwFlags       = DSBCAPS_GLOBALFOCUS | DSBCAPS_GETCURRENTPOSITION2;

	mov	DWORD PTR _dsbd$[ebp+4], 98304		; 00018000H

; 80   : 	dsbd.dwBufferBytes = buffer_size_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _dsbd$[ebp+8], edx

; 81   : 	dsbd.lpwfxFormat   = &wave_format_;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR _dsbd$[ebp+16], eax

; 82   :   // Create a temporary sound buffer with the specific buffer settings.
; 83   : 	hr = ds8->CreateSoundBuffer(&dsbd, &secondary_buffer, NULL);

	mov	esi, esp
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	lea	edx, DWORD PTR _dsbd$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+12]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 84   :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Initialize
	mov	eax, 1
	jmp	SHORT $LN8@Initialize
$LN1@Initialize:

; 85   : 
; 86   :     //hr = secondary_buffer->SetVolume(DSBVOLUME_MAX);
; 87   :   //if (FAILED(hr)) return S_FALSE;
; 88   : 
; 89   :   return Play();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@Initialize:

; 90   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@Initialize
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN12@Initialize:
	DD	1
	DD	$LN11@Initialize
$LN11@Initialize:
	DD	-52					; ffffffccH
	DD	36					; 00000024H
	DD	$LN10@Initialize
$LN10@Initialize:
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	98					; 00000062H
	DB	100					; 00000064H
	DB	0
?Initialize@DirectSound@output@audio@@UAEHIEE@Z ENDP	; audio::output::DirectSound::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio2\directsound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DirectSound@output@audio@@QAE@XZ PROC		; audio::output::DirectSound::~DirectSound
; _this$ = ecx

; 31   : DirectSound::~DirectSound() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DirectSound@output@audio@@6B@

; 32   :   Deinitialize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Deinitialize@DirectSound@output@audio@@UAEHXZ ; audio::output::DirectSound::Deinitialize

; 33   : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1DirectSound@output@audio@@QAE@XZ ENDP		; audio::output::DirectSound::~DirectSound
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio2\directsound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DirectSound@output@audio@@QAE@XZ PROC		; audio::output::DirectSound::DirectSound
; _this$ = ecx

; 26   : DirectSound::DirectSound() : last_write_cursor(0),last_cursor_pos(0) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Interface@output@audio@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DirectSound@output@audio@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 0

; 27   :   window_handle_ = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 28   :   buffer_size_ = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 29   : }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0DirectSound@output@audio@@QAE@XZ ENDP		; audio::output::DirectSound::DirectSound
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0Interface@output@audio@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Interface@output@audio@@QAE@XZ PROC			; audio::output::Interface::Interface, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Interface@output@audio@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Interface@output@audio@@QAE@XZ ENDP			; audio::output::Interface::Interface
_TEXT	ENDS
END
