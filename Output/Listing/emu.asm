; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

	TITLE	C:\Users\Khalid\Documents\GitHub\GBEmu\Solution\Code\emulation\gb\emu.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?value@?$_Abs@$0GE@@std@@2_JB			; std::_Abs<100>::value
PUBLIC	?value@?$_Abs@$0DLJKMKAA@@std@@2_JB		; std::_Abs<1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?value@?$_GcdX@$0GE@$0A@@std@@2_JB		; std::_GcdX<100,0>::value
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB	; std::_GcdX<1000000000,100>::value
PUBLIC	?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
PUBLIC	?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
PUBLIC	?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<100,1000000000>::value
PUBLIC	?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
PUBLIC	?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
PUBLIC	?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<100,1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$_Abs@$00@std@@2_JB			; std::_Abs<1>::value
PUBLIC	?value@?$_GcdX@$00$0A@@std@@2_JB		; std::_GcdX<1,0>::value
PUBLIC	?value@?$_GcdX@$00$00@std@@2_JB			; std::_GcdX<1,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?value@?$_Gcd@$00$00@std@@2_JB			; std::_Gcd<1,1>::value
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_monotonic@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_monotonic
PUBLIC	?is_steady@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_steady
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?value@?$integral_constant@H$0A@@std@@2HB	; std::integral_constant<int,0>::value
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB		; std::_GcdX<10000000,1>::value
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB		; std::_GcdX<1,10000000>::value
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
PUBLIC	?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
PUBLIC	?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB		; std::_Gcd<1,10000000>::value
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
PUBLIC	?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_nonNull
PUBLIC	?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelException
PUBLIC	?num@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::num
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_notInlined
PUBLIC	?den@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::den
PUBLIC	?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_structured
PUBLIC	?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_localCancel
PUBLIC	?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_reserved
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?value@?$integral_constant@W4_Barg_type@std@@$02@std@@2W4_Barg_type@2@B ; std::integral_constant<enum std::_Barg_type,3>::value
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
PUBLIC	?value@?$_Abs@$0JIJGIA@@std@@2_JB		; std::_Abs<10000000>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB		; std::_GcdX<10000000,0>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_GcdX<10000000,10000000>::value
PUBLIC	?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Gcd<10000000,10000000>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?num@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::num
PUBLIC	?den@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::den
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?is_monotonic@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_monotonic
PUBLIC	?is_steady@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_steady
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?_Is_forced@?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@2_NB ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Is_forced
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	_ConcRT_ProviderGuid
PUBLIC	_ConcRTEventGuid
PUBLIC	_SchedulerEventGuid
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	_ScheduleGroupEventGuid
PUBLIC	_ContextEventGuid
PUBLIC	_ChoreEventGuid
PUBLIC	_VirtualProcessorEventGuid
PUBLIC	_LockEventGuid
PUBLIC	_ResourceManagerEventGuid
PUBLIC	_PPLParallelInvokeEventGuid
PUBLIC	_PPLParallelForEventGuid
PUBLIC	_PPLParallelForeachEventGuid
PUBLIC	_AgentEventGuid
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT _AgentEventGuid
CONST	SEGMENT
_AgentEventGuid DD 0b9b5b78cH
	DW	0713H
	DW	04898H
	DB	0a2H
	DB	01aH
	DB	0c6H
	DB	079H
	DB	049H
	DB	0dcH
	DB	0edH
	DB	07H
CONST	ENDS
;	COMDAT _PPLParallelForeachEventGuid
CONST	SEGMENT
_PPLParallelForeachEventGuid DD 05cb7d785H
	DW	09d66H
	DW	0465dH
	DB	0baH
	DB	0e1H
	DB	046H
	DB	011H
	DB	06H
	DB	01bH
	DB	054H
	DB	034H
CONST	ENDS
;	COMDAT _PPLParallelForEventGuid
CONST	SEGMENT
_PPLParallelForEventGuid DD 031c8da6bH
	DW	06165H
	DW	04042H
	DB	08bH
	DB	092H
	DB	094H
	DB	09eH
	DB	031H
	DB	05fH
	DB	04dH
	DB	084H
CONST	ENDS
;	COMDAT _PPLParallelInvokeEventGuid
CONST	SEGMENT
_PPLParallelInvokeEventGuid DD 0d1b5b133H
	DW	0ec3dH
	DW	049f4H
	DB	098H
	DB	0a3H
	DB	046H
	DB	04dH
	DB	01aH
	DB	09eH
	DB	046H
	DB	082H
CONST	ENDS
;	COMDAT _ResourceManagerEventGuid
CONST	SEGMENT
_ResourceManagerEventGuid DD 02718d25bH
	DW	05bf5H
	DW	04479H
	DB	08eH
	DB	088H
	DB	0baH
	DB	0bcH
	DB	064H
	DB	0bdH
	DB	0bfH
	DB	0caH
CONST	ENDS
;	COMDAT _LockEventGuid
CONST	SEGMENT
_LockEventGuid DD 079a60dc6H
	DW	05fc8H
	DW	04952H
	DB	0a4H
	DB	01cH
	DB	011H
	DB	063H
	DB	0aeH
	DB	0ecH
	DB	05eH
	DB	0b8H
CONST	ENDS
;	COMDAT _VirtualProcessorEventGuid
CONST	SEGMENT
_VirtualProcessorEventGuid DD 02f27805fH
	DW	01676H
	DW	04eccH
	DB	096H
	DB	0faH
	DB	07eH
	DB	0b0H
	DB	09dH
	DB	044H
	DB	030H
	DB	02fH
CONST	ENDS
;	COMDAT _ChoreEventGuid
CONST	SEGMENT
_ChoreEventGuid DD 07e854ec7H
	DW	0cdc4H
	DW	0405aH
	DB	0b5H
	DB	0b2H
	DB	0aaH
	DB	0f7H
	DB	0c9H
	DB	0e7H
	DB	0d4H
	DB	0cH
CONST	ENDS
;	COMDAT _ContextEventGuid
CONST	SEGMENT
_ContextEventGuid DD 05727a00fH
	DW	050beH
	DW	04519H
	DB	082H
	DB	056H
	DB	0f7H
	DB	069H
	DB	098H
	DB	071H
	DB	0feH
	DB	0cbH
CONST	ENDS
;	COMDAT _ScheduleGroupEventGuid
CONST	SEGMENT
_ScheduleGroupEventGuid DD 0e8a3bf1fH
	DW	0a86bH
	DW	04390H
	DB	09cH
	DB	060H
	DB	053H
	DB	090H
	DB	0b9H
	DB	069H
	DB	0d2H
	DB	02cH
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT _SchedulerEventGuid
CONST	SEGMENT
_SchedulerEventGuid DD 0e2091f8aH
	DW	01e0aH
	DW	04731H
	DB	084H
	DB	0a2H
	DB	0dH
	DB	0d5H
	DB	07cH
	DB	08aH
	DB	052H
	DB	061H
CONST	ENDS
;	COMDAT _ConcRTEventGuid
CONST	SEGMENT
_ConcRTEventGuid DD 072b14a7dH
	DW	0704cH
	DW	0423eH
	DB	092H
	DB	0f8H
	DB	07eH
	DB	06dH
	DB	064H
	DB	0bcH
	DB	0b9H
	DB	02aH
CONST	ENDS
;	COMDAT _ConcRT_ProviderGuid
CONST	SEGMENT
_ConcRT_ProviderGuid DD 0f7b697a3H
	DW	04db5H
	DW	04d3bH
	DB	0beH
	DB	071H
	DB	0c4H
	DB	0d2H
	DB	084H
	DB	0e6H
	DB	059H
	DB	02fH
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?_Is_forced@?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@2_NB
CONST	SEGMENT
?_Is_forced@?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@2_NB DB 01H ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Is_forced
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?is_steady@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@steady_clock@chrono@std@@2_NB DB 01H		; std::chrono::steady_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@steady_clock@chrono@std@@2_NB DB 01H	; std::chrono::steady_clock::is_monotonic
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::num
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0JIJGIA@@std@@2_JB DQ 0000000000989680H	; std::_Abs<10000000>::value
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@W4_Barg_type@std@@$02@std@@2W4_Barg_type@2@B
CONST	SEGMENT
?value@?$integral_constant@W4_Barg_type@std@@$02@std@@2W4_Barg_type@2@B DD 03H ; std::integral_constant<enum std::_Barg_type,3>::value
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_reserved
CONST	ENDS
;	COMDAT ?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_localCancel
CONST	ENDS
;	COMDAT ?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_structured
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::ratio<1,10000000>::den
CONST	ENDS
;	COMDAT ?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB DD 0ffffffffH ; Concurrency::details::_TaskCollectionBase::_S_notInlined
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,10000000>::num
CONST	ENDS
;	COMDAT ?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_cancelException
CONST	ENDS
;	COMDAT ?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB DD 08H ; Concurrency::details::_TaskCollectionBase::_S_nonNull
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
CONST	ENDS
;	COMDAT ?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,10000000>::value
CONST	ENDS
;	COMDAT ?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
CONST	ENDS
;	COMDAT ?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB DD 00H ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000000>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000000,1>::value
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@H$0A@@std@@2HB
CONST	SEGMENT
?value@?$integral_constant@H$0A@@std@@2HB DD 00H	; std::integral_constant<int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?is_steady@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@system_clock@chrono@std@@2_NB DB 00H		; std::chrono::system_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@system_clock@chrono@std@@2_NB DB 00H	; std::chrono::system_clock::is_monotonic
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0A@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$00@std@@2_JB DQ 0000000000000001H	; std::_Abs<1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_Gcd<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB DD 03H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
CONST	ENDS
;	COMDAT ?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 02H ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 01H ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
CONST	ENDS
;	COMDAT ?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB DD 00H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<1000000000,100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0A@@std@@2_JB DQ 0000000000000064H	; std::_GcdX<100,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Abs<1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0GE@@std@@2_JB DQ 0000000000000064H	; std::_Abs<100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
CONST	SEGMENT
_dutycycletable DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
$SG153852 DB	'Code\emulation\gb\emu.cpp', 00H
	ORG $+2
$SG153853 DB	'Code\emulation\gb\emu.cpp', 00H
	ORG $+2
$SG153858 DB	'killed thread', 0aH, 00H
	ORG $+1
$SG153879 DB	'end of thread', 0aH, 00H
	ORG $+1
_clockspeed DQ	04150000000000000r		; 4.1943e+006
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
PUBLIC	?_Atomic_load_4@std@@YAKPCKW4memory_order@1@@Z	; std::_Atomic_load_4
PUBLIC	??0_Ignore@std@@QAE@XZ				; std::_Ignore::_Ignore
PUBLIC	??0?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@QAE@XZ ; std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
PUBLIC	??0?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@QAE@ABV01@@Z ; std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
PUBLIC	?tie@std@@YA?AV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@1@XZ ; std::tie
PUBLIC	??$forward@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@@std@@YA$$QAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AAV10@@Z ; std::forward<std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??1thread@std@@QAE@XZ				; std::thread::~thread
PUBLIC	?joinable@thread@std@@QBE_NXZ			; std::thread::joinable
PUBLIC	?join@thread@std@@QAEXXZ			; std::thread::join
PUBLIC	?get_id@thread@std@@QBE?AVid@12@XZ		; std::thread::get_id
PUBLIC	??_Gthread@std@@QAEPAXI@Z			; std::thread::`scalar deleting destructor'
PUBLIC	?get_id@this_thread@std@@YA?AVid@thread@2@XZ	; std::this_thread::get_id
PUBLIC	??0id@thread@std@@AAE@ABV12@@Z			; std::thread::id::id
PUBLIC	??0id@thread@std@@AAE@U_Thrd_imp_t@@@Z		; std::thread::id::id
PUBLIC	??8std@@YA_NVid@thread@0@0@Z			; std::operator==
PUBLIC	?_Store_relaxed_4@std@@YAXPCKK@Z		; std::_Store_relaxed_4
PUBLIC	?_Store_release_4@std@@YAXPCKK@Z		; std::_Store_release_4
PUBLIC	?_Store_seq_cst_4@std@@YAXPCKK@Z		; std::_Store_seq_cst_4
PUBLIC	?_Atomic_store_4@std@@YAXPCKKW4memory_order@1@@Z ; std::_Atomic_store_4
PUBLIC	?_Load_relaxed_4@std@@YAKPCK@Z			; std::_Load_relaxed_4
PUBLIC	?_Load_acquire_4@std@@YAKPCK@Z			; std::_Load_acquire_4
PUBLIC	?_Load_seq_cst_4@std@@YAKPCK@Z			; std::_Load_seq_cst_4
PUBLIC	??4atomic_int@std@@QAEHH@Z			; std::atomic_int::operator=
PUBLIC	??Batomic_int@std@@QBEHXZ			; std::atomic_int::operator int
PUBLIC	??4?$atomic@H@std@@QAEHH@Z			; std::atomic<int>::operator=
PUBLIC	?atomic_store_explicit@std@@YAXPAUatomic_int@1@HW4memory_order@1@@Z ; std::atomic_store_explicit
PUBLIC	?atomic_store@std@@YAXPAUatomic_int@1@H@Z	; std::atomic_store
PUBLIC	?atomic_load_explicit@std@@YAHPBUatomic_int@1@W4memory_order@1@@Z ; std::atomic_load_explicit
PUBLIC	?atomic_load@std@@YAHPBUatomic_int@1@@Z		; std::atomic_load
PUBLIC	?Calibrate@Timer@utilities@@QAEXXZ		; utilities::Timer::Calibrate
PUBLIC	?resolution@Timer@utilities@@QAENXZ		; utilities::Timer::resolution
PUBLIC	?GetCurrentCycles@Timer@utilities@@QAE_KXZ	; utilities::Timer::GetCurrentCycles
PUBLIC	?Initialize@Emu@gb@emulation@@QAEXXZ		; emulation::gb::Emu::Initialize
PUBLIC	?Deinitialize@Emu@gb@emulation@@QAEXXZ		; emulation::gb::Emu::Deinitialize
PUBLIC	?Step@Emu@gb@emulation@@QAENXZ			; emulation::gb::Emu::Step
PUBLIC	?Run@Emu@gb@emulation@@QAEXXZ			; emulation::gb::Emu::Run
PUBLIC	?Stop@Emu@gb@emulation@@QAEXXZ			; emulation::gb::Emu::Stop
PUBLIC	?Pause@Emu@gb@emulation@@QAEXXZ			; emulation::gb::Emu::Pause
PUBLIC	?Reset@Emu@gb@emulation@@QAEXXZ			; emulation::gb::Emu::Reset
PUBLIC	?Render@Emu@gb@emulation@@QAEXXZ		; emulation::gb::Emu::Render
PUBLIC	??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
PUBLIC	?thread_func@Emu@gb@emulation@@CAXPAV123@@Z	; emulation::gb::Emu::thread_func
PUBLIC	??$?0P6AXPAVEmu@gb@emulation@@@ZQAV012@@thread@std@@QAE@P6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z ; std::thread::thread<void (__cdecl*)(emulation::gb::Emu *),emulation::gb::Emu * const>
PUBLIC	??$SafeDelete@Vthread@std@@@@YAXPAPAVthread@std@@@Z ; SafeDelete<std::thread>
PUBLIC	??$forward@P6AXPAVEmu@gb@emulation@@@Z@std@@YA$$QAP6AXPAVEmu@gb@emulation@@@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*)(emulation::gb::Emu *)>
PUBLIC	??$_Decay_copy@P6AXPAVEmu@gb@emulation@@@Z@std@@YAP6AXPAVEmu@gb@emulation@@@Z$$QAP6AX0@Z@Z ; std::_Decay_copy<void (__cdecl*)(emulation::gb::Emu *)>
PUBLIC	??$forward@QAVEmu@gb@emulation@@@std@@YA$$QBQAVEmu@gb@emulation@@ABQAV123@@Z ; std::forward<emulation::gb::Emu * const>
PUBLIC	??$bind@XPAVEmu@gb@emulation@@QAV123@@std@@YA?AV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@P6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z ; std::bind<void,emulation::gb::Emu *,emulation::gb::Emu * const>
PUBLIC	??0?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAE@$$QAV01@@Z ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
PUBLIC	??R?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAEXXZ ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
PUBLIC	??0?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAE@$$QAV01@@Z ; std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
PUBLIC	?_Get_rest@?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAEAAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@2@XZ ; std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Get_rest
PUBLIC	??$_Launch@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@@Z ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$?0AAP6AXPAVEmu@gb@emulation@@@ZQAV012@@?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAE@AAP6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><void (__cdecl*&)(emulation::gb::Emu *),emulation::gb::Emu * const>
PUBLIC	??$forward@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@AAV10@@Z ; std::forward<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@UAEIXZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Go
PUBLIC	?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@CAIPAV12@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Run
PUBLIC	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@XZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$?0V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@1@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> ><std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$forward@V?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@@std@@YA$$QAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@AAV10@@Z ; std::forward<std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$get@$0A@PAVEmu@gb@emulation@@@std@@YAAAPAVEmu@gb@emulation@@AAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@@Z ; std::get<0,emulation::gb::Emu *>
PUBLIC	??$_Fixarg@AAP6AXPAVEmu@gb@emulation@@@ZPAV123@V?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@5@@std@@YAAAPAVEmu@gb@emulation@@AAP6AXPAV123@@ZAAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@AAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AAPAV123@@Z ; std::_Fixarg<void (__cdecl*&)(emulation::gb::Emu *),emulation::gb::Emu *,std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>,std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$forward@PAVEmu@gb@emulation@@@std@@YA$$QAPAVEmu@gb@emulation@@AAPAV123@@Z ; std::forward<emulation::gb::Emu *>
PUBLIC	??$?0PAVEmu@gb@emulation@@@?$_Tuple_val@PAVEmu@gb@emulation@@@std@@QAE@$$QAPAVEmu@gb@emulation@@@Z ; std::_Tuple_val<emulation::gb::Emu *>::_Tuple_val<emulation::gb::Emu *><emulation::gb::Emu *>
PUBLIC	??$forward@AAP6AXPAVEmu@gb@emulation@@@Z@std@@YAAAP6AXPAVEmu@gb@emulation@@@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*&)(emulation::gb::Emu *)>
PUBLIC	??$?0QAVEmu@gb@emulation@@@?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAE@$$QBQAVEmu@gb@emulation@@PAPAX@Z ; std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><emulation::gb::Emu * const>
PUBLIC	??$?0QAVEmu@gb@emulation@@@?$_Tuple_val@PAVEmu@gb@emulation@@@std@@QAE@$$QBQAVEmu@gb@emulation@@@Z ; std::_Tuple_val<emulation::gb::Emu *>::_Tuple_val<emulation::gb::Emu *><emulation::gb::Emu * const>
PUBLIC	??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@		; `string'
PUBLIC	??_C@_1JC@OFINEDFE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1CK@BEGEBJJG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; `string'
PUBLIC	??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@BEBCCGEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAs?$AAt?$AAo?$AAr?$AAe?$AA_?$AA4?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@NMHCEFB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAl?$AAo?$AAa?$AAd?$AA_?$AA4?$AA?$AA@ ; `string'
PUBLIC	??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`vftable'
PUBLIC	??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> > `RTTI Type Descriptor'
PUBLIC	??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@_Pad@std@@8			; std::_Pad::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_Pad@std@@@8				; std::_Pad `RTTI Type Descriptor'
PUBLIC	??_R3_Pad@std@@8				; std::_Pad::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Pad@std@@8				; std::_Pad::`RTTI Base Class Array'
PUBLIC	__real@0000000000000000
PUBLIC	__real@406f400000000000
PUBLIC	__real@408f400000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter:PROC
EXTRN	_memset:PROC
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp_?terminate@@YAXXZ:PROC
EXTRN	__imp___CrtDbgReportW:PROC
EXTRN	??2@YAPAXIHPBDH@Z:PROC				; operator new
EXTRN	??3@YAXPAXHPBDH@Z:PROC				; operator delete
EXTRN	__imp_?_Debug_message@std@@YAXPB_W0I@Z:PROC
EXTRN	__imp_?_Xbad_function_call@std@@YAXXZ:PROC
EXTRN	__imp___Thrd_join:PROC
EXTRN	__imp___Thrd_equal:PROC
EXTRN	__imp___Thrd_current:PROC
EXTRN	__imp_?_Throw_Cpp_error@std@@YAXH@Z:PROC
EXTRN	__imp_??0_Pad@std@@QAE@XZ:PROC
EXTRN	__imp_??1_Pad@std@@QAE@XZ:PROC
EXTRN	__imp_?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z:PROC
EXTRN	__imp_?_Release@_Pad@std@@QAEXXZ:PROC
EXTRN	?Step@Cpu@gb@emulation@@QAEXN@Z:PROC		; emulation::gb::Cpu::Step
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__aulldiv:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_ignore	DB	01H DUP (?)
__Tuple_alloc DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@406f400000000000
CONST	SEGMENT
__real@406f400000000000 DQ 0406f400000000000r	; 250
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R2_Pad@std@@8
rdata$r	SEGMENT
??_R2_Pad@std@@8 DD FLAT:??_R1A@?0A@EA@_Pad@std@@8	; std::_Pad::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Pad@std@@8
rdata$r	SEGMENT
??_R3_Pad@std@@8 DD 00H					; std::_Pad::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Pad@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Pad@std@@@8
_DATA	SEGMENT
??_R0?AV_Pad@std@@@8 DD FLAT:??_7type_info@@6B@		; std::_Pad `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Pad@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@_Pad@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Pad@std@@8 DD FLAT:??_R0?AV_Pad@std@@@8	; std::_Pad::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Pad@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@8 DD FLAT:??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Pad@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@8 DD 00H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@'
	DB	'ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@6B@ DD 00H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@@8
	DD	FLAT:??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@6B@
CONST	SEGMENT
??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@6B@ DD FLAT:??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`vftable'
	DD	FLAT:?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@UAEIXZ
CONST	ENDS
;	COMDAT ??_C@_1CI@NMHCEFB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAl?$AAo?$AAa?$AAd?$AA_?$AA4?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@NMHCEFB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAl?$AAo?$AAa?$AAd?$AA_?$AA4?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	't', 00H, 'o', 00H, 'm', 00H, 'i', 00H, 'c', 00H, '_', 00H, 'l'
	DB	00H, 'o', 00H, 'a', 00H, 'd', 00H, '_', 00H, '4', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@BEBCCGEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAs?$AAt?$AAo?$AAr?$AAe?$AA_?$AA4?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@BEBCCGEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAs?$AAt?$AAo?$AAr?$AAe?$AA_?$AA4?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	't', 00H, 'o', 00H, 'm', 00H, 'i', 00H, 'c', 00H, '_', 00H, 's'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 'e', 00H, '_', 00H, '4', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
CONST	SEGMENT
??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ DB '"'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'a', 00H
	DB	'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+', 00H, ' '
	DB	00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H, 'r', 00H
	DB	'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'I', 00H, 'n', 00H, 'v'
	DB	00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H, 'A', 00H
	DB	'r', 00H, 'g', 00H, 'u', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't'
	DB	00H, '"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
CONST	SEGMENT
??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ DB 'Standa'
	DB	'rd C++ Libraries Invalid Argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@BEGEBJJG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@BEGEBJJG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?$AA@ DB 'I'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y'
	DB	00H, '_', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1JC@OFINEDFE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1JC@OFINEDFE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '1', 00H, '.', 00H, '0', 00H, '\', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'm', 00H, 'i', 00H, 'c', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@1@@Z$0
__ehfuncinfo$??$?0V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Launch@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Launch@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@@Z$0
__ehfuncinfo$??$_Launch@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Launch@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?Run@Emu@gb@emulation@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Run@Emu@gb@emulation@@QAEXXZ$0
__ehfuncinfo$?Run@Emu@gb@emulation@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Run@Emu@gb@emulation@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??$?0QAVEmu@gb@emulation@@@?$_Tuple_val@PAVEmu@gb@emulation@@@std@@QAE@$$QBQAVEmu@gb@emulation@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Arg$ = 8						; size = 4
??$?0QAVEmu@gb@emulation@@@?$_Tuple_val@PAVEmu@gb@emulation@@@std@@QAE@$$QBQAVEmu@gb@emulation@@@Z PROC ; std::_Tuple_val<emulation::gb::Emu *>::_Tuple_val<emulation::gb::Emu *><emulation::gb::Emu * const>, COMDAT
; _this$ = ecx

; 151  : 		{	// construct with argument

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Arg$[ebp]
	push	eax
	call	??$forward@QAVEmu@gb@emulation@@@std@@YA$$QBQAVEmu@gb@emulation@@ABQAV123@@Z ; std::forward<emulation::gb::Emu * const>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 152  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0QAVEmu@gb@emulation@@@?$_Tuple_val@PAVEmu@gb@emulation@@@std@@QAE@$$QBQAVEmu@gb@emulation@@@Z ENDP ; std::_Tuple_val<emulation::gb::Emu *>::_Tuple_val<emulation::gb::Emu *><emulation::gb::Emu * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??$?0QAVEmu@gb@emulation@@@?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAE@$$QBQAVEmu@gb@emulation@@PAPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Arg0$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?0QAVEmu@gb@emulation@@@?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAE@$$QBQAVEmu@gb@emulation@@PAPAX@Z PROC ; std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><emulation::gb::Emu * const>, COMDAT
; _this$ = ecx

; 521  : _VARIADIC_EXPAND_0X(_CLASS_TUPLE, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@QAE@XZ ; std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
	mov	eax, DWORD PTR __Arg0$[ebp]
	push	eax
	call	??$forward@QAVEmu@gb@emulation@@@std@@YA$$QBQAVEmu@gb@emulation@@ABQAV123@@Z ; std::forward<emulation::gb::Emu * const>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0QAVEmu@gb@emulation@@@?$_Tuple_val@PAVEmu@gb@emulation@@@std@@QAE@$$QBQAVEmu@gb@emulation@@@Z ; std::_Tuple_val<emulation::gb::Emu *>::_Tuple_val<emulation::gb::Emu *><emulation::gb::Emu * const>
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0QAVEmu@gb@emulation@@@?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAE@$$QBQAVEmu@gb@emulation@@PAPAX@Z ENDP ; std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><emulation::gb::Emu * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAP6AXPAVEmu@gb@emulation@@@Z@std@@YAAAP6AXPAVEmu@gb@emulation@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAP6AXPAVEmu@gb@emulation@@@Z@std@@YAAAP6AXPAVEmu@gb@emulation@@@ZAAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*&)(emulation::gb::Emu *)>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAP6AXPAVEmu@gb@emulation@@@Z@std@@YAAAP6AXPAVEmu@gb@emulation@@@ZAAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*&)(emulation::gb::Emu *)>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??$?0PAVEmu@gb@emulation@@@?$_Tuple_val@PAVEmu@gb@emulation@@@std@@QAE@$$QAPAVEmu@gb@emulation@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Arg$ = 8						; size = 4
??$?0PAVEmu@gb@emulation@@@?$_Tuple_val@PAVEmu@gb@emulation@@@std@@QAE@$$QAPAVEmu@gb@emulation@@@Z PROC ; std::_Tuple_val<emulation::gb::Emu *>::_Tuple_val<emulation::gb::Emu *><emulation::gb::Emu *>, COMDAT
; _this$ = ecx

; 151  : 		{	// construct with argument

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Arg$[ebp]
	push	eax
	call	??$forward@PAVEmu@gb@emulation@@@std@@YA$$QAPAVEmu@gb@emulation@@AAPAV123@@Z ; std::forward<emulation::gb::Emu *>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 152  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVEmu@gb@emulation@@@?$_Tuple_val@PAVEmu@gb@emulation@@@std@@QAE@$$QAPAVEmu@gb@emulation@@@Z ENDP ; std::_Tuple_val<emulation::gb::Emu *>::_Tuple_val<emulation::gb::Emu *><emulation::gb::Emu *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@PAVEmu@gb@emulation@@@std@@YA$$QAPAVEmu@gb@emulation@@AAPAV123@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVEmu@gb@emulation@@@std@@YA$$QAPAVEmu@gb@emulation@@AAPAV123@@Z PROC ; std::forward<emulation::gb::Emu *>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@PAVEmu@gb@emulation@@@std@@YA$$QAPAVEmu@gb@emulation@@AAPAV123@@Z ENDP ; std::forward<emulation::gb::Emu *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??$_Fixarg@AAP6AXPAVEmu@gb@emulation@@@ZPAV123@V?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@5@@std@@YAAAPAVEmu@gb@emulation@@AAP6AXPAV123@@ZAAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@AAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AAPAV123@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Mybargs$ = 12						; size = 4
__Myfargs$ = 16						; size = 4
__Arg$ = 20						; size = 4
??$_Fixarg@AAP6AXPAVEmu@gb@emulation@@@ZPAV123@V?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@5@@std@@YAAAPAVEmu@gb@emulation@@AAP6AXPAV123@@ZAAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@AAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AAPAV123@@Z PROC ; std::_Fixarg<void (__cdecl*&)(emulation::gb::Emu *),emulation::gb::Emu *,std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>,std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT

; 1088 : 	{	// convert a plain argument

	push	ebp
	mov	ebp, esp

; 1089 : 	return (_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1090 : 	}

	pop	ebp
	ret	0
??$_Fixarg@AAP6AXPAVEmu@gb@emulation@@@ZPAV123@V?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@5@@std@@YAAAPAVEmu@gb@emulation@@AAP6AXPAV123@@ZAAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@AAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AAPAV123@@Z ENDP ; std::_Fixarg<void (__cdecl*&)(emulation::gb::Emu *),emulation::gb::Emu *,std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>,std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??$get@$0A@PAVEmu@gb@emulation@@@std@@YAAAPAVEmu@gb@emulation@@AAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$0A@PAVEmu@gb@emulation@@@std@@YAAAPAVEmu@gb@emulation@@AAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@@Z PROC ; std::get<0,emulation::gb::Emu *>, COMDAT

; 697  : _VARIADIC_EXPAND_0X(_TUPLE_GET, _COMMA, , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Tuple$[ebp]
	pop	ebp
	ret	0
??$get@$0A@PAVEmu@gb@emulation@@@std@@YAAAPAVEmu@gb@emulation@@AAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@@Z ENDP ; std::get<0,emulation::gb::Emu *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@@std@@YA$$QAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@@std@@YA$$QAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@AAV10@@Z PROC ; std::forward<std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@V?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@@std@@YA$$QAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@AAV10@@Z ENDP ; std::forward<std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ??$?0V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Tgt$ = 8						; size = 4
??$?0V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@1@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> ><std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT
; _this$ = ecx

; 182  : 		{	// construct from target

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0_Pad@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@6B@
	mov	ecx, DWORD PTR __Tgt$[ebp]
	push	ecx
	call	??$forward@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@AAV10@@Z ; std::forward<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAE@$$QAV01@@Z ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>

; 183  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@1@@Z$0:
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Pad@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$??$?0V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@1@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> ><std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@XZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Pad@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@XZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@CAIPAV12@@Z
_TEXT	SEGMENT
__Local$ = -12						; size = 8
__Ln$ = 8						; size = 4
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@CAIPAV12@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Run, COMDAT

; 192  : 		{	// make local copy of function object and call it

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 193  : 		_Target _Local(_STD forward<_Target>(_Ln->_MyTarget));

	mov	eax, DWORD PTR __Ln$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	??$forward@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@AAV10@@Z ; std::forward<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Local$[ebp]
	call	??0?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAE@$$QAV01@@Z ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>

; 194  : 		_Ln->_Release();

	mov	esi, esp
	mov	ecx, DWORD PTR __Ln$[ebp]
	call	DWORD PTR __imp_?_Release@_Pad@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 195  : 		_Local();

	lea	ecx, DWORD PTR __Local$[ebp]
	call	??R?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAEXXZ ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()

; 196  : 		return (0);

	xor	eax, eax

; 197  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Run
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@Run:
	DD	1
	DD	$LN4@Run
$LN4@Run:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN3@Run
$LN3@Run:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@CAIPAV12@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Run
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@UAEIXZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Go, COMDAT
; _this$ = ecx

; 186  : 		{	// run the thread function object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Run(this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@CAIPAV12@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Run
	add	esp, 4

; 188  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@UAEIXZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Go
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@AAV10@@Z PROC ; std::forward<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@AAV10@@Z ENDP ; std::forward<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??$?0AAP6AXPAVEmu@gb@emulation@@@ZQAV012@@?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAE@AAP6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Fx$ = 8						; size = 4
__Vx0$ = 12						; size = 4
??$?0AAP6AXPAVEmu@gb@emulation@@@ZQAV012@@?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAE@AAP6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><void (__cdecl*&)(emulation::gb::Emu *),emulation::gb::Emu * const>, COMDAT
; _this$ = ecx

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Fx$[ebp]
	push	eax
	call	??$forward@AAP6AXPAVEmu@gb@emulation@@@Z@std@@YAAAP6AXPAVEmu@gb@emulation@@@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*&)(emulation::gb::Emu *)>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	push	0
	mov	eax, DWORD PTR __Vx0$[ebp]
	push	eax
	call	??$forward@QAVEmu@gb@emulation@@@std@@YA$$QBQAVEmu@gb@emulation@@ABQAV123@@Z ; std::forward<emulation::gb::Emu * const>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0QAVEmu@gb@emulation@@@?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAE@$$QBQAVEmu@gb@emulation@@PAPAX@Z ; std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><emulation::gb::Emu * const>
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0AAP6AXPAVEmu@gb@emulation@@@ZQAV012@@?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAE@AAP6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><void (__cdecl*&)(emulation::gb::Emu *),emulation::gb::Emu * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ??$_Launch@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@@Z
_TEXT	SEGMENT
__Launcher$ = -40					; size = 24
__$EHRec$ = -12						; size = 12
__Thr$ = 8						; size = 4
__Tg$ = 12						; size = 4
??$_Launch@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@@Z PROC ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT

; 204  : 	{	// launch a new thread

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Launch@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 205  : 	_LaunchPad<_Target> _Launcher(_STD forward<_Target>(_Tg));

	mov	eax, DWORD PTR __Tg$[ebp]
	push	eax
	call	??$forward@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@AAV10@@Z ; std::forward<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Launcher$[ebp]
	call	??$?0V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@1@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> ><std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 206  : 	_Launcher._Launch(_Thr);

	mov	esi, esp
	mov	ecx, DWORD PTR __Thr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Launcher$[ebp]
	call	DWORD PTR __imp_?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 207  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Launcher$[ebp]
	call	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@XZ
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@Launch
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@Launch:
	DD	1
	DD	$LN6@Launch
$LN6@Launch:
	DD	-40					; ffffffd8H
	DD	24					; 00000018H
	DD	$LN4@Launch
$LN4@Launch:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	97					; 00000061H
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Launch@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@@Z$0:
	lea	ecx, DWORD PTR __Launcher$[ebp]
	jmp	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@QAE@XZ
__ehhandler$??$_Launch@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Launch@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Launch@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@@Z ENDP ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ?_Get_rest@?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAEAAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_rest@?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAEAAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@2@XZ PROC ; std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Get_rest, COMDAT
; _this$ = ecx

; 521  : _VARIADIC_EXPAND_0X(_CLASS_TUPLE, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_rest@?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAEAAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@2@XZ ENDP ; std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Get_rest
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAE@$$QAV01@@Z PROC ; std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>, COMDAT
; _this$ = ecx

; 521  : _VARIADIC_EXPAND_0X(_CLASS_TUPLE, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Get_rest@?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAEAAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@2@XZ ; std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Get_rest
	push	eax
	call	??$forward@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@@std@@YA$$QAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AAV10@@Z ; std::forward<std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@QAE@ABV01@@Z ; std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@PAVEmu@gb@emulation@@@std@@YA$$QAPAVEmu@gb@emulation@@AAPAV123@@Z ; std::forward<emulation::gb::Emu *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0PAVEmu@gb@emulation@@@?$_Tuple_val@PAVEmu@gb@emulation@@@std@@QAE@$$QAPAVEmu@gb@emulation@@@Z ; std::_Tuple_val<emulation::gb::Emu *>::_Tuple_val<emulation::gb::Emu *><emulation::gb::Emu *>
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAE@$$QAV01@@Z ENDP ; std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??R?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAEXXZ
_TEXT	SEGMENT
__Myfargs$ = -9						; size = 1
_this$ = -4						; size = 4
??R?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAEXXZ PROC ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator(), COMDAT
; _this$ = ecx

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Myfargs$[ebp]
	push	eax
	call	?tie@std@@YA?AV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@1@XZ ; std::tie
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	??$get@$0A@PAVEmu@gb@emulation@@@std@@YAAAPAVEmu@gb@emulation@@AAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@@Z ; std::get<0,emulation::gb::Emu *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __Myfargs$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$_Fixarg@AAP6AXPAVEmu@gb@emulation@@@ZPAV123@V?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@5@@std@@YAAAPAVEmu@gb@emulation@@AAP6AXPAV123@@ZAAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@AAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AAPAV123@@Z ; std::_Fixarg<void (__cdecl*&)(emulation::gb::Emu *),emulation::gb::Emu *,std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>,std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
	add	esp, 16					; 00000010H
	mov	esi, esp
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@operator:
	DD	1
	DD	$LN4@operator
$LN4@operator:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@operator
$LN3@operator:
	DB	95					; 0000005fH
	DB	77					; 0000004dH
	DB	121					; 00000079H
	DB	102					; 00000066H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
??R?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAEXXZ ENDP ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??0?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAE@$$QAV01@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>, COMDAT
; _this$ = ecx

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@P6AXPAVEmu@gb@emulation@@@Z@std@@YA$$QAP6AXPAVEmu@gb@emulation@@@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*)(emulation::gb::Emu *)>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 4
	push	eax
	call	??$forward@V?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@@std@@YA$$QAV?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@0@AAV10@@Z ; std::forward<std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$tuple@PAVEmu@gb@emulation@@U_Nil@std@@U45@U45@U45@U45@U45@U45@@std@@QAE@$$QAV01@@Z ; std::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<emulation::gb::Emu *,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAE@$$QAV01@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??$bind@XPAVEmu@gb@emulation@@QAV123@@std@@YA?AV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@P6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Pfx$ = 12						; size = 4
__Vx0$ = 16						; size = 4
??$bind@XPAVEmu@gb@emulation@@QAV123@@std@@YA?AV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@P6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z PROC ; std::bind<void,emulation::gb::Emu *,emulation::gb::Emu * const>, COMDAT

; 1387 : _VARIADIC_EXPAND_0X_0X(_BIND_IMPLICIT1)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	eax, DWORD PTR __Vx0$[ebp]
	push	eax
	call	??$forward@QAVEmu@gb@emulation@@@std@@YA$$QBQAVEmu@gb@emulation@@ABQAV123@@Z ; std::forward<emulation::gb::Emu * const>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	eax, DWORD PTR __Pfx$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0AAP6AXPAVEmu@gb@emulation@@@ZQAV012@@?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@QAE@AAP6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z ; std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><void (__cdecl*&)(emulation::gb::Emu *),emulation::gb::Emu * const>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$bind@XPAVEmu@gb@emulation@@QAV123@@std@@YA?AV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@P6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z ENDP ; std::bind<void,emulation::gb::Emu *,emulation::gb::Emu * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@QAVEmu@gb@emulation@@@std@@YA$$QBQAVEmu@gb@emulation@@ABQAV123@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@QAVEmu@gb@emulation@@@std@@YA$$QBQAVEmu@gb@emulation@@ABQAV123@@Z PROC ; std::forward<emulation::gb::Emu * const>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@QAVEmu@gb@emulation@@@std@@YA$$QBQAVEmu@gb@emulation@@ABQAV123@@Z ENDP ; std::forward<emulation::gb::Emu * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Decay_copy@P6AXPAVEmu@gb@emulation@@@Z@std@@YAP6AXPAVEmu@gb@emulation@@@Z$$QAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Decay_copy@P6AXPAVEmu@gb@emulation@@@Z@std@@YAP6AXPAVEmu@gb@emulation@@@Z$$QAP6AX0@Z@Z PROC ; std::_Decay_copy<void (__cdecl*)(emulation::gb::Emu *)>, COMDAT

; 1815 : 	{	// forward _Arg as value of decayed type

	push	ebp
	mov	ebp, esp

; 1816 : 	return (_STD forward<_Ty>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]
	push	eax
	call	??$forward@P6AXPAVEmu@gb@emulation@@@Z@std@@YA$$QAP6AXPAVEmu@gb@emulation@@@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*)(emulation::gb::Emu *)>
	add	esp, 4
	mov	eax, DWORD PTR [eax]

; 1817 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Decay_copy@P6AXPAVEmu@gb@emulation@@@Z@std@@YAP6AXPAVEmu@gb@emulation@@@Z$$QAP6AX0@Z@Z ENDP ; std::_Decay_copy<void (__cdecl*)(emulation::gb::Emu *)>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@P6AXPAVEmu@gb@emulation@@@Z@std@@YA$$QAP6AXPAVEmu@gb@emulation@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@P6AXPAVEmu@gb@emulation@@@Z@std@@YA$$QAP6AXPAVEmu@gb@emulation@@@ZAAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*)(emulation::gb::Emu *)>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@P6AXPAVEmu@gb@emulation@@@Z@std@@YA$$QAP6AXPAVEmu@gb@emulation@@@ZAAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*)(emulation::gb::Emu *)>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\wincore\types.h
;	COMDAT ??$SafeDelete@Vthread@std@@@@YAXPAPAVthread@std@@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
_ppInterfaceToDelete$ = 8				; size = 4
??$SafeDelete@Vthread@std@@@@YAXPAPAVthread@std@@@Z PROC ; SafeDelete<std::thread>, COMDAT

; 37   : inline void SafeDelete(Interface **ppInterfaceToDelete) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 38   :     if (*ppInterfaceToDelete != NULL) {

	mov	eax, DWORD PTR _ppInterfaceToDelete$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SafeDelete

; 39   :         delete (*ppInterfaceToDelete);

	mov	ecx, DWORD PTR _ppInterfaceToDelete$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN4@SafeDelete
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_Gthread@std@@QAEPAXI@Z
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN5@SafeDelete
$LN4@SafeDelete:
	mov	DWORD PTR tv69[ebp], 0
$LN5@SafeDelete:

; 40   :         (*ppInterfaceToDelete) = NULL;

	mov	ecx, DWORD PTR _ppInterfaceToDelete$[ebp]
	mov	DWORD PTR [ecx], 0
$LN2@SafeDelete:

; 41   :     }
; 42   : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$SafeDelete@Vthread@std@@@@YAXPAPAVthread@std@@@Z ENDP ; SafeDelete<std::thread>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??$?0P6AXPAVEmu@gb@emulation@@@ZQAV012@@thread@std@@QAE@P6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Fx$ = 8						; size = 4
__V0$ = 12						; size = 4
??$?0P6AXPAVEmu@gb@emulation@@@ZQAV012@@thread@std@@QAE@P6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z PROC ; std::thread::thread<void (__cdecl*)(emulation::gb::Emu *),emulation::gb::Emu * const>, COMDAT
; _this$ = ecx

; 52   : _VARIADIC_EXPAND_0X(_THREAD_CONS, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@QAVEmu@gb@emulation@@@std@@YA$$QBQAVEmu@gb@emulation@@ABQAV123@@Z ; std::forward<emulation::gb::Emu * const>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Fx$[ebp]
	push	ecx
	call	??$forward@P6AXPAVEmu@gb@emulation@@@Z@std@@YA$$QAP6AXPAVEmu@gb@emulation@@@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*)(emulation::gb::Emu *)>
	add	esp, 4
	push	eax
	call	??$_Decay_copy@P6AXPAVEmu@gb@emulation@@@Z@std@@YAP6AXPAVEmu@gb@emulation@@@Z$$QAP6AX0@Z@Z ; std::_Decay_copy<void (__cdecl*)(emulation::gb::Emu *)>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??$bind@XPAVEmu@gb@emulation@@QAV123@@std@@YA?AV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@P6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z ; std::bind<void,emulation::gb::Emu *,emulation::gb::Emu * const>
	add	esp, 12					; 0000000cH
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$_Launch@V?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVEmu@gb@emulation@@@ZQAV123@U_Nil@std@@U45@U45@U45@U45@U45@@0@@Z ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(emulation::gb::Emu *),emulation::gb::Emu * const,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0P6AXPAVEmu@gb@emulation@@@ZQAV012@@thread@std@@QAE@P6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z ENDP ; std::thread::thread<void (__cdecl*)(emulation::gb::Emu *),emulation::gb::Emu * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\emu.cpp
_TEXT	SEGMENT
_emu$ = 8						; size = 4
?thread_func@Emu@gb@emulation@@CAXPAV123@@Z PROC	; emulation::gb::Emu::thread_func

; 103  : void Emu::thread_func(Emu* emu) {

	push	ebp
	mov	ebp, esp
	push	esi

; 104  :   memset(&emu->timing,0,sizeof(emu->timing));

	push	80					; 00000050H
	push	0
	mov	eax, DWORD PTR _emu$[ebp]
	add	eax, 3336				; 00000d08H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 105  :   emu->utimer.Calibrate();

	mov	ecx, DWORD PTR _emu$[ebp]
	add	ecx, 56					; 00000038H
	call	?Calibrate@Timer@utilities@@QAEXXZ	; utilities::Timer::Calibrate

; 106  :   emu->timing.prev_cycles = emu->utimer.GetCurrentCycles();

	mov	ecx, DWORD PTR _emu$[ebp]
	add	ecx, 56					; 00000038H
	call	?GetCurrentCycles@Timer@utilities@@QAE_KXZ ; utilities::Timer::GetCurrentCycles
	mov	ecx, DWORD PTR _emu$[ebp]
	mov	DWORD PTR [ecx+3352], eax
	mov	DWORD PTR [ecx+3356], edx
$LN2@thread_fun:

; 107  :   while (emu->state != 0) {

	mov	ecx, DWORD PTR _emu$[ebp]
	add	ecx, 48					; 00000030H
	call	??Batomic_int@std@@QBEHXZ		; std::atomic_int::operator int
	test	eax, eax
	je	SHORT $LN1@thread_fun

; 108  :     emu->Step();

	mov	ecx, DWORD PTR _emu$[ebp]
	call	?Step@Emu@gb@emulation@@QAENXZ		; emulation::gb::Emu::Step
	fstp	ST(0)

; 109  :   }

	jmp	SHORT $LN2@thread_fun
$LN1@thread_fun:

; 110  :   OutputDebugString("end of thread\n");

	mov	esi, esp
	push	OFFSET $SG153879
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 111  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?thread_func@Emu@gb@emulation@@CAXPAV123@@Z ENDP	; emulation::gb::Emu::thread_func
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ PROC ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator(), COMDAT
; _this$ = ecx

; 514  : _VARIADIC_EXPAND_P1_0(_CLASS_FUNC_CLASS_0, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN1@operator
	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_function_call@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator:
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ ENDP ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\emu.cpp
_TEXT	SEGMENT
tv134 = -8						; size = 4
_this$ = -4						; size = 4
?Render@Emu@gb@emulation@@QAEXXZ PROC			; emulation::gb::Emu::Render
; _this$ = ecx

; 92   : void Emu::Render() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 93   :   timing.render_time_span = 0;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [eax+3392], xmm0

; 94   :   ++timing.fps_counter;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3368]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3368], edx

; 95   :   on_render();

	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()

; 96   :   if (timing.fps_time_span >= 1000.0) {

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx+3400]
	comisd	xmm0, QWORD PTR __real@408f400000000000
	jb	SHORT $LN1@Render

; 97   :     timing.fps = timing.fps_counter * (1000.0/timing.fps_time_span);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3368]
	mov	DWORD PTR tv134[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv134[ebp]
	mov	ecx, DWORD PTR tv134[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm1, QWORD PTR __real@408f400000000000
	divsd	xmm1, QWORD PTR [edx+3400]
	mulsd	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [eax+3376], xmm0

; 98   :     timing.fps_counter = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3368], 0

; 99   :     timing.fps_time_span = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [edx+3400], xmm0
$LN1@Render:

; 100  :   }
; 101  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Render@Emu@gb@emulation@@QAEXXZ ENDP			; emulation::gb::Emu::Render
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\emu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Reset@Emu@gb@emulation@@QAEXXZ PROC			; emulation::gb::Emu::Reset
; _this$ = ecx

; 82   : void Emu::Reset() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 83   :   Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@Emu@gb@emulation@@QAEXXZ		; emulation::gb::Emu::Stop

; 84   : 	timer_.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3280				; 00000cd0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+3280]
	mov	esi, esp
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 85   :   lcd_driver_.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2960				; 00000b90H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2960]
	mov	esi, esp
	mov	edx, DWORD PTR [eax+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 86   :   memory_.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2504				; 000009c8H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+2504]
	mov	esi, esp
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 87   :   cpu_.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1416				; 00000588H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1416]
	mov	esi, esp
	mov	edx, DWORD PTR [eax+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 88   :   apu_.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3040				; 00000be0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+3040]
	mov	esi, esp
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 89   :   //Run();
; 90   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@Emu@gb@emulation@@QAEXXZ ENDP			; emulation::gb::Emu::Reset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\emu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Pause@Emu@gb@emulation@@QAEXXZ PROC			; emulation::gb::Emu::Pause
; _this$ = ecx

; 78   : void Emu::Pause() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 79   :   Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@Emu@gb@emulation@@QAEXXZ		; emulation::gb::Emu::Stop

; 80   : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Pause@Emu@gb@emulation@@QAEXXZ ENDP			; emulation::gb::Emu::Pause
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\emu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Stop@Emu@gb@emulation@@QAEXXZ PROC			; emulation::gb::Emu::Stop
; _this$ = ecx

; 70   : void Emu::Stop() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 71   :   if (thread==nullptr && state == 0) return;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3328], 0
	jne	SHORT $LN1@Stop
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??Batomic_int@std@@QBEHXZ		; std::atomic_int::operator int
	test	eax, eax
	jne	SHORT $LN1@Stop
	jmp	SHORT $LN2@Stop
$LN1@Stop:

; 72   :   state = 0;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4?$atomic@H@std@@QAEHH@Z		; std::atomic<int>::operator=

; 73   :   thread->join();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3328]
	call	?join@thread@std@@QAEXXZ		; std::thread::join

; 74   :   OutputDebugString("killed thread\n");

	mov	esi, esp
	push	OFFSET $SG153858
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 75   :   SafeDelete(&thread);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 3328				; 00000d00H
	push	edx
	call	??$SafeDelete@Vthread@std@@@@YAXPAPAVthread@std@@@Z ; SafeDelete<std::thread>
	add	esp, 4
$LN2@Stop:

; 76   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Stop@Emu@gb@emulation@@QAEXXZ ENDP			; emulation::gb::Emu::Stop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\emu.cpp
_TEXT	SEGMENT
tv93 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Run@Emu@gb@emulation@@QAEXXZ PROC			; emulation::gb::Emu::Run
; _this$ = ecx

; 64   : void Emu::Run() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Run@Emu@gb@emulation@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 65   :   if (thread!=nullptr && state == 1) return;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3328], 0
	je	SHORT $LN1@Run
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??Batomic_int@std@@QBEHXZ		; std::atomic_int::operator int
	cmp	eax, 1
	jne	SHORT $LN1@Run
	jmp	SHORT $LN2@Run
$LN1@Run:

; 66   :   state = 1;

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4?$atomic@H@std@@QAEHH@Z		; std::atomic<int>::operator=

; 67   :   thread = new std::thread(Emu::thread_func,this);

	push	67					; 00000043H
	push	OFFSET $SG153852
	push	1
	push	8
	call	??2@YAPAXIHPBDH@Z			; operator new
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN4@Run
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	push	OFFSET ?thread_func@Emu@gb@emulation@@CAXPAV123@@Z ; emulation::gb::Emu::thread_func
	mov	ecx, DWORD PTR $T3[ebp]
	call	??$?0P6AXPAVEmu@gb@emulation@@@ZQAV012@@thread@std@@QAE@P6AXPAVEmu@gb@emulation@@@Z$$QBQAV234@@Z ; std::thread::thread<void (__cdecl*)(emulation::gb::Emu *),emulation::gb::Emu * const>
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN5@Run
$LN4@Run:
	mov	DWORD PTR tv93[ebp], 0
$LN5@Run:
	mov	eax, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR [ecx+3328], edx
$LN2@Run:

; 68   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Run@Emu@gb@emulation@@QAEXXZ$0:
	push	67					; 00000043H
	push	OFFSET $SG153853
	push	1
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAXHPBDH@Z			; operator delete
	add	esp, 16					; 00000010H
	ret	0
__ehhandler$?Run@Emu@gb@emulation@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Run@Emu@gb@emulation@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Run@Emu@gb@emulation@@QAEXXZ ENDP			; emulation::gb::Emu::Run
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\emu.cpp
_TEXT	SEGMENT
tv223 = -100						; size = 8
tv220 = -92						; size = 8
tv213 = -84						; size = 8
tv210 = -76						; size = 8
tv193 = -68						; size = 8
tv257 = -60						; size = 8
tv188 = -52						; size = 8
tv185 = -44						; size = 8
tv178 = -36						; size = 8
tv175 = -28						; size = 8
_time_span$ = -20					; size = 8
_dt$ = -12						; size = 8
_this$ = -4						; size = 4
?Step@Emu@gb@emulation@@QAENXZ PROC			; emulation::gb::Emu::Step
; _this$ = ecx

; 45   : double Emu::Step() {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-100]
	mov	ecx, 25					; 00000019H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 46   :   const double dt =  1000.0 / emulation::gb::clockspeed;//options.cpu_freq(); 0.00058f;//16.667f;

	movsd	xmm0, QWORD PTR __real@408f400000000000
	divsd	xmm0, QWORD PTR _clockspeed
	movsd	QWORD PTR _dt$[ebp], xmm0

; 47   :   timing.current_cycles = utimer.GetCurrentCycles();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	?GetCurrentCycles@Timer@utilities@@QAE_KXZ ; utilities::Timer::GetCurrentCycles
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3344], eax
	mov	DWORD PTR [ecx+3348], edx

; 48   :   double time_span =  (timing.current_cycles - timing.prev_cycles) * utimer.resolution();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+3344]
	sub	ecx, DWORD PTR [eax+3352]
	mov	edx, DWORD PTR [edx+3348]
	sbb	edx, DWORD PTR [eax+3356]
	mov	DWORD PTR tv175[ebp], ecx
	mov	DWORD PTR tv175[ebp+4], edx
	mov	eax, DWORD PTR tv175[ebp+4]
	mov	DWORD PTR tv178[ebp+4], eax
	and	DWORD PTR tv175[ebp+4], 2147483647	; 7fffffffH
	fild	QWORD PTR tv175[ebp]
	and	DWORD PTR tv178[ebp+4], -2147483648	; 80000000H
	mov	DWORD PTR tv178[ebp], 0
	fild	QWORD PTR tv178[ebp]
	fchs
	faddp	ST(1), ST(0)
	fstp	QWORD PTR tv185[ebp]
	fld	QWORD PTR tv185[ebp]
	fstp	QWORD PTR tv188[ebp]
	movsd	xmm0, QWORD PTR tv188[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	movsd	QWORD PTR tv257[ebp], xmm0
	call	?resolution@Timer@utilities@@QAENXZ	; utilities::Timer::resolution
	fstp	QWORD PTR tv193[ebp]
	movsd	xmm0, QWORD PTR tv257[ebp]
	mulsd	xmm0, QWORD PTR tv193[ebp]
	movsd	QWORD PTR _time_span$[ebp], xmm0

; 49   :   if (time_span > 250.0) //clamping time

	movsd	xmm0, QWORD PTR _time_span$[ebp]
	comisd	xmm0, QWORD PTR __real@406f400000000000
	jbe	SHORT $LN3@Step

; 50   :     time_span = 250.0;

	movsd	xmm0, QWORD PTR __real@406f400000000000
	movsd	QWORD PTR _time_span$[ebp], xmm0
$LN3@Step:

; 51   : 
; 52   :   timing.span_accumulator += time_span;

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx+3408]
	addsd	xmm0, QWORD PTR _time_span$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [edx+3408], xmm0
$LN2@Step:

; 53   :   while (timing.span_accumulator >= dt) {

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+3408]
	comisd	xmm0, QWORD PTR _dt$[ebp]
	jb	$LN1@Step

; 54   :     cpu_.Step(dt);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _dt$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1416				; 00000588H
	call	?Step@Cpu@gb@emulation@@QAEXN@Z		; emulation::gb::Cpu::Step

; 55   :     timing.span_accumulator -= dt*cpu_.cycles;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1432]
	mov	eax, DWORD PTR [ecx+1436]
	mov	DWORD PTR tv210[ebp], edx
	mov	DWORD PTR tv210[ebp+4], eax
	mov	ecx, DWORD PTR tv210[ebp+4]
	mov	DWORD PTR tv213[ebp+4], ecx
	and	DWORD PTR tv210[ebp+4], 2147483647	; 7fffffffH
	fild	QWORD PTR tv210[ebp]
	and	DWORD PTR tv213[ebp+4], -2147483648	; 80000000H
	mov	DWORD PTR tv213[ebp], 0
	fild	QWORD PTR tv213[ebp]
	fchs
	faddp	ST(1), ST(0)
	fstp	QWORD PTR tv220[ebp]
	fld	QWORD PTR tv220[ebp]
	fstp	QWORD PTR tv223[ebp]
	movsd	xmm0, QWORD PTR tv223[ebp]
	mulsd	xmm0, QWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm1, QWORD PTR [edx+3408]
	subsd	xmm1, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [eax+3408], xmm1

; 56   :   }

	jmp	$LN2@Step
$LN1@Step:

; 57   : 
; 58   :   timing.total_cycles += timing.current_cycles-timing.prev_cycles;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+3344]
	sub	eax, DWORD PTR [edx+3352]
	mov	ecx, DWORD PTR [ecx+3348]
	sbb	ecx, DWORD PTR [edx+3356]
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+3360]
	adc	ecx, DWORD PTR [edx+3364]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3360], eax
	mov	DWORD PTR [edx+3364], ecx

; 59   :   timing.prev_cycles = timing.current_cycles;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3344]
	mov	DWORD PTR [eax+3352], edx
	mov	ecx, DWORD PTR [ecx+3348]
	mov	DWORD PTR [eax+3356], ecx

; 60   :   timing.fps_time_span += time_span;

	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [edx+3400]
	addsd	xmm0, QWORD PTR _time_span$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [eax+3400], xmm0

; 61   :   return timing.span_accumulator;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	QWORD PTR [ecx+3408]

; 62   : }

	pop	edi
	add	esp, 100				; 00000064H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Step@Emu@gb@emulation@@QAENXZ ENDP			; emulation::gb::Emu::Step
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\emu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Deinitialize@Emu@gb@emulation@@QAEXXZ PROC		; emulation::gb::Emu::Deinitialize
; _this$ = ecx

; 35   : void Emu::Deinitialize() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 36   :   Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@Emu@gb@emulation@@QAEXXZ		; emulation::gb::Emu::Stop

; 37   :   apu_.Deinitialize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3040				; 00000be0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+3040]
	mov	esi, esp
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 38   :   cpu_.Deinitialize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1416				; 00000588H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1416]
	mov	esi, esp
	mov	edx, DWORD PTR [eax+4]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 39   :   memory_.Deinitialize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2504				; 000009c8H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+2504]
	mov	esi, esp
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 40   :   lcd_driver_.Deinitialize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2960				; 00000b90H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2960]
	mov	esi, esp
	mov	edx, DWORD PTR [eax+4]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 41   : 	timer_.Deinitialize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3280				; 00000cd0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+3280]
	mov	esi, esp
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 42   :   cartridge_.Deinitialize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	esi, esp
	mov	edx, DWORD PTR [eax+4]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 43   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Deinitialize@Emu@gb@emulation@@QAEXXZ ENDP		; emulation::gb::Emu::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\emu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Initialize@Emu@gb@emulation@@QAEXXZ PROC		; emulation::gb::Emu::Initialize
; _this$ = ecx

; 24   : void Emu::Initialize() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 25   :   cartridge_.Initialize(this);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	edx, DWORD PTR [eax]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 26   : 	timer_.Initialize(this);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3280				; 00000cd0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3280]
	mov	edx, DWORD PTR [eax]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 27   :   lcd_driver_.Initialize(this);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2960				; 00000b90H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2960]
	mov	edx, DWORD PTR [eax]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 28   :   memory_.Initialize(this);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2504				; 000009c8H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2504]
	mov	edx, DWORD PTR [eax]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 29   :   cpu_.Initialize(this);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1416				; 00000588H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1416]
	mov	edx, DWORD PTR [eax]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 30   :   apu_.Initialize(this);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3040				; 00000be0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3040]
	mov	edx, DWORD PTR [eax]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 31   :   thread = null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3328], 0

; 32   :   state = 0;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4?$atomic@H@std@@QAEHH@Z		; std::atomic<int>::operator=

; 33   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Initialize@Emu@gb@emulation@@QAEXXZ ENDP		; emulation::gb::Emu::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\wincore\timer\timer2.h
;	COMDAT ?GetCurrentCycles@Timer@utilities@@QAE_KXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentCycles@Timer@utilities@@QAE_KXZ PROC		; utilities::Timer::GetCurrentCycles, COMDAT
; _this$ = ecx

; 68   :   __forceinline uint64_t GetCurrentCycles() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 69   :     QueryPerformanceCounter((LARGE_INTEGER*)&current_cycles_);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 70   :     return current_cycles_; 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR [ecx+20]

; 71   :   }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentCycles@Timer@utilities@@QAE_KXZ ENDP		; utilities::Timer::GetCurrentCycles
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\wincore\timer\timer2.h
;	COMDAT ?resolution@Timer@utilities@@QAENXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?resolution@Timer@utilities@@QAENXZ PROC		; utilities::Timer::resolution, COMDAT
; _this$ = ecx

; 45   :   __forceinline double resolution() { return resolution_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	QWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?resolution@Timer@utilities@@QAENXZ ENDP		; utilities::Timer::resolution
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\wincore\timer\timer2.h
;	COMDAT ?Calibrate@Timer@utilities@@QAEXXZ
_TEXT	SEGMENT
tv137 = -36						; size = 8
tv134 = -28						; size = 8
tv95 = -20						; size = 8
tv92 = -12						; size = 8
_this$ = -4						; size = 4
?Calibrate@Timer@utilities@@QAEXXZ PROC			; utilities::Timer::Calibrate, COMDAT
; _this$ = ecx

; 36   :   void Calibrate() {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 37   :     start_cycles_ = GetCurrentCycles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCurrentCycles@Timer@utilities@@QAE_KXZ ; utilities::Timer::GetCurrentCycles
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], edx

; 38   :     QueryPerformanceFrequency((LARGE_INTEGER*)&frequency_);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 39   :     resolution_ = 1000.0 / frequency_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR tv92[ebp], ecx
	mov	DWORD PTR tv92[ebp+4], edx
	mov	eax, DWORD PTR tv92[ebp+4]
	mov	DWORD PTR tv95[ebp+4], eax
	and	DWORD PTR tv92[ebp+4], 2147483647	; 7fffffffH
	fild	QWORD PTR tv92[ebp]
	and	DWORD PTR tv95[ebp+4], -2147483648	; 80000000H
	mov	DWORD PTR tv95[ebp], 0
	fild	QWORD PTR tv95[ebp]
	fchs
	faddp	ST(1), ST(0)
	fstp	QWORD PTR tv134[ebp]
	fld	QWORD PTR tv134[ebp]
	fstp	QWORD PTR tv137[ebp]
	movsd	xmm0, QWORD PTR __real@408f400000000000
	divsd	xmm0, QWORD PTR tv137[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+48], xmm0

; 40   :     resolution_ns_ = 1000000 / frequency_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	push	ecx
	push	0
	push	1000000					; 000f4240H
	call	__aulldiv
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [ecx+36], edx

; 41   :   }

	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Calibrate@Timer@utilities@@QAEXXZ ENDP			; utilities::Timer::Calibrate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xxatomic
;	COMDAT ?atomic_load@std@@YAHPBUatomic_int@1@@Z
_TEXT	SEGMENT
__Atom$ = 8						; size = 4
?atomic_load@std@@YAHPBUatomic_int@1@@Z PROC		; std::atomic_load, COMDAT

; 667  : 	{	// return value stored in *_Atom

	push	ebp
	mov	ebp, esp

; 668  : 	return atomic_load_explicit(_Atom, memory_order_seq_cst);

	push	5
	mov	eax, DWORD PTR __Atom$[ebp]
	push	eax
	call	?atomic_load_explicit@std@@YAHPBUatomic_int@1@W4memory_order@1@@Z ; std::atomic_load_explicit
	add	esp, 8

; 669  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?atomic_load@std@@YAHPBUatomic_int@1@@Z ENDP		; std::atomic_load
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xxatomic
;	COMDAT ?atomic_load_explicit@std@@YAHPBUatomic_int@1@W4memory_order@1@@Z
_TEXT	SEGMENT
__Atom$ = 8						; size = 4
__Order$ = 12						; size = 4
?atomic_load_explicit@std@@YAHPBUatomic_int@1@W4memory_order@1@@Z PROC ; std::atomic_load_explicit, COMDAT

; 655  : 	{	// return value held in *_Atom

	push	ebp
	mov	ebp, esp

; 656  : 	return _ATOMIC_LOAD(_Atom, _Order);

	mov	eax, DWORD PTR __Order$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Atom$[ebp]
	push	ecx
	call	?_Atomic_load_4@std@@YAKPCKW4memory_order@1@@Z ; std::_Atomic_load_4
	add	esp, 8

; 657  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?atomic_load_explicit@std@@YAHPBUatomic_int@1@W4memory_order@1@@Z ENDP ; std::atomic_load_explicit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xxatomic
;	COMDAT ?atomic_store@std@@YAXPAUatomic_int@1@H@Z
_TEXT	SEGMENT
__Atom$ = 8						; size = 4
__Value$ = 12						; size = 4
?atomic_store@std@@YAXPAUatomic_int@1@H@Z PROC		; std::atomic_store, COMDAT

; 643  : 	{	// store _Value into *_Atom

	push	ebp
	mov	ebp, esp

; 644  : 	atomic_store_explicit(_Atom, _Value, memory_order_seq_cst);

	push	5
	mov	eax, DWORD PTR __Value$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Atom$[ebp]
	push	ecx
	call	?atomic_store_explicit@std@@YAXPAUatomic_int@1@HW4memory_order@1@@Z ; std::atomic_store_explicit
	add	esp, 12					; 0000000cH

; 645  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?atomic_store@std@@YAXPAUatomic_int@1@H@Z ENDP		; std::atomic_store
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xxatomic
;	COMDAT ?atomic_store_explicit@std@@YAXPAUatomic_int@1@HW4memory_order@1@@Z
_TEXT	SEGMENT
__Atom$ = 8						; size = 4
__Value$ = 12						; size = 4
__Order$ = 16						; size = 4
?atomic_store_explicit@std@@YAXPAUatomic_int@1@HW4memory_order@1@@Z PROC ; std::atomic_store_explicit, COMDAT

; 630  : 	{	// store _Value into *_Atom

	push	ebp
	mov	ebp, esp

; 631  : 	assert(_ISIZE == sizeof (_ITYPE));
; 632  : 	_ATOMIC_STORE(_Atom, _Value, _Order);

	mov	eax, DWORD PTR __Order$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Value$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Atom$[ebp]
	push	edx
	call	?_Atomic_store_4@std@@YAXPCKKW4memory_order@1@@Z ; std::_Atomic_store_4
	add	esp, 12					; 0000000cH

; 633  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?atomic_store_explicit@std@@YAXPAUatomic_int@1@HW4memory_order@1@@Z ENDP ; std::atomic_store_explicit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xxatomic
;	COMDAT ??4?$atomic@H@std@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??4?$atomic@H@std@@QAEHH@Z PROC				; std::atomic<int>::operator=, COMDAT
; _this$ = ecx

; 273  : 		{	// assign from _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 		return _ATOMIC_ITYPE::operator=(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4atomic_int@std@@QAEHH@Z		; std::atomic_int::operator=

; 275  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$atomic@H@std@@QAEHH@Z ENDP				; std::atomic<int>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xxatomic
;	COMDAT ??Batomic_int@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Batomic_int@std@@QBEHXZ PROC				; std::atomic_int::operator int, COMDAT
; _this$ = ecx

; 886  : 	{	// return value held in *this

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 	return atomic_load(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?atomic_load@std@@YAHPBUatomic_int@1@@Z	; std::atomic_load
	add	esp, 4

; 888  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Batomic_int@std@@QBEHXZ ENDP				; std::atomic_int::operator int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xxatomic
;	COMDAT ??4atomic_int@std@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Value$ = 8						; size = 4
??4atomic_int@std@@QAEHH@Z PROC				; std::atomic_int::operator=, COMDAT
; _this$ = ecx

; 841  : 	{	// assign _Value to *this

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 842  : 	atomic_store(this, _Value);

	mov	eax, DWORD PTR __Value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?atomic_store@std@@YAXPAUatomic_int@1@H@Z ; std::atomic_store
	add	esp, 8

; 843  : 	return _Value;

	mov	eax, DWORD PTR __Value$[ebp]

; 844  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4atomic_int@std@@QAEHH@Z ENDP				; std::atomic_int::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic.h
;	COMDAT ?_Load_seq_cst_4@std@@YAKPCK@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
__Value$ = -4						; size = 4
__Tgt$ = 8						; size = 4
?_Load_seq_cst_4@std@@YAKPCK@Z PROC			; std::_Load_seq_cst_4, COMDAT

; 1520 : 	{	/* load from *_Tgt atomically with

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1521 : 			sequentially consistent memory order */
; 1522 : 	_Uint4_t _Value;
; 1523 : 
; 1524 :  #if defined(_M_ARM)
; 1525 : 	_Memory_barrier();
; 1526 : 	_Value = __iso_volatile_load32((volatile int *)_Tgt);
; 1527 : 	_Memory_barrier();
; 1528 :  #else
; 1529 : 	_Value = _InterlockedOr((volatile long *)_Tgt, 0);

	xor	ecx, ecx
	mov	edx, DWORD PTR __Tgt$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	mov	edx, DWORD PTR tv68[ebp]
	mov	eax, DWORD PTR [edx]
$LN3@Load_seq_c:
	mov	esi, eax
	or	esi, ecx
	lock	 cmpxchg DWORD PTR [edx], esi
	jne	SHORT $LN3@Load_seq_c
	mov	DWORD PTR __Value$[ebp], eax

; 1530 :  #endif
; 1531 : 
; 1532 : 	return (_Value);

	mov	eax, DWORD PTR __Value$[ebp]

; 1533 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?_Load_seq_cst_4@std@@YAKPCK@Z ENDP			; std::_Load_seq_cst_4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic.h
;	COMDAT ?_Load_acquire_4@std@@YAKPCK@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
__Value$ = -4						; size = 4
__Tgt$ = 8						; size = 4
?_Load_acquire_4@std@@YAKPCK@Z PROC			; std::_Load_acquire_4, COMDAT

; 1505 : 	{	/* load from *_Tgt atomically with

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1506 : 			acquire memory order */
; 1507 : 	_Uint4_t _Value;
; 1508 : 
; 1509 :  #if defined(_M_ARM)
; 1510 : 	_Value = __iso_volatile_load32((volatile int *)_Tgt);
; 1511 : 	_Memory_barrier();
; 1512 :  #else
; 1513 : 	_Value = _InterlockedOr((volatile long *)_Tgt, 0);

	xor	ecx, ecx
	mov	edx, DWORD PTR __Tgt$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	mov	edx, DWORD PTR tv68[ebp]
	mov	eax, DWORD PTR [edx]
$LN3@Load_acqui:
	mov	esi, eax
	or	esi, ecx
	lock	 cmpxchg DWORD PTR [edx], esi
	jne	SHORT $LN3@Load_acqui
	mov	DWORD PTR __Value$[ebp], eax

; 1514 :  #endif
; 1515 : 
; 1516 : 	return (_Value);

	mov	eax, DWORD PTR __Value$[ebp]

; 1517 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?_Load_acquire_4@std@@YAKPCK@Z ENDP			; std::_Load_acquire_4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic.h
;	COMDAT ?_Load_relaxed_4@std@@YAKPCK@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
__Value$ = -4						; size = 4
__Tgt$ = 8						; size = 4
?_Load_relaxed_4@std@@YAKPCK@Z PROC			; std::_Load_relaxed_4, COMDAT

; 1491 : 	{	/* load from *_Tgt atomically with

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1492 : 			relaxed memory order */
; 1493 : 	_Uint4_t _Value;
; 1494 : 
; 1495 :  #if defined(_M_ARM)
; 1496 : 	_Value = __iso_volatile_load32((volatile int *)_Tgt);
; 1497 :  #else
; 1498 : 	_Value = _InterlockedOr((volatile long *)_Tgt, 0);

	xor	ecx, ecx
	mov	edx, DWORD PTR __Tgt$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	mov	edx, DWORD PTR tv68[ebp]
	mov	eax, DWORD PTR [edx]
$LN3@Load_relax:
	mov	esi, eax
	or	esi, ecx
	lock	 cmpxchg DWORD PTR [edx], esi
	jne	SHORT $LN3@Load_relax
	mov	DWORD PTR __Value$[ebp], eax

; 1499 :  #endif
; 1500 : 
; 1501 : 	return (_Value);

	mov	eax, DWORD PTR __Value$[ebp]

; 1502 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?_Load_relaxed_4@std@@YAKPCK@Z ENDP			; std::_Load_relaxed_4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic.h
;	COMDAT ?_Atomic_store_4@std@@YAXPCKKW4memory_order@1@@Z
_TEXT	SEGMENT
tv64 = -4						; size = 4
__Tgt$ = 8						; size = 4
__Value$ = 12						; size = 4
__Order$ = 16						; size = 4
?_Atomic_store_4@std@@YAXPCKKW4memory_order@1@@Z PROC	; std::_Atomic_store_4, COMDAT

; 1471 : 	{	/* store _Value atomically */

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1472 : 	switch(_Order)

	mov	eax, DWORD PTR __Order$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 0
	je	SHORT $LN4@Atomic_sto
	cmp	DWORD PTR tv64[ebp], 3
	je	SHORT $LN3@Atomic_sto
	cmp	DWORD PTR tv64[ebp], 5
	je	SHORT $LN2@Atomic_sto
	jmp	SHORT $LN1@Atomic_sto
$LN4@Atomic_sto:

; 1473 : 		{
; 1474 : 		case memory_order_relaxed:
; 1475 : 			_Store_relaxed_4(_Tgt, _Value);

	mov	ecx, DWORD PTR __Value$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tgt$[ebp]
	push	edx
	call	?_Store_relaxed_4@std@@YAXPCKK@Z	; std::_Store_relaxed_4
	add	esp, 8

; 1476 : 			break;

	jmp	$LN7@Atomic_sto
$LN3@Atomic_sto:

; 1477 : 		case memory_order_release:
; 1478 : 			_Store_release_4(_Tgt, _Value);

	mov	eax, DWORD PTR __Value$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Tgt$[ebp]
	push	ecx
	call	?_Store_release_4@std@@YAXPCKK@Z	; std::_Store_release_4
	add	esp, 8

; 1479 : 			break;

	jmp	$LN7@Atomic_sto
$LN2@Atomic_sto:

; 1480 : 		case memory_order_seq_cst:
; 1481 : 			_Store_seq_cst_4(_Tgt, _Value);

	mov	edx, DWORD PTR __Value$[ebp]
	push	edx
	mov	eax, DWORD PTR __Tgt$[ebp]
	push	eax
	call	?_Store_seq_cst_4@std@@YAXPCKK@Z	; std::_Store_seq_cst_4
	add	esp, 8

; 1482 : 			break;

	jmp	$LN7@Atomic_sto
$LN1@Atomic_sto:

; 1483 : 		default:
; 1484 : 			_INVALID_MEMORY_ORDER;

	mov	esi, esp
	push	1484					; 000005ccH
	push	OFFSET ??_C@_1JC@OFINEDFE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1CK@BEGEBJJG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
	test	ecx, ecx
	je	SHORT $LN9@Atomic_sto
	xor	edx, edx
	jne	SHORT $LN10@Atomic_sto
$LN9@Atomic_sto:
	mov	esi, esp
	push	OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	1484					; 000005ccH
	push	OFFSET ??_C@_1JC@OFINEDFE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN10@Atomic_sto
	int	3
$LN10@Atomic_sto:
	mov	esi, esp
	push	0
	push	1484					; 000005ccH
	push	OFFSET ??_C@_1JC@OFINEDFE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1CK@BEBCCGEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAs?$AAt?$AAo?$AAr?$AAe?$AA_?$AA4?$AA?$AA@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@Atomic_sto:

; 1485 : 			break;
; 1486 : 		}
; 1487 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Atomic_store_4@std@@YAXPCKKW4memory_order@1@@Z ENDP	; std::_Atomic_store_4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic.h
;	COMDAT ?_Store_seq_cst_4@std@@YAXPCKK@Z
_TEXT	SEGMENT
__Tgt$ = 8						; size = 4
__Value$ = 12						; size = 4
?_Store_seq_cst_4@std@@YAXPCKK@Z PROC			; std::_Store_seq_cst_4, COMDAT

; 1458 : 	{	/* store _Value atomically with

	push	ebp
	mov	ebp, esp

; 1459 : 			sequentially consistent memory order */
; 1460 :  #if defined(_M_ARM)
; 1461 : 	_Memory_barrier();
; 1462 : 	__iso_volatile_store32((volatile int *)_Tgt, _Value);
; 1463 : 	_Memory_barrier();
; 1464 :  #else
; 1465 : 	_InterlockedExchange((volatile long *)_Tgt, _Value);

	mov	eax, DWORD PTR __Value$[ebp]
	mov	ecx, DWORD PTR __Tgt$[ebp]
	xchg	DWORD PTR [ecx], eax

; 1466 :  #endif
; 1467 : 	}

	pop	ebp
	ret	0
?_Store_seq_cst_4@std@@YAXPCKK@Z ENDP			; std::_Store_seq_cst_4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic.h
;	COMDAT ?_Store_release_4@std@@YAXPCKK@Z
_TEXT	SEGMENT
__Tgt$ = 8						; size = 4
__Value$ = 12						; size = 4
?_Store_release_4@std@@YAXPCKK@Z PROC			; std::_Store_release_4, COMDAT

; 1436 : 	{	/* store _Value atomically with release memory order */

	push	ebp
	mov	ebp, esp

; 1437 :  #if defined(_M_ARM)
; 1438 : 	_Memory_barrier();
; 1439 : 	__iso_volatile_store32((volatile int *)_Tgt, _Value);
; 1440 :  #elif _MS_32
; 1441 : 	_Compiler_barrier();
; 1442 : 	__asm
; 1443 : 		{
; 1444 : 		mov eax, _Value;

	mov	eax, DWORD PTR __Value$[ebp]

; 1445 : 		mov edx, _Tgt;

	mov	edx, DWORD PTR __Tgt$[ebp]

; 1446 : 		mov [edx], eax;

	mov	DWORD PTR [edx], eax

; 1447 : 		}
; 1448 : 	_Compiler_barrier();
; 1449 : 
; 1450 :  #elif _MS_64
; 1451 : 	_Compiler_barrier();
; 1452 : 	*_Tgt = _Value;
; 1453 : 	_Compiler_barrier();
; 1454 :  #endif /* _MS_32 */
; 1455 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_Store_release_4@std@@YAXPCKK@Z ENDP			; std::_Store_release_4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic.h
;	COMDAT ?_Store_relaxed_4@std@@YAXPCKK@Z
_TEXT	SEGMENT
__Tgt$ = 8						; size = 4
__Value$ = 12						; size = 4
?_Store_relaxed_4@std@@YAXPCKK@Z PROC			; std::_Store_relaxed_4, COMDAT

; 1415 : 	{	/* store _Value atomically with relaxed memory order */

	push	ebp
	mov	ebp, esp

; 1416 :  #if defined(_M_ARM)
; 1417 : 	__iso_volatile_store32((volatile int *)_Tgt, _Value);
; 1418 :  #elif _MS_32
; 1419 : 	_Compiler_barrier();
; 1420 : 	__asm
; 1421 : 		{
; 1422 : 		mov eax, _Value;

	mov	eax, DWORD PTR __Value$[ebp]

; 1423 : 		mov edx, _Tgt;

	mov	edx, DWORD PTR __Tgt$[ebp]

; 1424 : 		mov [edx], eax;

	mov	DWORD PTR [edx], eax

; 1425 : 		}
; 1426 : 	_Compiler_barrier();
; 1427 : 
; 1428 :  #elif _MS_64
; 1429 : 	_Compiler_barrier();
; 1430 : 	*_Tgt = _Value;
; 1431 : 	_Compiler_barrier();
; 1432 :  #endif /* _MS_32 */
; 1433 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_Store_relaxed_4@std@@YAXPCKK@Z ENDP			; std::_Store_relaxed_4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??8std@@YA_NVid@thread@0@0@Z
_TEXT	SEGMENT
tv68 = -1						; size = 1
__Left$ = 8						; size = 8
__Right$ = 16						; size = 8
??8std@@YA_NVid@thread@0@0@Z PROC			; std::operator==, COMDAT

; 238  : 	{	// return true if _Left and _Right identify the same thread

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 239  : 	return (_Thrd_equal(_Left._Thr, _Right._Thr));

	mov	esi, esp
	mov	eax, DWORD PTR __Right$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Left$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	call	DWORD PTR __imp___Thrd_equal
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv68[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv68[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv68[ebp]

; 240  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??8std@@YA_NVid@thread@0@0@Z ENDP			; std::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??0id@thread@std@@AAE@U_Thrd_imp_t@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Thrd$ = 8						; size = 8
??0id@thread@std@@AAE@U_Thrd_imp_t@@@Z PROC		; std::thread::id::id, COMDAT
; _this$ = ecx

; 198  : 		{	// construct from thread identifier

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Thrd$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Thrd$[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 199  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0id@thread@std@@AAE@U_Thrd_imp_t@@@Z ENDP		; std::thread::id::id
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??0id@thread@std@@AAE@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Thrd$ = 8						; size = 4
??0id@thread@std@@AAE@ABV12@@Z PROC			; std::thread::id::id, COMDAT
; _this$ = ecx

; 193  : 		{	// construct from thread object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Thrd$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 194  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@thread@std@@AAE@ABV12@@Z ENDP			; std::thread::id::id
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ?get_id@this_thread@std@@YA?AVid@thread@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?get_id@this_thread@std@@YA?AVid@thread@2@XZ PROC	; std::this_thread::get_id, COMDAT

; 228  : 	{	// return id for current thread

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 229  : 	return (_Thrd_current());

	mov	esi, esp
	call	DWORD PTR __imp___Thrd_current
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
	mov	eax, DWORD PTR $T1[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0id@thread@std@@AAE@U_Thrd_imp_t@@@Z	; std::thread::id::id
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 230  : 	}

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?get_id@this_thread@std@@YA?AVid@thread@2@XZ ENDP	; std::this_thread::get_id
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gthread@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gthread@std@@QAEPAXI@Z PROC				; std::thread::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1thread@std@@QAE@XZ			; std::thread::~thread
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gthread@std@@QAEPAXI@Z ENDP				; std::thread::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ?get_id@thread@std@@QBE?AVid@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?get_id@thread@std@@QBE?AVid@12@XZ PROC			; std::thread::get_id, COMDAT
; _this$ = ecx

; 223  : 	{	// return id for this thread

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 	return (id(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0id@thread@std@@AAE@ABV12@@Z		; std::thread::id::id
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 225  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?get_id@thread@std@@QBE?AVid@12@XZ ENDP			; std::thread::get_id
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ?join@thread@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -20						; size = 8
$T2 = -12						; size = 8
_this$ = -4						; size = 4
?join@thread@std@@QAEXXZ PROC				; std::thread::join, COMDAT
; _this$ = ecx

; 210  : 	{	// join thread

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 211  : 	if (!joinable())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?joinable@thread@std@@QBE_NXZ		; std::thread::joinable
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@join

; 212  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp_?_Throw_Cpp_error@std@@YAXH@Z
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@join:

; 213  : 	if (_Thr_is_null(_Thr))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN3@join

; 214  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp_?_Throw_Cpp_error@std@@YAXH@Z
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@join:

; 215  : 	if (get_id() == _STD this_thread::get_id())

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	?get_id@this_thread@std@@YA?AVid@thread@2@XZ ; std::this_thread::get_id
	add	esp, 4
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get_id@thread@std@@QBE?AVid@12@XZ	; std::thread::get_id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	??8std@@YA_NVid@thread@0@0@Z		; std::operator==
	add	esp, 16					; 00000010H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@join

; 216  : 		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

	mov	esi, esp
	push	5
	call	DWORD PTR __imp_?_Throw_Cpp_error@std@@YAXH@Z
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@join:

; 217  : 	if (_Thrd_join(_Thr, 0) != _Thrd_success)

	mov	esi, esp
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR __imp___Thrd_join
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@join

; 218  : 		_Throw_Cpp_error(_NO_SUCH_PROCESS);

	mov	esi, esp
	push	2
	call	DWORD PTR __imp_?_Throw_Cpp_error@std@@YAXH@Z
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@join:

; 219  : 	_Thr_set_null(_Thr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 220  : 	}

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?join@thread@std@@QAEXXZ ENDP				; std::thread::join
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ?joinable@thread@std@@QBE_NXZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?joinable@thread@std@@QBE_NXZ PROC			; std::thread::joinable, COMDAT
; _this$ = ecx

; 82   : 		{	// return true if this thread can be joined

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 		return (!_Thr_is_null(_Thr));

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@joinable
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@joinable
$LN3@joinable:
	mov	DWORD PTR tv67[ebp], 0
$LN4@joinable:
	mov	al, BYTE PTR tv67[ebp]

; 84   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?joinable@thread@std@@QBE_NXZ ENDP			; std::thread::joinable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??1thread@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1thread@std@@QAE@XZ PROC				; std::thread::~thread, COMDAT
; _this$ = ecx

; 56   : 		{	// clean up

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 		if (joinable())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?joinable@thread@std@@QBE_NXZ		; std::thread::joinable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@thread

; 58   : 			_XSTD terminate();

	mov	esi, esp
	call	DWORD PTR __imp_?terminate@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@thread:

; 59   : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1thread@std@@QAE@XZ ENDP				; std::thread::~thread
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@@std@@YA$$QAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@@std@@YA$$QAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AAV10@@Z PROC ; std::forward<std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@@std@@YA$$QAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AAV10@@Z ENDP ; std::forward<std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ?tie@std@@YA?AV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?tie@std@@YA?AV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@1@XZ PROC ; std::tie, COMDAT

; 725  : _VARIADIC_EXPAND_0X(_TUPLE_TIE, , , , )

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@QAE@XZ ; std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?tie@std@@YA?AV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@1@XZ ENDP ; std::tie
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@QAE@ABV01@@Z PROC ; std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>, COMDAT
; _this$ = ecx

; 226  : 	tuple(const tuple&) _NOEXCEPT

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 227  : 		{	// copy construct
; 228  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@QAE@ABV01@@Z ENDP ; std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@QAE@XZ PROC ; std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>, COMDAT
; _this$ = ecx

; 217  : 	tuple()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 218  : 		{	// default construct
; 219  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@QAE@XZ ENDP ; std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 137  : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$yc	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 130  : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Ignore@std@@QAE@XZ PROC				; std::_Ignore::_Ignore, COMDAT
; _this$ = ecx

; 120  : 	_Ignore()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Ignore@std@@QAE@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic.h
;	COMDAT ?_Atomic_load_4@std@@YAKPCKW4memory_order@1@@Z
_TEXT	SEGMENT
tv64 = -4						; size = 4
__Tgt$ = 8						; size = 4
__Order$ = 12						; size = 4
?_Atomic_load_4@std@@YAKPCKW4memory_order@1@@Z PROC	; std::_Atomic_load_4, COMDAT

; 1537 : 	{	/* load from *_Tgt atomically */

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1538 : 	switch(_Order)

	mov	eax, DWORD PTR __Order$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 5
	ja	SHORT $LN1@Atomic_loa
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN11@Atomic_loa[ecx*4]
$LN4@Atomic_loa:

; 1539 : 		{
; 1540 : 		case memory_order_relaxed:
; 1541 : 			return (_Load_relaxed_4(_Tgt));

	mov	edx, DWORD PTR __Tgt$[ebp]
	push	edx
	call	?_Load_relaxed_4@std@@YAKPCK@Z		; std::_Load_relaxed_4
	add	esp, 4
	jmp	$LN7@Atomic_loa
$LN3@Atomic_loa:

; 1542 : 
; 1543 : 		case memory_order_consume:
; 1544 : 		case memory_order_acquire:
; 1545 : 			return (_Load_acquire_4(_Tgt));

	mov	eax, DWORD PTR __Tgt$[ebp]
	push	eax
	call	?_Load_acquire_4@std@@YAKPCK@Z		; std::_Load_acquire_4
	add	esp, 4
	jmp	$LN7@Atomic_loa
$LN2@Atomic_loa:

; 1546 : 
; 1547 : 		case memory_order_seq_cst:
; 1548 : 			return (_Load_seq_cst_4(_Tgt));

	mov	ecx, DWORD PTR __Tgt$[ebp]
	push	ecx
	call	?_Load_seq_cst_4@std@@YAKPCK@Z		; std::_Load_seq_cst_4
	add	esp, 4
	jmp	$LN7@Atomic_loa
$LN1@Atomic_loa:

; 1549 : 
; 1550 : 		default:
; 1551 : 			_INVALID_MEMORY_ORDER;

	mov	esi, esp
	push	1551					; 0000060fH
	push	OFFSET ??_C@_1JC@OFINEDFE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1CK@BEGEBJJG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
	test	edx, edx
	je	SHORT $LN9@Atomic_loa
	xor	eax, eax
	jne	SHORT $LN10@Atomic_loa
$LN9@Atomic_loa:
	mov	esi, esp
	push	OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	1551					; 0000060fH
	push	OFFSET ??_C@_1JC@OFINEDFE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN10@Atomic_loa
	int	3
$LN10@Atomic_loa:
	mov	esi, esp
	push	0
	push	1551					; 0000060fH
	push	OFFSET ??_C@_1JC@OFINEDFE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1CI@NMHCEFB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAl?$AAo?$AAa?$AAd?$AA_?$AA4?$AA?$AA@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1552 : 			return (0);

	xor	eax, eax
$LN7@Atomic_loa:

; 1553 : 		}
; 1554 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@Atomic_loa:
	DD	$LN4@Atomic_loa
	DD	$LN3@Atomic_loa
	DD	$LN3@Atomic_loa
	DD	$LN1@Atomic_loa
	DD	$LN1@Atomic_loa
	DD	$LN2@Atomic_loa
?_Atomic_load_4@std@@YAKPCKW4memory_order@1@@Z ENDP	; std::_Atomic_load_4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
