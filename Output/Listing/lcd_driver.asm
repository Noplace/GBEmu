; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

	TITLE	C:\Users\Khalid\Documents\GitHub\GBEmu\Solution\Code\emulation\gb\lcd_driver.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?value@?$_Abs@$0GE@@std@@2_JB			; std::_Abs<100>::value
PUBLIC	?value@?$_Abs@$0DLJKMKAA@@std@@2_JB		; std::_Abs<1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?value@?$_GcdX@$0GE@$0A@@std@@2_JB		; std::_GcdX<100,0>::value
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB	; std::_GcdX<1000000000,100>::value
PUBLIC	?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
PUBLIC	?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
PUBLIC	?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<100,1000000000>::value
PUBLIC	?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
PUBLIC	?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
PUBLIC	?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<100,1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$_Abs@$00@std@@2_JB			; std::_Abs<1>::value
PUBLIC	?value@?$_GcdX@$00$0A@@std@@2_JB		; std::_GcdX<1,0>::value
PUBLIC	?value@?$_GcdX@$00$00@std@@2_JB			; std::_GcdX<1,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?value@?$_Gcd@$00$00@std@@2_JB			; std::_Gcd<1,1>::value
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_monotonic@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_monotonic
PUBLIC	?is_steady@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_steady
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?value@?$integral_constant@H$0A@@std@@2HB	; std::integral_constant<int,0>::value
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
PUBLIC	?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
PUBLIC	?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_nonNull
PUBLIC	?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelException
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_notInlined
PUBLIC	?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_structured
PUBLIC	?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_localCancel
PUBLIC	?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_reserved
PUBLIC	?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB		; std::_GcdX<10000000,1>::value
PUBLIC	?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB		; std::_GcdX<1,10000000>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB		; std::_Gcd<1,10000000>::value
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?num@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::num
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?den@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::den
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
PUBLIC	?value@?$_Abs@$0JIJGIA@@std@@2_JB		; std::_Abs<10000000>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB		; std::_GcdX<10000000,0>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_GcdX<10000000,10000000>::value
PUBLIC	?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Gcd<10000000,10000000>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?num@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::num
PUBLIC	?den@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::den
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?is_monotonic@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_monotonic
PUBLIC	?is_steady@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_steady
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	_ConcRT_ProviderGuid
PUBLIC	_ConcRTEventGuid
PUBLIC	_SchedulerEventGuid
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	_ScheduleGroupEventGuid
PUBLIC	_ContextEventGuid
PUBLIC	_ChoreEventGuid
PUBLIC	_VirtualProcessorEventGuid
PUBLIC	_LockEventGuid
PUBLIC	_ResourceManagerEventGuid
PUBLIC	_PPLParallelInvokeEventGuid
PUBLIC	_PPLParallelForEventGuid
PUBLIC	_PPLParallelForeachEventGuid
PUBLIC	_AgentEventGuid
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT _AgentEventGuid
CONST	SEGMENT
_AgentEventGuid DD 0b9b5b78cH
	DW	0713H
	DW	04898H
	DB	0a2H
	DB	01aH
	DB	0c6H
	DB	079H
	DB	049H
	DB	0dcH
	DB	0edH
	DB	07H
CONST	ENDS
;	COMDAT _PPLParallelForeachEventGuid
CONST	SEGMENT
_PPLParallelForeachEventGuid DD 05cb7d785H
	DW	09d66H
	DW	0465dH
	DB	0baH
	DB	0e1H
	DB	046H
	DB	011H
	DB	06H
	DB	01bH
	DB	054H
	DB	034H
CONST	ENDS
;	COMDAT _PPLParallelForEventGuid
CONST	SEGMENT
_PPLParallelForEventGuid DD 031c8da6bH
	DW	06165H
	DW	04042H
	DB	08bH
	DB	092H
	DB	094H
	DB	09eH
	DB	031H
	DB	05fH
	DB	04dH
	DB	084H
CONST	ENDS
;	COMDAT _PPLParallelInvokeEventGuid
CONST	SEGMENT
_PPLParallelInvokeEventGuid DD 0d1b5b133H
	DW	0ec3dH
	DW	049f4H
	DB	098H
	DB	0a3H
	DB	046H
	DB	04dH
	DB	01aH
	DB	09eH
	DB	046H
	DB	082H
CONST	ENDS
;	COMDAT _ResourceManagerEventGuid
CONST	SEGMENT
_ResourceManagerEventGuid DD 02718d25bH
	DW	05bf5H
	DW	04479H
	DB	08eH
	DB	088H
	DB	0baH
	DB	0bcH
	DB	064H
	DB	0bdH
	DB	0bfH
	DB	0caH
CONST	ENDS
;	COMDAT _LockEventGuid
CONST	SEGMENT
_LockEventGuid DD 079a60dc6H
	DW	05fc8H
	DW	04952H
	DB	0a4H
	DB	01cH
	DB	011H
	DB	063H
	DB	0aeH
	DB	0ecH
	DB	05eH
	DB	0b8H
CONST	ENDS
;	COMDAT _VirtualProcessorEventGuid
CONST	SEGMENT
_VirtualProcessorEventGuid DD 02f27805fH
	DW	01676H
	DW	04eccH
	DB	096H
	DB	0faH
	DB	07eH
	DB	0b0H
	DB	09dH
	DB	044H
	DB	030H
	DB	02fH
CONST	ENDS
;	COMDAT _ChoreEventGuid
CONST	SEGMENT
_ChoreEventGuid DD 07e854ec7H
	DW	0cdc4H
	DW	0405aH
	DB	0b5H
	DB	0b2H
	DB	0aaH
	DB	0f7H
	DB	0c9H
	DB	0e7H
	DB	0d4H
	DB	0cH
CONST	ENDS
;	COMDAT _ContextEventGuid
CONST	SEGMENT
_ContextEventGuid DD 05727a00fH
	DW	050beH
	DW	04519H
	DB	082H
	DB	056H
	DB	0f7H
	DB	069H
	DB	098H
	DB	071H
	DB	0feH
	DB	0cbH
CONST	ENDS
;	COMDAT _ScheduleGroupEventGuid
CONST	SEGMENT
_ScheduleGroupEventGuid DD 0e8a3bf1fH
	DW	0a86bH
	DW	04390H
	DB	09cH
	DB	060H
	DB	053H
	DB	090H
	DB	0b9H
	DB	069H
	DB	0d2H
	DB	02cH
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT _SchedulerEventGuid
CONST	SEGMENT
_SchedulerEventGuid DD 0e2091f8aH
	DW	01e0aH
	DW	04731H
	DB	084H
	DB	0a2H
	DB	0dH
	DB	0d5H
	DB	07cH
	DB	08aH
	DB	052H
	DB	061H
CONST	ENDS
;	COMDAT _ConcRTEventGuid
CONST	SEGMENT
_ConcRTEventGuid DD 072b14a7dH
	DW	0704cH
	DW	0423eH
	DB	092H
	DB	0f8H
	DB	07eH
	DB	06dH
	DB	064H
	DB	0bcH
	DB	0b9H
	DB	02aH
CONST	ENDS
;	COMDAT _ConcRT_ProviderGuid
CONST	SEGMENT
_ConcRT_ProviderGuid DD 0f7b697a3H
	DW	04db5H
	DW	04d3bH
	DB	0beH
	DB	071H
	DB	0c4H
	DB	0d2H
	DB	084H
	DB	0e6H
	DB	059H
	DB	02fH
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?is_steady@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@steady_clock@chrono@std@@2_NB DB 01H		; std::chrono::steady_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@steady_clock@chrono@std@@2_NB DB 01H	; std::chrono::steady_clock::is_monotonic
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::num
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0JIJGIA@@std@@2_JB DQ 0000000000989680H	; std::_Abs<10000000>::value
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::ratio<1,10000000>::den
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,10000000>::num
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,10000000>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000000,1>::value
CONST	ENDS
;	COMDAT ?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_reserved
CONST	ENDS
;	COMDAT ?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_localCancel
CONST	ENDS
;	COMDAT ?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_structured
CONST	ENDS
;	COMDAT ?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB DD 0ffffffffH ; Concurrency::details::_TaskCollectionBase::_S_notInlined
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_cancelException
CONST	ENDS
;	COMDAT ?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB DD 08H ; Concurrency::details::_TaskCollectionBase::_S_nonNull
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
CONST	ENDS
;	COMDAT ?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
CONST	ENDS
;	COMDAT ?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
CONST	ENDS
;	COMDAT ?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB DD 00H ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@H$0A@@std@@2HB
CONST	SEGMENT
?value@?$integral_constant@H$0A@@std@@2HB DD 00H	; std::integral_constant<int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?is_steady@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@system_clock@chrono@std@@2_NB DB 00H		; std::chrono::system_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@system_clock@chrono@std@@2_NB DB 00H	; std::chrono::system_clock::is_monotonic
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0A@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$00@std@@2_JB DQ 0000000000000001H	; std::_Abs<1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_Gcd<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB DD 03H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
CONST	ENDS
;	COMDAT ?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 02H ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 01H ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
CONST	ENDS
;	COMDAT ?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB DD 00H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<1000000000,100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0A@@std@@2_JB DQ 0000000000000064H	; std::_GcdX<100,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Abs<1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0GE@@std@@2_JB DQ 0000000000000064H	; std::_Abs<100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_pal32	DD	0ffffffffH
	DD	0ffaaaaaaH
	DD	0ff545454H
	DD	0ff000000H
$SG130133 DB	'Code\emulation\gb\lcd_driver.cpp', 00H
	ORG $+3
$SG130136 DB	'Code\emulation\gb\lcd_driver.cpp', 00H
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
PUBLIC	??0_Ignore@std@@QAE@XZ				; std::_Ignore::_Ignore
PUBLIC	?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ; emulation::gb::Component::Initialize
PUBLIC	?vram@Memory@gb@emulation@@QAEPAEXZ		; emulation::gb::Memory::vram
PUBLIC	?oam@Memory@gb@emulation@@QAEPAEXZ		; emulation::gb::Memory::oam
PUBLIC	?ioports@Memory@gb@emulation@@QAEPAEXZ		; emulation::gb::Memory::ioports
PUBLIC	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ	; emulation::gb::Memory::interrupt_flag
PUBLIC	?Initialize@LCDDriver@gb@emulation@@UAEXPAVEmu@23@@Z ; emulation::gb::LCDDriver::Initialize
PUBLIC	?Deinitialize@LCDDriver@gb@emulation@@UAEXXZ	; emulation::gb::LCDDriver::Deinitialize
PUBLIC	?Step@LCDDriver@gb@emulation@@QAEXN@Z		; emulation::gb::LCDDriver::Step
PUBLIC	?Read@LCDDriver@gb@emulation@@QAEEG@Z		; emulation::gb::LCDDriver::Read
PUBLIC	?Write@LCDDriver@gb@emulation@@QAEXGE@Z		; emulation::gb::LCDDriver::Write
PUBLIC	?RenderBGLine@LCDDriver@gb@emulation@@QAEXXZ	; emulation::gb::LCDDriver::RenderBGLine
PUBLIC	?RenderWindowLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderWindowLine
PUBLIC	?RenderSpriteLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderSpriteLine
PUBLIC	?RenderLine@LCDDriver@gb@emulation@@QAEXXZ	; emulation::gb::LCDDriver::RenderLine
PUBLIC	?RenderAllBGTiles@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderAllBGTiles
PUBLIC	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ	; emulation::gb::Emu::memory
PUBLIC	??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
PUBLIC	__real@0000000000000000
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXIHPBDH@Z:PROC				; operator new[]
EXTRN	__imp_?_Xbad_function_call@std@@YAXXZ:PROC
EXTRN	?Read8@Memory@gb@emulation@@QAEEG@Z:PROC	; emulation::gb::Memory::Read8
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_ignore	DB	01H DUP (?)
__Tuple_alloc DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv82 = -16						; size = 4
_d$1 = -10						; size = 1
_tileindex$ = -9					; size = 1
_bgtilemap$ = -8					; size = 4
_this$ = -4						; size = 4
??R<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QBEEXZ PROC ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::operator()
; _this$ = ecx

; 212  : 	auto readTile = [&](){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 		  uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx+16]
	shr	dl, 3
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN4@operator
	mov	DWORD PTR tv82[ebp], 6144		; 00001800H
	jmp	SHORT $LN5@operator
$LN4@operator:
	mov	DWORD PTR tv82[ebp], 7168		; 00001c00H
$LN5@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR _bgtilemap$[ebp], eax

; 214  : 			auto tileindex = bgtilemap[(mapoffset<<5) + lineoffset];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _bgtilemap$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR _tileindex$[ebp], cl

; 215  : 			if(lcdc_.tile_data == 0) { //1 && tileindex < 128) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cl, BYTE PTR [eax+16]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN1@operator

; 216  :         //tileindex += 256;
; 217  :         //tileindex &= 0xFF;
; 218  : 				int8_t d = tileindex;

	mov	al, BYTE PTR _tileindex$[ebp]
	mov	BYTE PTR _d$1[ebp], al

; 219  : 				d+=128;

	movsx	ecx, BYTE PTR _d$1[ebp]
	add	ecx, 128				; 00000080H
	mov	BYTE PTR _d$1[ebp], cl

; 220  : 				tileindex = d;

	mov	dl, BYTE PTR _d$1[ebp]
	mov	BYTE PTR _tileindex$[ebp], dl
$LN1@operator:

; 221  : 			}
; 222  : 			return tileindex;

	mov	al, BYTE PTR _tileindex$[ebp]

; 223  : 	};

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QBEEXZ ENDP ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This$ = 8						; size = 4
__Mapoffset$ = 12					; size = 4
__Lineoffset$ = 16					; size = 4
??0<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QAE@PAVLCDDriver@gb@emulation@@AAH1@Z PROC ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::<lambda_97bc8e9b09435192667e87dfa941ef5a>
; _this$ = ecx

; 223  : 	};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __This$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Mapoffset$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Lineoffset$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QAE@PAVLCDDriver@gb@emulation@@AAH1@Z ENDP ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::<lambda_97bc8e9b09435192667e87dfa941ef5a>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv82 = -16						; size = 4
_d$1 = -10						; size = 1
_tileindex$ = -9					; size = 1
_bgtilemap$ = -8					; size = 4
_this$ = -4						; size = 4
??R<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QBEEXZ PROC ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::operator()
; _this$ = ecx

; 176  : 	auto readTile = [&](){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 		  uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx+16]
	shr	dl, 3
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN4@operator
	mov	DWORD PTR tv82[ebp], 6144		; 00001800H
	jmp	SHORT $LN5@operator
$LN4@operator:
	mov	DWORD PTR tv82[ebp], 7168		; 00001c00H
$LN5@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR _bgtilemap$[ebp], eax

; 178  : 			auto tileindex = bgtilemap[(mapoffset<<5)];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 5
	mov	eax, DWORD PTR _bgtilemap$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR _tileindex$[ebp], cl

; 179  : 			if(lcdc_.tile_data == 0) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cl, BYTE PTR [eax+16]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN1@operator

; 180  : 				int8_t d = tileindex;

	mov	al, BYTE PTR _tileindex$[ebp]
	mov	BYTE PTR _d$1[ebp], al

; 181  : 				d+=128;

	movsx	ecx, BYTE PTR _d$1[ebp]
	add	ecx, 128				; 00000080H
	mov	BYTE PTR _d$1[ebp], cl

; 182  : 				tileindex = d;

	mov	dl, BYTE PTR _d$1[ebp]
	mov	BYTE PTR _tileindex$[ebp], dl
$LN1@operator:

; 183  : 			}
; 184  : 			return tileindex;

	mov	al, BYTE PTR _tileindex$[ebp]

; 185  : 	};

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QBEEXZ ENDP ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This$ = 8						; size = 4
__Mapoffset$ = 12					; size = 4
??0<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QAE@PAVLCDDriver@gb@emulation@@AAH@Z PROC ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>
; _this$ = ecx

; 185  : 	};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __This$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Mapoffset$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QAE@PAVLCDDriver@gb@emulation@@AAH@Z ENDP ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ PROC ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator(), COMDAT
; _this$ = ecx

; 514  : _VARIADIC_EXPAND_P1_0(_CLASS_FUNC_CLASS_0, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN1@operator
	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_function_call@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator:
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ ENDP ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\emu.h
;	COMDAT ?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ PROC	; emulation::gb::Emu::memory, COMDAT
; _this$ = ecx

; 21   :   Memory* memory() { return &memory_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1152				; 00000480H
	mov	esp, ebp
	pop	ebp
	ret	0
?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ENDP	; emulation::gb::Emu::memory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv137 = -64						; size = 4
_tile$1 = -60						; size = 4
_tileindex$2 = -56					; size = 4
_i$3 = -52						; size = 4
_tiledata$4 = -48					; size = 4
_i$5 = -44						; size = 4
_readTile$ = -36					; size = 8
_x$ = -24						; size = 4
_y$ = -20						; size = 4
_mapoffset$ = -12					; size = 4
_this$ = -4						; size = 4
?RenderAllBGTiles@LCDDriver@gb@emulation@@QAEXXZ PROC	; emulation::gb::LCDDriver::RenderAllBGTiles
; _this$ = ecx

; 172  : void LCDDriver::RenderAllBGTiles() {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 173  : 	auto mapoffset = ((ly)&0xFF) >> 3;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+20]
	and	ecx, 255				; 000000ffH
	sar	ecx, 3
	mov	DWORD PTR _mapoffset$[ebp], ecx

; 174  : 	auto y = (ly) & 7;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+20]
	and	eax, 7
	mov	DWORD PTR _y$[ebp], eax

; 175  : 	auto x = 0;

	mov	DWORD PTR _x$[ebp], 0

; 176  : 	auto readTile = [&](){
; 177  : 		  uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];
; 178  : 			auto tileindex = bgtilemap[(mapoffset<<5)];
; 179  : 			if(lcdc_.tile_data == 0) {
; 180  : 				int8_t d = tileindex;
; 181  : 				d+=128;
; 182  : 				tileindex = d;
; 183  : 			}
; 184  : 			return tileindex;
; 185  : 	};

	lea	ecx, DWORD PTR _mapoffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	ecx, DWORD PTR _readTile$[ebp]
	call	??0<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QAE@PAVLCDDriver@gb@emulation@@AAH@Z ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>

; 186  : 
; 187  : 	if (lcdc_.bgdisplay == 0) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+16]
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN9@RenderAllB

; 188  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN8@RenderAllB
$LN7@RenderAllB:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN8@RenderAllB:
	cmp	DWORD PTR _i$5[ebp], 256		; 00000100H
	jge	SHORT $LN6@RenderAllB

; 189  : 			colormap[((ly)<<8)+(i)] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	shl	edx, 8
	add	edx, DWORD PTR _i$5[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	BYTE PTR [ecx+edx], 0

; 190  : 		}

	jmp	SHORT $LN7@RenderAllB
$LN6@RenderAllB:
	jmp	$LN10@RenderAllB
$LN9@RenderAllB:

; 191  : 	} else {
; 192  : 		uint8_t* tiledata = &emu_->memory()->vram()[lcdc_.tile_data ==0?0x0800:0x0000];

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+16]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN12@RenderAllB
	mov	DWORD PTR tv137[ebp], 2048		; 00000800H
	jmp	SHORT $LN13@RenderAllB
$LN12@RenderAllB:
	mov	DWORD PTR tv137[ebp], 0
$LN13@RenderAllB:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv137[ebp]
	mov	DWORD PTR _tiledata$4[ebp], eax

; 193  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@RenderAllB
$LN3@RenderAllB:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@RenderAllB:
	cmp	DWORD PTR _i$3[ebp], 256		; 00000100H
	jge	$LN10@RenderAllB

; 194  : 			auto tileindex = (i>>3)+(ly>>3)*32;

	mov	ecx, DWORD PTR _i$3[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+20]
	sar	eax, 3
	shl	eax, 5
	add	ecx, eax
	mov	DWORD PTR _tileindex$2[ebp], ecx

; 195  : 			uint8_t* tile = &tiledata[(tileindex<<4)];

	mov	ecx, DWORD PTR _tileindex$2[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _tiledata$4[ebp]
	mov	DWORD PTR _tile$1[ebp], ecx

; 196  : 			
; 197  : 			colormap[((ly)<<8)+i] = bg_pal[pixel((7-x))];

	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _tile$1[ebp]
	movzx	edx, BYTE PTR [eax+edx*2]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$[ebp]
	sar	edx, cl
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _tile$1[ebp]
	movzx	eax, BYTE PTR [ecx+eax*2+1]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$[ebp]
	sar	eax, cl
	shl	eax, 1
	and	eax, 2
	add	eax, 1
	and	edx, eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [ecx+20]
	shl	eax, 8
	add	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	esi, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [esi+edx+24]
	mov	BYTE PTR [ecx+eax], dl

; 198  : 
; 199  : 			++x;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax

; 200  : 			if (x==8) {

	cmp	DWORD PTR _x$[ebp], 8
	jne	SHORT $LN1@RenderAllB

; 201  : 				x = 0;

	mov	DWORD PTR _x$[ebp], 0
$LN1@RenderAllB:

; 202  : 			}
; 203  : 		}

	jmp	$LN3@RenderAllB
$LN10@RenderAllB:

; 204  : 	}
; 205  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@RenderAllB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN17@RenderAllB:
	DD	2
	DD	$LN16@RenderAllB
$LN16@RenderAllB:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN14@RenderAllB
	DD	-36					; ffffffdcH
	DD	8
	DD	$LN15@RenderAllB
$LN15@RenderAllB:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$LN14@RenderAllB:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?RenderAllBGTiles@LCDDriver@gb@emulation@@QAEXXZ ENDP	; emulation::gb::LCDDriver::RenderAllBGTiles
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RenderLine@LCDDriver@gb@emulation@@QAEXXZ PROC		; emulation::gb::LCDDriver::RenderLine
; _this$ = ecx

; 327  : void LCDDriver::RenderLine() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 328  :   //RenderAllBGTiles();
; 329  : 	RenderBGLine();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenderBGLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderBGLine

; 330  : 	//RenderWindowLine();
; 331  : 	//RenderSpriteLine();
; 332  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderLine@LCDDriver@gb@emulation@@QAEXXZ ENDP		; emulation::gb::LCDDriver::RenderLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv188 = -48						; size = 4
_i$1 = -44						; size = 4
_p$2 = -37						; size = 1
_x$3 = -36						; size = 4
_pal$4 = -32						; size = 4
_y$5 = -25						; size = 1
_tile$6 = -24						; size = 4
_spritex$7 = -18					; size = 1
_spritey$8 = -17					; size = 1
_j$9 = -16						; size = 4
_sprites$10 = -12					; size = 4
_tiledata$11 = -8					; size = 4
_this$ = -4						; size = 4
?RenderSpriteLine@LCDDriver@gb@emulation@@QAEXXZ PROC	; emulation::gb::LCDDriver::RenderSpriteLine
; _this$ = ecx

; 254  : void LCDDriver::RenderSpriteLine() {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 255  :   struct Sprite{
; 256  :     uint8_t y,x,tileindex;
; 257  : 
; 258  :     union {
; 259  :       struct {
; 260  :         uint8_t unused:4;
; 261  :         uint8_t pal:1;
; 262  :         uint8_t xflip:1;
; 263  :         uint8_t yflip:1;
; 264  :         uint8_t priority:1;
; 265  :         /* Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
; 266  :          (Used for both BG and Window. BG color 0 is always behind OBJ)
; 267  :   Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
; 268  :   Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
; 269  :   Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
; 270  :   Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
; 271  :   Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)
; 272  : */
; 273  :       };
; 274  :       uint8_t raw;
; 275  :     }attr;
; 276  : 
; 277  :   } ;
; 278  : 	if (lcdc_.sprite_enable == 1) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+16]
	shr	cl, 1
	and	cl, 1
	movzx	edx, cl
	cmp	edx, 1
	jne	$LN17@RenderSpri

; 279  : 		uint8_t* tiledata = &emu_->memory()->vram()[0x0000];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	mov	ecx, 1
	imul	ecx, 0
	add	eax, ecx
	mov	DWORD PTR _tiledata$11[ebp], eax

; 280  :     Sprite* sprites = (Sprite*)emu_->memory()->oam();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?oam@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::oam
	mov	DWORD PTR _sprites$10[ebp], eax

; 281  : 
; 282  :     for (int j=0;j<40;++j) {

	mov	DWORD PTR _j$9[ebp], 0
	jmp	SHORT $LN15@RenderSpri
$LN14@RenderSpri:
	mov	eax, DWORD PTR _j$9[ebp]
	add	eax, 1
	mov	DWORD PTR _j$9[ebp], eax
$LN15@RenderSpri:
	cmp	DWORD PTR _j$9[ebp], 40			; 00000028H
	jge	$LN13@RenderSpri

; 283  :        uint8_t spritey = sprites[j].y-16;

	mov	ecx, DWORD PTR _j$9[ebp]
	mov	edx, DWORD PTR _sprites$10[ebp]
	movzx	eax, BYTE PTR [edx+ecx*4]
	sub	eax, 16					; 00000010H
	mov	BYTE PTR _spritey$8[ebp], al

; 284  :        uint8_t spritex = sprites[j].y-8;

	mov	ecx, DWORD PTR _j$9[ebp]
	mov	edx, DWORD PTR _sprites$10[ebp]
	movzx	eax, BYTE PTR [edx+ecx*4]
	sub	eax, 8
	mov	BYTE PTR _spritex$7[ebp], al

; 285  :        if ( ly >= (spritey) && ly < (spritey+(8<<lcdc_.sprite_size))) { //same line

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	movzx	eax, BYTE PTR _spritey$8[ebp]
	cmp	edx, eax
	jl	$LN12@RenderSpri
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	movzx	eax, BYTE PTR _spritey$8[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [ecx+16]
	shr	cl, 2
	and	cl, 1
	movzx	ecx, cl
	mov	esi, 8
	shl	esi, cl
	add	eax, esi
	cmp	edx, eax
	jge	$LN12@RenderSpri

; 286  :          if (lcdc_.sprite_size)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+16]
	shr	al, 2
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@RenderSpri

; 287  :            sprites[j].tileindex &= ~0x01;

	mov	edx, DWORD PTR _j$9[ebp]
	mov	eax, DWORD PTR _sprites$10[ebp]
	movzx	ecx, BYTE PTR [eax+edx*4+2]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _j$9[ebp]
	mov	eax, DWORD PTR _sprites$10[ebp]
	mov	BYTE PTR [eax+edx*4+2], cl
$LN11@RenderSpri:

; 288  :           uint8_t* tile = &tiledata[(sprites[j].tileindex<<4)];

	mov	ecx, DWORD PTR _j$9[ebp]
	mov	edx, DWORD PTR _sprites$10[ebp]
	movzx	eax, BYTE PTR [edx+ecx*4+2]
	shl	eax, 4
	add	eax, DWORD PTR _tiledata$11[ebp]
	mov	DWORD PTR _tile$6[ebp], eax

; 289  :           uint8_t y = ly-spritey;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	movzx	eax, BYTE PTR _spritey$8[ebp]
	sub	edx, eax
	mov	BYTE PTR _y$5[ebp], dl

; 290  :           uint8_t* pal = sprites[j].attr.pal == 0?obj_pal1:obj_pal2;

	mov	ecx, DWORD PTR _j$9[ebp]
	mov	edx, DWORD PTR _sprites$10[ebp]
	mov	al, BYTE PTR [edx+ecx*4+3]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN19@RenderSpri
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR tv188[ebp], edx
	jmp	SHORT $LN20@RenderSpri
$LN19@RenderSpri:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR tv188[ebp], eax
$LN20@RenderSpri:
	mov	ecx, DWORD PTR tv188[ebp]
	mov	DWORD PTR _pal$4[ebp], ecx

; 291  :           if (sprites[j].attr.yflip)

	mov	edx, DWORD PTR _j$9[ebp]
	mov	eax, DWORD PTR _sprites$10[ebp]
	mov	cl, BYTE PTR [eax+edx*4+3]
	shr	cl, 6
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN10@RenderSpri

; 292  :             y = ((8<<lcdc_.sprite_size)) - y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+16]
	shr	cl, 2
	and	cl, 1
	movzx	ecx, cl
	mov	edx, 8
	shl	edx, cl
	movzx	eax, BYTE PTR _y$5[ebp]
	sub	edx, eax
	mov	BYTE PTR _y$5[ebp], dl
$LN10@RenderSpri:

; 293  : 			     
; 294  : 			    for (int x=0;x<8;++x) {

	mov	DWORD PTR _x$3[ebp], 0
	jmp	SHORT $LN9@RenderSpri
$LN8@RenderSpri:
	mov	ecx, DWORD PTR _x$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$3[ebp], ecx
$LN9@RenderSpri:
	cmp	DWORD PTR _x$3[ebp], 8
	jge	$LN12@RenderSpri

; 295  :             uint8_t p = 0;

	mov	BYTE PTR _p$2[ebp], 0

; 296  :             if (sprites[j].attr.xflip) {

	mov	edx, DWORD PTR _j$9[ebp]
	mov	eax, DWORD PTR _sprites$10[ebp]
	mov	cl, BYTE PTR [eax+edx*4+3]
	shr	cl, 5
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN6@RenderSpri

; 297  :               p = pixel((x));

	movzx	eax, BYTE PTR _y$5[ebp]
	mov	ecx, DWORD PTR _tile$6[ebp]
	movzx	edx, BYTE PTR [ecx+eax*2]
	mov	ecx, DWORD PTR _x$3[ebp]
	sar	edx, cl
	movzx	eax, BYTE PTR _y$5[ebp]
	mov	ecx, DWORD PTR _tile$6[ebp]
	movzx	eax, BYTE PTR [ecx+eax*2+1]
	mov	ecx, DWORD PTR _x$3[ebp]
	sar	eax, cl
	shl	eax, 1
	and	eax, 2
	add	eax, 1
	and	edx, eax
	mov	BYTE PTR _p$2[ebp], dl

; 298  :             } else {

	jmp	SHORT $LN5@RenderSpri
$LN6@RenderSpri:

; 299  :               p = pixel((7-x));

	movzx	ecx, BYTE PTR _y$5[ebp]
	mov	edx, DWORD PTR _tile$6[ebp]
	movzx	eax, BYTE PTR [edx+ecx*2]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$3[ebp]
	sar	eax, cl
	movzx	ecx, BYTE PTR _y$5[ebp]
	mov	edx, DWORD PTR _tile$6[ebp]
	movzx	edx, BYTE PTR [edx+ecx*2+1]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$3[ebp]
	sar	edx, cl
	shl	edx, 1
	and	edx, 2
	add	edx, 1
	and	eax, edx
	mov	BYTE PTR _p$2[ebp], al
$LN5@RenderSpri:

; 300  :             }
; 301  :             if (p != 0)

	movzx	eax, BYTE PTR _p$2[ebp]
	test	eax, eax
	je	SHORT $LN4@RenderSpri

; 302  :             colormap[((ly)<<8)+x+spritex] = pal[p];

	movzx	ecx, BYTE PTR _p$2[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+20]
	shl	eax, 8
	add	eax, DWORD PTR _x$3[ebp]
	movzx	edx, BYTE PTR _spritex$7[ebp]
	add	eax, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	esi, DWORD PTR _pal$4[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl
$LN4@RenderSpri:

; 303  :           }

	jmp	$LN8@RenderSpri
$LN12@RenderSpri:

; 304  : 
; 305  : 			
; 306  :        }
; 307  :      }

	jmp	$LN14@RenderSpri
$LN13@RenderSpri:

; 308  : 
; 309  :     for (int i=0;i<256;++i) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@RenderSpri
$LN2@RenderSpri:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN3@RenderSpri:
	cmp	DWORD PTR _i$1[ebp], 256		; 00000100H
	jge	SHORT $LN17@RenderSpri

; 310  : 			
; 311  :   
; 312  :       /*auto tileindex = readTile();
; 313  : 			uint8_t* tile = &tiledata[(tileindex<<4)];
; 314  : 			#define pixel(bit) ((tile[y<<1]>>(bit))&0x1+(((tile[(y<<1)+1]>>(bit))<<1)&0x2))
; 315  : 			frame_buffer[((ly)<<8)+i] = colormap[bg_pal[pixel((7-x))]];
; 316  : 			#undef pixel
; 317  : 			++x;
; 318  : 			if (x==8) {
; 319  : 				x = 0;
; 320  : 				lineoffset = (lineoffset+1)&0x1F;
; 321  : 			}*/
; 322  : 		}

	jmp	SHORT $LN2@RenderSpri
$LN17@RenderSpri:

; 323  : 
; 324  : 	}
; 325  : }

	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderSpriteLine@LCDDriver@gb@emulation@@QAEXXZ ENDP	; emulation::gb::LCDDriver::RenderSpriteLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_a$1 = -8						; size = 4
_this$ = -4						; size = 4
?RenderWindowLine@LCDDriver@gb@emulation@@QAEXXZ PROC	; emulation::gb::LCDDriver::RenderWindowLine
; _this$ = ecx

; 247  : void LCDDriver::RenderWindowLine() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 248  : 	if (lcdc_.window_enable == 1) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+16]
	shr	cl, 5
	and	cl, 1
	movzx	edx, cl
	cmp	edx, 1
	jne	SHORT $LN2@RenderWind

; 249  : 	int  a = 1;

	mov	DWORD PTR _a$1[ebp], 1
$LN2@RenderWind:

; 250  : 
; 251  : 	}
; 252  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RenderWindowLine@LCDDriver@gb@emulation@@QAEXXZ ENDP	; emulation::gb::LCDDriver::RenderWindowLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv151 = -84						; size = 4
_bgcolor$1 = -77					; size = 1
_tile$2 = -76						; size = 4
_tileindex$3 = -69					; size = 1
_i$4 = -68						; size = 4
_tiledata$5 = -64					; size = 4
_i$6 = -60						; size = 4
_readTile$ = -52					; size = 12
_x$ = -36						; size = 4
_y$ = -32						; size = 4
_lineoffset$ = -24					; size = 4
_mapoffset$ = -12					; size = 4
_this$ = -4						; size = 4
?RenderBGLine@LCDDriver@gb@emulation@@QAEXXZ PROC	; emulation::gb::LCDDriver::RenderBGLine
; _this$ = ecx

; 207  : void LCDDriver::RenderBGLine() {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 208  : 	auto mapoffset = ((ly+scroll_y)&0xFF) >> 3;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+19]
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	sar	ecx, 3
	mov	DWORD PTR _mapoffset$[ebp], ecx

; 209  : 	auto lineoffset = ((scroll_x>>3))&0x1F;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+18]
	sar	edx, 3
	and	edx, 31					; 0000001fH
	mov	DWORD PTR _lineoffset$[ebp], edx

; 210  : 	auto y = (ly + scroll_y) & 7;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+20]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+19]
	add	ecx, eax
	and	ecx, 7
	mov	DWORD PTR _y$[ebp], ecx

; 211  : 	auto x = scroll_x & 7;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+18]
	and	edx, 7
	mov	DWORD PTR _x$[ebp], edx

; 212  : 	auto readTile = [&](){
; 213  : 		  uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];
; 214  : 			auto tileindex = bgtilemap[(mapoffset<<5) + lineoffset];
; 215  : 			if(lcdc_.tile_data == 0) { //1 && tileindex < 128) {
; 216  :         //tileindex += 256;
; 217  :         //tileindex &= 0xFF;
; 218  : 				int8_t d = tileindex;
; 219  : 				d+=128;
; 220  : 				tileindex = d;
; 221  : 			}
; 222  : 			return tileindex;
; 223  : 	};

	lea	eax, DWORD PTR _lineoffset$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mapoffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	ecx, DWORD PTR _readTile$[ebp]
	call	??0<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QAE@PAVLCDDriver@gb@emulation@@AAH1@Z ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::<lambda_97bc8e9b09435192667e87dfa941ef5a>

; 224  : 
; 225  : 	if (lcdc_.bgdisplay == 0) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+16]
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN9@RenderBGLi

; 226  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN8@RenderBGLi
$LN7@RenderBGLi:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN8@RenderBGLi:
	cmp	DWORD PTR _i$6[ebp], 256		; 00000100H
	jge	SHORT $LN6@RenderBGLi

; 227  : 			colormap[((ly)<<8)+(i)] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	shl	edx, 8
	add	edx, DWORD PTR _i$6[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	BYTE PTR [ecx+edx], 0

; 228  : 		}

	jmp	SHORT $LN7@RenderBGLi
$LN6@RenderBGLi:
	jmp	$LN10@RenderBGLi
$LN9@RenderBGLi:

; 229  : 	} else {
; 230  : 		uint8_t* tiledata = &emu_->memory()->vram()[lcdc_.tile_data ==0?0x0800:0x0000];

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+16]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN12@RenderBGLi
	mov	DWORD PTR tv151[ebp], 2048		; 00000800H
	jmp	SHORT $LN13@RenderBGLi
$LN12@RenderBGLi:
	mov	DWORD PTR tv151[ebp], 0
$LN13@RenderBGLi:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv151[ebp]
	mov	DWORD PTR _tiledata$5[ebp], eax

; 231  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN4@RenderBGLi
$LN3@RenderBGLi:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN4@RenderBGLi:
	cmp	DWORD PTR _i$4[ebp], 256		; 00000100H
	jge	$LN10@RenderBGLi

; 232  : 			auto tileindex = readTile();

	lea	ecx, DWORD PTR _readTile$[ebp]
	call	??R<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QBEEXZ ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::operator()
	mov	BYTE PTR _tileindex$3[ebp], al

; 233  : 			uint8_t* tile = &tiledata[(tileindex<<4)];

	movzx	ecx, BYTE PTR _tileindex$3[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _tiledata$5[ebp]
	mov	DWORD PTR _tile$2[ebp], ecx

; 234  : 			
; 235  :       uint8_t bgcolor = pixel((7-x));

	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _tile$2[ebp]
	movzx	edx, BYTE PTR [eax+edx*2]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$[ebp]
	sar	edx, cl
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _tile$2[ebp]
	movzx	eax, BYTE PTR [ecx+eax*2+1]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$[ebp]
	sar	eax, cl
	shl	eax, 1
	and	eax, 2
	add	eax, 1
	and	edx, eax
	mov	BYTE PTR _bgcolor$1[ebp], dl

; 236  : 			
; 237  : 			++x;

	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$[ebp], ecx

; 238  : 			if (x==8) {

	cmp	DWORD PTR _x$[ebp], 8
	jne	SHORT $LN1@RenderBGLi

; 239  : 				x = 0;

	mov	DWORD PTR _x$[ebp], 0

; 240  : 				lineoffset = (lineoffset+1)&0x1F;

	mov	edx, DWORD PTR _lineoffset$[ebp]
	add	edx, 1
	and	edx, 31					; 0000001fH
	mov	DWORD PTR _lineoffset$[ebp], edx
$LN1@RenderBGLi:

; 241  :       }
; 242  :       colormap[((ly)<<8)+i] = bg_pal[bgcolor];

	movzx	eax, BYTE PTR _bgcolor$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	shl	edx, 8
	add	edx, DWORD PTR _i$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+24]
	mov	BYTE PTR [ecx+edx], al

; 243  : 		}

	jmp	$LN3@RenderBGLi
$LN10@RenderBGLi:

; 244  : 	}
; 245  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@RenderBGLi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@RenderBGLi:
	DD	3
	DD	$LN17@RenderBGLi
$LN17@RenderBGLi:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN14@RenderBGLi
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN15@RenderBGLi
	DD	-52					; ffffffccH
	DD	12					; 0000000cH
	DD	$LN16@RenderBGLi
$LN16@RenderBGLi:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$LN15@RenderBGLi:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN14@RenderBGLi:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?RenderBGLine@LCDDriver@gb@emulation@@QAEXXZ ENDP	; emulation::gb::LCDDriver::RenderBGLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv139 = -22						; size = 2
tv65 = -20						; size = 4
_i$1 = -16						; size = 4
_dest$2 = -12						; size = 4
_srcaddr$3 = -8						; size = 2
_this$ = -4						; size = 4
_address$ = 8						; size = 2
_data$ = 12						; size = 1
?Write@LCDDriver@gb@emulation@@QAEXGE@Z PROC		; emulation::gb::LCDDriver::Write
; _this$ = ecx

; 112  : void LCDDriver::Write(uint16_t address, uint8_t data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 113  :   switch (address) {

	movzx	eax, WORD PTR _address$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 65344				; 0000ff40H
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 11			; 0000000bH
	ja	$LN18@Write
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN20@Write[edx*4]
$LN15@Write:

; 114  :     case 0xFF40:
; 115  :       lcdc_.raw = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax+16], cl

; 116  :       break;

	jmp	$LN18@Write
$LN14@Write:

; 117  :     case 0xFF41:
; 118  :       stat_.raw = (data & ~0x7) | (stat_.raw&0x7);

	movzx	edx, BYTE PTR _data$[ebp]
	and	edx, -8					; fffffff8H
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	and	ecx, 7
	or	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+17], dl

; 119  :       break;

	jmp	$LN18@Write
$LN13@Write:

; 120  :     case 0xFF42:
; 121  :       scroll_y = data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [ecx+19], dl

; 122  :       break;

	jmp	$LN18@Write
$LN12@Write:

; 123  :     case 0xFF43:
; 124  :       scroll_x = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax+18], cl

; 125  :       break;

	jmp	$LN18@Write

; 126  :       break;

	jmp	$LN18@Write
$LN11@Write:

; 127  :     case 0xFF44:
; 128  :       ly = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+20], 0

; 129  :       break;

	jmp	$LN18@Write
$LN10@Write:

; 130  :     case 0xFF45:
; 131  :       lyc = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax+21], cl

; 132  :       break;

	jmp	$LN18@Write
$LN9@Write:

; 133  :     case 0xFF46: {
; 134  :       uint16_t srcaddr = data<<8;

	movzx	edx, BYTE PTR _data$[ebp]
	shl	edx, 8
	mov	WORD PTR _srcaddr$3[ebp], dx

; 135  :       auto dest = emu_->memory()->oam();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?oam@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::oam
	mov	DWORD PTR _dest$2[ebp], eax

; 136  :       for (int i=0;i<160;++i)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN8@Write
$LN7@Write:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN8@Write:
	cmp	DWORD PTR _i$1[ebp], 160		; 000000a0H
	jge	SHORT $LN6@Write

; 137  :         *dest++ = emu_->memory()->Read8(srcaddr++);

	mov	dx, WORD PTR _srcaddr$3[ebp]
	mov	WORD PTR tv139[ebp], dx
	mov	ax, WORD PTR _srcaddr$3[ebp]
	add	ax, 1
	mov	WORD PTR _srcaddr$3[ebp], ax
	movzx	ecx, WORD PTR tv139[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, DWORD PTR _dest$2[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _dest$2[ebp]
	add	edx, 1
	mov	DWORD PTR _dest$2[ebp], edx
	jmp	SHORT $LN7@Write
$LN6@Write:

; 138  :       break;

	jmp	$LN18@Write
$LN5@Write:

; 139  :     }
; 140  :     case 0xFF47:
; 141  :       bg_pallete_data = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax+36], cl

; 142  :       bg_pal[0] = data&0x3;

	movzx	edx, BYTE PTR _data$[ebp]
	and	edx, 3
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+24], dl

; 143  :       bg_pal[1] = (data>>2)&0x3;

	movzx	edx, BYTE PTR _data$[ebp]
	sar	edx, 2
	and	edx, 3
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+24], dl

; 144  :       bg_pal[2] = (data>>4)&0x3;

	movzx	edx, BYTE PTR _data$[ebp]
	sar	edx, 4
	and	edx, 3
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+24], dl

; 145  :       bg_pal[3] = (data>>6)&0x3;

	movzx	edx, BYTE PTR _data$[ebp]
	sar	edx, 6
	and	edx, 3
	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+24], dl

; 146  :       break;

	jmp	$LN18@Write
$LN4@Write:

; 147  :     case 0xFF48:
; 148  :       obj_pallete1_data = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _data$[ebp]
	mov	BYTE PTR [edx+37], al

; 149  :       obj_pal1[0] = data&0x3;

	movzx	ecx, BYTE PTR _data$[ebp]
	and	ecx, 3
	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+28], cl

; 150  :       obj_pal1[1] = (data>>2)&0x3;

	movzx	ecx, BYTE PTR _data$[ebp]
	sar	ecx, 2
	and	ecx, 3
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+28], cl

; 151  :       obj_pal1[2] = (data>>4)&0x3;

	movzx	ecx, BYTE PTR _data$[ebp]
	sar	ecx, 4
	and	ecx, 3
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+28], cl

; 152  :       obj_pal1[3] = (data>>6)&0x3;

	movzx	ecx, BYTE PTR _data$[ebp]
	sar	ecx, 6
	and	ecx, 3
	mov	edx, 1
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+28], cl

; 153  :       break;

	jmp	SHORT $LN18@Write
$LN3@Write:

; 154  :     case 0xFF49:
; 155  :       obj_pallete2_data = data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [ecx+38], dl

; 156  :       obj_pal2[0] = data&0x3;

	movzx	eax, BYTE PTR _data$[ebp]
	and	eax, 3
	mov	ecx, 1
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+32], al

; 157  :       obj_pal2[1] = (data>>2)&0x3;

	movzx	eax, BYTE PTR _data$[ebp]
	sar	eax, 2
	and	eax, 3
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+32], al

; 158  :       obj_pal2[2] = (data>>4)&0x3;

	movzx	eax, BYTE PTR _data$[ebp]
	sar	eax, 4
	and	eax, 3
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+32], al

; 159  :       obj_pal2[3] = (data>>6)&0x3;

	movzx	eax, BYTE PTR _data$[ebp]
	sar	eax, 6
	and	eax, 3
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+32], al

; 160  :       break;

	jmp	SHORT $LN18@Write
$LN2@Write:

; 161  :     case 0xFF4A:
; 162  :       wy = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax+23], cl

; 163  :       break;

	jmp	SHORT $LN18@Write
$LN1@Write:

; 164  :     case 0xFF4B:
; 165  :       wx = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _data$[ebp]
	mov	BYTE PTR [edx+22], al
$LN18@Write:

; 166  :       break;
; 167  :   }
; 168  : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN20@Write:
	DD	$LN15@Write
	DD	$LN14@Write
	DD	$LN13@Write
	DD	$LN12@Write
	DD	$LN11@Write
	DD	$LN10@Write
	DD	$LN9@Write
	DD	$LN5@Write
	DD	$LN4@Write
	DD	$LN3@Write
	DD	$LN2@Write
	DD	$LN1@Write
?Write@LCDDriver@gb@emulation@@QAEXGE@Z ENDP		; emulation::gb::LCDDriver::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
_address$ = 8						; size = 2
?Read@LCDDriver@gb@emulation@@QAEEG@Z PROC		; emulation::gb::LCDDriver::Read
; _this$ = ecx

; 83   : uint8_t LCDDriver::Read(uint16_t address) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 
; 85   :   switch (address) {

	movzx	eax, WORD PTR _address$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 65344				; 0000ff40H
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 11			; 0000000bH
	ja	SHORT $LN12@Read
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN16@Read[edx*4]
$LN11@Read:

; 86   :     case 0xFF40:
; 87   :       return lcdc_.raw;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+16]
	jmp	SHORT $LN14@Read
$LN10@Read:

; 88   :     case 0xFF41:
; 89   :       return stat_.raw;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+17]
	jmp	SHORT $LN14@Read
$LN9@Read:

; 90   :     case 0xFF42:
; 91   :       return scroll_y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+19]
	jmp	SHORT $LN14@Read
$LN8@Read:

; 92   :     case 0xFF43:
; 93   :       return scroll_x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+18]
	jmp	SHORT $LN14@Read
$LN7@Read:

; 94   :     case 0xFF44:
; 95   :       return ly;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+20]
	jmp	SHORT $LN14@Read
$LN6@Read:

; 96   :     case 0xFF45:
; 97   :       return lyc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+21]
	jmp	SHORT $LN14@Read
$LN5@Read:

; 98   :     case 0xFF47:
; 99   :       return bg_pallete_data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+36]
	jmp	SHORT $LN14@Read
$LN4@Read:

; 100  :     case 0xFF48:
; 101  :       return obj_pallete1_data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+37]
	jmp	SHORT $LN14@Read
$LN3@Read:

; 102  :     case 0xFF49:
; 103  :       return obj_pallete2_data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+38]
	jmp	SHORT $LN14@Read
$LN2@Read:

; 104  :     case 0xFF4A:
; 105  :       return wy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+23]
	jmp	SHORT $LN14@Read
$LN1@Read:

; 106  :     case 0xFF4B:
; 107  :       return wx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+22]
	jmp	SHORT $LN14@Read
$LN12@Read:

; 108  :   }
; 109  : 	return 0;

	xor	al, al
$LN14@Read:

; 110  : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN16@Read:
	DD	$LN11@Read
	DD	$LN10@Read
	DD	$LN9@Read
	DD	$LN8@Read
	DD	$LN7@Read
	DD	$LN6@Read
	DD	$LN12@Read
	DD	$LN5@Read
	DD	$LN4@Read
	DD	$LN3@Read
	DD	$LN2@Read
	DD	$LN1@Read
?Read@LCDDriver@gb@emulation@@QAEEG@Z ENDP		; emulation::gb::LCDDriver::Read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv373 = -56						; size = 4
tv367 = -52						; size = 4
tv238 = -48						; size = 4
tv225 = -44						; size = 4
tv347 = -40						; size = 4
tv198 = -36						; size = 4
tv328 = -32						; size = 4
tv320 = -28						; size = 4
tv155 = -24						; size = 4
tv139 = -20						; size = 4
tv131 = -16						; size = 4
tv71 = -9						; size = 1
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_dt$ = 8						; size = 8
?Step@LCDDriver@gb@emulation@@QAEXN@Z PROC		; emulation::gb::LCDDriver::Step
; _this$ = ecx

; 30   : void LCDDriver::Step(double dt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 	stat_.coincidence = lyc == ly;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+21]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+20]
	cmp	ecx, eax
	jne	SHORT $LN23@Step
	mov	BYTE PTR tv71[ebp], 1
	jmp	SHORT $LN24@Step
$LN23@Step:
	mov	BYTE PTR tv71[ebp], 0
$LN24@Step:
	mov	cl, BYTE PTR tv71[ebp]
	and	cl, 1
	shl	cl, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+17]
	and	al, 251					; 000000fbH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+17], al

; 32   :   if (stat_.coincidence_inr && stat_.coincidence)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+17]
	shr	al, 6
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@Step
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+17]
	shr	al, 2
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@Step

; 33   :     emu_->memory()->interrupt_flag() |= 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv131[ebp], eax
	mov	eax, DWORD PTR tv131[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR tv131[ebp]
	mov	BYTE PTR [edx], cl
$LN20@Step:

; 34   : 
; 35   : 	switch (stat_.mode) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+17]
	and	cl, 3
	movzx	edx, cl
	mov	DWORD PTR tv139[ebp], edx
	cmp	DWORD PTR tv139[ebp], 3
	ja	$LN18@Step
	mov	eax, DWORD PTR tv139[ebp]
	jmp	DWORD PTR $LN25@Step[eax*4]
$LN17@Step:

; 36   : 		case 2:
; 37   :       if (stat_.oam_int)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+17]
	shr	dl, 5
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Step

; 38   :         emu_->memory()->interrupt_flag() |= 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv155[ebp], eax
	mov	edx, DWORD PTR tv155[ebp]
	movzx	eax, BYTE PTR [edx]
	or	eax, 2
	mov	ecx, DWORD PTR tv155[ebp]
	mov	BYTE PTR [ecx], al
$LN16@Step:

; 39   : 			if (counter2==80)

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv320[ebp], edx
	mov	eax, DWORD PTR tv320[ebp]
	cmp	DWORD PTR [eax+48], 80			; 00000050H
	jne	SHORT $LN15@Step
	mov	ecx, DWORD PTR tv320[ebp]
	cmp	DWORD PTR [ecx+52], 0
	jne	SHORT $LN15@Step

; 40   : 				stat_.mode = 3;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+17]
	or	al, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+17], al
$LN15@Step:

; 41   : 			break;

	jmp	$LN18@Step
$LN14@Step:

; 42   : 		case 3:
; 43   : 		  if (counter2 == 282) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv328[ebp], edx
	mov	eax, DWORD PTR tv328[ebp]
	cmp	DWORD PTR [eax+48], 282			; 0000011aH
	jne	SHORT $LN13@Step
	mov	ecx, DWORD PTR tv328[ebp]
	cmp	DWORD PTR [ecx+52], 0
	jne	SHORT $LN13@Step

; 44   : 	  		RenderLine();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenderLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderLine

; 45   : 				stat_.mode = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+17]
	and	al, 252					; 000000fcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+17], al

; 46   : 				if (ly == 143) 

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+20]
	cmp	eax, 143				; 0000008fH
	jne	SHORT $LN13@Step

; 47   : 					stat_.mode = 1;//vblank period

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+17]
	and	dl, 252					; 000000fcH
	or	dl, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+17], dl
$LN13@Step:

; 48   : 			}
; 49   : 			break;

	jmp	$LN18@Step
$LN11@Step:

; 50   : 		case 0:
; 51   :       if (stat_.hblank_int)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+17]
	shr	dl, 3
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN10@Step

; 52   :         emu_->memory()->interrupt_flag() |= 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv198[ebp], eax
	mov	edx, DWORD PTR tv198[ebp]
	movzx	eax, BYTE PTR [edx]
	or	eax, 2
	mov	ecx, DWORD PTR tv198[ebp]
	mov	BYTE PTR [ecx], al
$LN10@Step:

; 53   : 
; 54   : 			if (counter2==456)

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv347[ebp], edx
	mov	eax, DWORD PTR tv347[ebp]
	cmp	DWORD PTR [eax+48], 456			; 000001c8H
	jne	SHORT $LN9@Step
	mov	ecx, DWORD PTR tv347[ebp]
	cmp	DWORD PTR [ecx+52], 0
	jne	SHORT $LN9@Step

; 55   : 				stat_.mode = 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+17]
	and	al, 252					; 000000fcH
	or	al, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+17], al
$LN9@Step:

; 56   : 			break;

	jmp	SHORT $LN18@Step
$LN8@Step:

; 57   : 		case 1:
; 58   :         if (stat_.vblank_int)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+17]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@Step

; 59   :           emu_->memory()->interrupt_flag() |= 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv225[ebp], eax
	mov	eax, DWORD PTR tv225[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR tv225[ebp]
	mov	BYTE PTR [edx], cl
$LN7@Step:

; 60   : 				emu_->memory()->interrupt_flag() |= 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv238[ebp], eax
	mov	ecx, DWORD PTR tv238[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR tv238[ebp]
	mov	BYTE PTR [eax], dl
$LN18@Step:

; 61   : 			break;
; 62   : 	}
; 63   : 
; 64   : 	
; 65   :   if (counter2 == 456) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv367[ebp], ecx
	mov	edx, DWORD PTR tv367[ebp]
	cmp	DWORD PTR [edx+48], 456			; 000001c8H
	jne	$LN6@Step
	mov	eax, DWORD PTR tv367[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	$LN6@Step

; 66   : 		if (ly == 153 && counter2 == 456) {

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	cmp	edx, 153				; 00000099H
	jne	$LN5@Step
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv373[ebp], eax
	mov	ecx, DWORD PTR tv373[ebp]
	cmp	DWORD PTR [ecx+48], 456			; 000001c8H
	jne	$LN5@Step
	mov	edx, DWORD PTR tv373[ebp]
	cmp	DWORD PTR [edx+52], 0
	jne	$LN5@Step

; 67   :       for (int i=0;i<256*256;++i)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@Step
$LN3@Step:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@Step:
	cmp	DWORD PTR _i$1[ebp], 65536		; 00010000H
	jge	SHORT $LN2@Step

; 68   :         frame_buffer[i] = pal32[colormap[i]];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _i$1[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _pal32[ecx*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN3@Step
$LN2@Step:

; 69   : 			emu_->on_render();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()

; 70   : 			stat_.mode = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+17]
	and	cl, 252					; 000000fcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+17], cl

; 71   : 			ly = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+20], 0

; 72   : 			counter1 = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0

; 73   : 			counter2 = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0
	mov	DWORD PTR [edx+52], 0
	jmp	SHORT $LN1@Step
$LN5@Step:

; 74   : 		} else
; 75   : 			++ly;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+20]
	add	cl, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+20], cl
$LN1@Step:

; 76   : 		counter2 = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+52], 0
$LN6@Step:

; 77   : 	}
; 78   : 
; 79   :   ++counter2; //line clock

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	add	edx, 1
	mov	eax, DWORD PTR [ecx+52]
	adc	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], edx
	mov	DWORD PTR [ecx+52], eax

; 80   :   ++counter1;//screen clock

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	add	eax, 1
	mov	ecx, DWORD PTR [edx+44]
	adc	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], eax
	mov	DWORD PTR [edx+44], ecx

; 81   : }

	pop	edi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN25@Step:
	DD	$LN11@Step
	DD	$LN8@Step
	DD	$LN17@Step
	DD	$LN14@Step
?Step@LCDDriver@gb@emulation@@QAEXN@Z ENDP		; emulation::gb::LCDDriver::Step
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_ioports$ = -8						; size = 4
_this$ = -4						; size = 4
?Deinitialize@LCDDriver@gb@emulation@@UAEXXZ PROC	; emulation::gb::LCDDriver::Deinitialize
; _this$ = ecx

; 24   : void LCDDriver::Deinitialize() {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 25   :   auto ioports = emu_->memory()->ioports();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?ioports@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::ioports
	mov	DWORD PTR _ioports$[ebp], eax

; 26   :   delete [] colormap;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 27   :   delete [] frame_buffer;  

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 28   : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Deinitialize@LCDDriver@gb@emulation@@UAEXXZ ENDP	; emulation::gb::LCDDriver::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
_emu$ = 8						; size = 4
?Initialize@LCDDriver@gb@emulation@@UAEXPAVEmu@23@@Z PROC ; emulation::gb::LCDDriver::Initialize
; _this$ = ecx

; 9    : void LCDDriver::Initialize(Emu* emu) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 10   :   Component::Initialize(emu);

	mov	eax, DWORD PTR _emu$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ; emulation::gb::Component::Initialize

; 11   :   frame_buffer = new uint32_t[256*256];

	push	11					; 0000000bH
	push	OFFSET $SG130133
	push	1
	push	262144					; 00040000H
	call	??_U@YAPAXIHPBDH@Z			; operator new[]
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+8], edx

; 12   :   lcdc_.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+16], 0

; 13   :   stat_.raw = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+17], 2

; 14   :   ly = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+20], 0

; 15   :   lyc = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], 0

; 16   :   scroll_x = scroll_y = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+19], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+18], 0

; 17   :   wx = wy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+23], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+22], 0

; 18   :   counter1 = counter2 = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0
	mov	DWORD PTR [edx+52], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0

; 19   :   vsync = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [ecx+56], xmm0

; 20   :   hsync = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [edx+64], xmm0

; 21   :   colormap = new uint8_t[256*256];

	push	21					; 00000015H
	push	OFFSET $SG130136
	push	1
	push	65536					; 00010000H
	call	??_U@YAPAXIHPBDH@Z			; operator new[]
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+12], ecx

; 22   : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Initialize@LCDDriver@gb@emulation@@UAEXPAVEmu@23@@Z ENDP ; emulation::gb::LCDDriver::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ PROC	; emulation::gb::Memory::interrupt_flag, COMDAT
; _this$ = ecx

; 21   :   uint8_t& interrupt_flag() {  return ioports_[0x0F]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	imul	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+184]
	mov	esp, ebp
	pop	ebp
	ret	0
?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ENDP	; emulation::gb::Memory::interrupt_flag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?ioports@Memory@gb@emulation@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ioports@Memory@gb@emulation@@QAEPAEXZ PROC		; emulation::gb::Memory::ioports, COMDAT
; _this$ = ecx

; 19   :   uint8_t* ioports() { return ioports_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 184				; 000000b8H
	mov	esp, ebp
	pop	ebp
	ret	0
?ioports@Memory@gb@emulation@@QAEPAEXZ ENDP		; emulation::gb::Memory::ioports
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?oam@Memory@gb@emulation@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?oam@Memory@gb@emulation@@QAEPAEXZ PROC			; emulation::gb::Memory::oam, COMDAT
; _this$ = ecx

; 18   :   uint8_t* oam() { return oam_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	esp, ebp
	pop	ebp
	ret	0
?oam@Memory@gb@emulation@@QAEPAEXZ ENDP			; emulation::gb::Memory::oam
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?vram@Memory@gb@emulation@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?vram@Memory@gb@emulation@@QAEPAEXZ PROC		; emulation::gb::Memory::vram, COMDAT
; _this$ = ecx

; 17   : 	uint8_t* vram() { return vram_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?vram@Memory@gb@emulation@@QAEPAEXZ ENDP		; emulation::gb::Memory::vram
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\gb.h
;	COMDAT ?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_emu$ = 8						; size = 4
?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z PROC ; emulation::gb::Component::Initialize, COMDAT
; _this$ = ecx

; 28   :   virtual void Initialize(Emu* emu) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 29   :     emu_ = emu;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _emu$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 30   :   }

	mov	esp, ebp
	pop	ebp
	ret	4
?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ENDP ; emulation::gb::Component::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 137  : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$yc	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 130  : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Ignore@std@@QAE@XZ PROC				; std::_Ignore::_Ignore, COMDAT
; _this$ = ecx

; 120  : 	_Ignore()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Ignore@std@@QAE@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
