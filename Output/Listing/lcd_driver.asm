; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

	TITLE	D:\Personal\Projects\GBEmu\Solution\Code\emulation\gb\lcd_driver.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?value@?$_Abs@$0GE@@std@@2_JB			; std::_Abs<100>::value
PUBLIC	?value@?$_Abs@$0DLJKMKAA@@std@@2_JB		; std::_Abs<1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?value@?$_GcdX@$0GE@$0A@@std@@2_JB		; std::_GcdX<100,0>::value
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB	; std::_GcdX<1000000000,100>::value
PUBLIC	?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
PUBLIC	?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
PUBLIC	?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<100,1000000000>::value
PUBLIC	?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
PUBLIC	?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
PUBLIC	?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<100,1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$_Abs@$00@std@@2_JB			; std::_Abs<1>::value
PUBLIC	?value@?$_GcdX@$00$0A@@std@@2_JB		; std::_GcdX<1,0>::value
PUBLIC	?value@?$_GcdX@$00$00@std@@2_JB			; std::_GcdX<1,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?value@?$_Gcd@$00$00@std@@2_JB			; std::_Gcd<1,1>::value
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_monotonic@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_monotonic
PUBLIC	?is_steady@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_steady
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB		; std::_GcdX<10000000,1>::value
PUBLIC	?value@?$integral_constant@H$0A@@std@@2HB	; std::integral_constant<int,0>::value
PUBLIC	?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB		; std::_GcdX<1,10000000>::value
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB		; std::_Gcd<1,10000000>::value
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?num@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::num
PUBLIC	?den@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::den
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
PUBLIC	?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
PUBLIC	?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_nonNull
PUBLIC	?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelException
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_notInlined
PUBLIC	?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_structured
PUBLIC	?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_localCancel
PUBLIC	?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_reserved
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
PUBLIC	?value@?$_Abs@$0JIJGIA@@std@@2_JB		; std::_Abs<10000000>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB		; std::_GcdX<10000000,0>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_GcdX<10000000,10000000>::value
PUBLIC	?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Gcd<10000000,10000000>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?num@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::num
PUBLIC	?den@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::den
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?is_monotonic@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_monotonic
PUBLIC	?is_steady@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_steady
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	_ConcRT_ProviderGuid
PUBLIC	_ConcRTEventGuid
PUBLIC	_SchedulerEventGuid
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	_ScheduleGroupEventGuid
PUBLIC	_ContextEventGuid
PUBLIC	_ChoreEventGuid
PUBLIC	_VirtualProcessorEventGuid
PUBLIC	_LockEventGuid
PUBLIC	_ResourceManagerEventGuid
PUBLIC	_PPLParallelInvokeEventGuid
PUBLIC	_PPLParallelForEventGuid
PUBLIC	_PPLParallelForeachEventGuid
PUBLIC	_AgentEventGuid
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT _AgentEventGuid
CONST	SEGMENT
_AgentEventGuid DD 0b9b5b78cH
	DW	0713H
	DW	04898H
	DB	0a2H
	DB	01aH
	DB	0c6H
	DB	079H
	DB	049H
	DB	0dcH
	DB	0edH
	DB	07H
CONST	ENDS
;	COMDAT _PPLParallelForeachEventGuid
CONST	SEGMENT
_PPLParallelForeachEventGuid DD 05cb7d785H
	DW	09d66H
	DW	0465dH
	DB	0baH
	DB	0e1H
	DB	046H
	DB	011H
	DB	06H
	DB	01bH
	DB	054H
	DB	034H
CONST	ENDS
;	COMDAT _PPLParallelForEventGuid
CONST	SEGMENT
_PPLParallelForEventGuid DD 031c8da6bH
	DW	06165H
	DW	04042H
	DB	08bH
	DB	092H
	DB	094H
	DB	09eH
	DB	031H
	DB	05fH
	DB	04dH
	DB	084H
CONST	ENDS
;	COMDAT _PPLParallelInvokeEventGuid
CONST	SEGMENT
_PPLParallelInvokeEventGuid DD 0d1b5b133H
	DW	0ec3dH
	DW	049f4H
	DB	098H
	DB	0a3H
	DB	046H
	DB	04dH
	DB	01aH
	DB	09eH
	DB	046H
	DB	082H
CONST	ENDS
;	COMDAT _ResourceManagerEventGuid
CONST	SEGMENT
_ResourceManagerEventGuid DD 02718d25bH
	DW	05bf5H
	DW	04479H
	DB	08eH
	DB	088H
	DB	0baH
	DB	0bcH
	DB	064H
	DB	0bdH
	DB	0bfH
	DB	0caH
CONST	ENDS
;	COMDAT _LockEventGuid
CONST	SEGMENT
_LockEventGuid DD 079a60dc6H
	DW	05fc8H
	DW	04952H
	DB	0a4H
	DB	01cH
	DB	011H
	DB	063H
	DB	0aeH
	DB	0ecH
	DB	05eH
	DB	0b8H
CONST	ENDS
;	COMDAT _VirtualProcessorEventGuid
CONST	SEGMENT
_VirtualProcessorEventGuid DD 02f27805fH
	DW	01676H
	DW	04eccH
	DB	096H
	DB	0faH
	DB	07eH
	DB	0b0H
	DB	09dH
	DB	044H
	DB	030H
	DB	02fH
CONST	ENDS
;	COMDAT _ChoreEventGuid
CONST	SEGMENT
_ChoreEventGuid DD 07e854ec7H
	DW	0cdc4H
	DW	0405aH
	DB	0b5H
	DB	0b2H
	DB	0aaH
	DB	0f7H
	DB	0c9H
	DB	0e7H
	DB	0d4H
	DB	0cH
CONST	ENDS
;	COMDAT _ContextEventGuid
CONST	SEGMENT
_ContextEventGuid DD 05727a00fH
	DW	050beH
	DW	04519H
	DB	082H
	DB	056H
	DB	0f7H
	DB	069H
	DB	098H
	DB	071H
	DB	0feH
	DB	0cbH
CONST	ENDS
;	COMDAT _ScheduleGroupEventGuid
CONST	SEGMENT
_ScheduleGroupEventGuid DD 0e8a3bf1fH
	DW	0a86bH
	DW	04390H
	DB	09cH
	DB	060H
	DB	053H
	DB	090H
	DB	0b9H
	DB	069H
	DB	0d2H
	DB	02cH
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT _SchedulerEventGuid
CONST	SEGMENT
_SchedulerEventGuid DD 0e2091f8aH
	DW	01e0aH
	DW	04731H
	DB	084H
	DB	0a2H
	DB	0dH
	DB	0d5H
	DB	07cH
	DB	08aH
	DB	052H
	DB	061H
CONST	ENDS
;	COMDAT _ConcRTEventGuid
CONST	SEGMENT
_ConcRTEventGuid DD 072b14a7dH
	DW	0704cH
	DW	0423eH
	DB	092H
	DB	0f8H
	DB	07eH
	DB	06dH
	DB	064H
	DB	0bcH
	DB	0b9H
	DB	02aH
CONST	ENDS
;	COMDAT _ConcRT_ProviderGuid
CONST	SEGMENT
_ConcRT_ProviderGuid DD 0f7b697a3H
	DW	04db5H
	DW	04d3bH
	DB	0beH
	DB	071H
	DB	0c4H
	DB	0d2H
	DB	084H
	DB	0e6H
	DB	059H
	DB	02fH
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?is_steady@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@steady_clock@chrono@std@@2_NB DB 01H		; std::chrono::steady_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@steady_clock@chrono@std@@2_NB DB 01H	; std::chrono::steady_clock::is_monotonic
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::num
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0JIJGIA@@std@@2_JB DQ 0000000000989680H	; std::_Abs<10000000>::value
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_reserved
CONST	ENDS
;	COMDAT ?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_localCancel
CONST	ENDS
;	COMDAT ?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_structured
CONST	ENDS
;	COMDAT ?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB DD 0ffffffffH ; Concurrency::details::_TaskCollectionBase::_S_notInlined
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_cancelException
CONST	ENDS
;	COMDAT ?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB DD 08H ; Concurrency::details::_TaskCollectionBase::_S_nonNull
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
CONST	ENDS
;	COMDAT ?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
CONST	ENDS
;	COMDAT ?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB DD 00H ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::ratio<1,10000000>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,10000000>::num
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,10000000>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@H$0A@@std@@2HB
CONST	SEGMENT
?value@?$integral_constant@H$0A@@std@@2HB DD 00H	; std::integral_constant<int,0>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000000,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?is_steady@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@system_clock@chrono@std@@2_NB DB 00H		; std::chrono::system_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@system_clock@chrono@std@@2_NB DB 00H	; std::chrono::system_clock::is_monotonic
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0A@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$00@std@@2_JB DQ 0000000000000001H	; std::_Abs<1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_Gcd<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB DD 03H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
CONST	ENDS
;	COMDAT ?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 02H ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 01H ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
CONST	ENDS
;	COMDAT ?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB DD 00H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<1000000000,100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0A@@std@@2_JB DQ 0000000000000064H	; std::_GcdX<100,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Abs<1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0GE@@std@@2_JB DQ 0000000000000064H	; std::_Abs<100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
CONST	SEGMENT
_colormap DD	0ffffffffH
	DD	0ffaaaaaaH
	DD	0ff545454H
	DD	0ff000000H
$SG130094 DB	'Code\emulation\gb\lcd_driver.cpp', 00H
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
PUBLIC	??0_Ignore@std@@QAE@XZ				; std::_Ignore::_Ignore
PUBLIC	?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ; emulation::gb::Component::Initialize
PUBLIC	?vram@Memory@gb@emulation@@QAEPAEXZ		; emulation::gb::Memory::vram
PUBLIC	?oam@Memory@gb@emulation@@QAEPAEXZ		; emulation::gb::Memory::oam
PUBLIC	?ioports@Memory@gb@emulation@@QAEPAEXZ		; emulation::gb::Memory::ioports
PUBLIC	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ	; emulation::gb::Memory::interrupt_flag
PUBLIC	?Initialize@LCDDriver@gb@emulation@@UAEXPAVEmu@23@@Z ; emulation::gb::LCDDriver::Initialize
PUBLIC	?Deinitialize@LCDDriver@gb@emulation@@UAEXXZ	; emulation::gb::LCDDriver::Deinitialize
PUBLIC	?Step@LCDDriver@gb@emulation@@QAEXN@Z		; emulation::gb::LCDDriver::Step
PUBLIC	?Read@LCDDriver@gb@emulation@@QAEEG@Z		; emulation::gb::LCDDriver::Read
PUBLIC	?Write@LCDDriver@gb@emulation@@QAEXGE@Z		; emulation::gb::LCDDriver::Write
PUBLIC	?RenderBGLine@LCDDriver@gb@emulation@@QAEXXZ	; emulation::gb::LCDDriver::RenderBGLine
PUBLIC	?RenderWindowLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderWindowLine
PUBLIC	?RenderSpriteLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderSpriteLine
PUBLIC	?RenderLine@LCDDriver@gb@emulation@@QAEXXZ	; emulation::gb::LCDDriver::RenderLine
PUBLIC	?RenderAllBGTiles@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderAllBGTiles
PUBLIC	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ	; emulation::gb::Emu::memory
PUBLIC	??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
PUBLIC	__real@0000000000000000
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXIHPBDH@Z:PROC				; operator new[]
EXTRN	__imp_?_Xbad_function_call@std@@YAXXZ:PROC
EXTRN	?Read8@Memory@gb@emulation@@QAEEG@Z:PROC	; emulation::gb::Memory::Read8
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_ignore	DB	01H DUP (?)
__Tuple_alloc DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv82 = -16						; size = 4
_d$1 = -10						; size = 1
_tileindex$ = -9					; size = 1
_bgtilemap$ = -8					; size = 4
_this$ = -4						; size = 4
??R<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QBEEXZ PROC ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::operator()
; _this$ = ecx

; 214  : 	auto readTile = [&](){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 215  : 		  uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx+12]
	shr	dl, 3
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN4@operator
	mov	DWORD PTR tv82[ebp], 6144		; 00001800H
	jmp	SHORT $LN5@operator
$LN4@operator:
	mov	DWORD PTR tv82[ebp], 7168		; 00001c00H
$LN5@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR _bgtilemap$[ebp], eax

; 216  : 			auto tileindex = bgtilemap[(mapoffset<<5) + lineoffset];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _bgtilemap$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR _tileindex$[ebp], cl

; 217  : 			if(lcdc_.tile_data == 0) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cl, BYTE PTR [eax+12]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN1@operator

; 218  : 				int8_t d = tileindex;

	mov	al, BYTE PTR _tileindex$[ebp]
	mov	BYTE PTR _d$1[ebp], al

; 219  : 				d+=128;

	movsx	ecx, BYTE PTR _d$1[ebp]
	add	ecx, 128				; 00000080H
	mov	BYTE PTR _d$1[ebp], cl

; 220  : 				tileindex = d;

	mov	dl, BYTE PTR _d$1[ebp]
	mov	BYTE PTR _tileindex$[ebp], dl
$LN1@operator:

; 221  : 			}
; 222  : 			return tileindex;

	mov	al, BYTE PTR _tileindex$[ebp]

; 223  : 	};

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QBEEXZ ENDP ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This$ = 8						; size = 4
__Mapoffset$ = 12					; size = 4
__Lineoffset$ = 16					; size = 4
??0<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QAE@PAVLCDDriver@gb@emulation@@AAH1@Z PROC ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::<lambda_97bc8e9b09435192667e87dfa941ef5a>
; _this$ = ecx

; 223  : 	};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __This$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Mapoffset$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Lineoffset$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QAE@PAVLCDDriver@gb@emulation@@AAH1@Z ENDP ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::<lambda_97bc8e9b09435192667e87dfa941ef5a>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv82 = -16						; size = 4
_d$1 = -10						; size = 1
_tileindex$ = -9					; size = 1
_bgtilemap$ = -8					; size = 4
_this$ = -4						; size = 4
??R<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QBEEXZ PROC ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::operator()
; _this$ = ecx

; 178  : 	auto readTile = [&](){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 		  uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx+12]
	shr	dl, 3
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN4@operator
	mov	DWORD PTR tv82[ebp], 6144		; 00001800H
	jmp	SHORT $LN5@operator
$LN4@operator:
	mov	DWORD PTR tv82[ebp], 7168		; 00001c00H
$LN5@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR _bgtilemap$[ebp], eax

; 180  : 			auto tileindex = bgtilemap[(mapoffset<<5)];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 5
	mov	eax, DWORD PTR _bgtilemap$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR _tileindex$[ebp], cl

; 181  : 			if(lcdc_.tile_data == 0) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cl, BYTE PTR [eax+12]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN1@operator

; 182  : 				int8_t d = tileindex;

	mov	al, BYTE PTR _tileindex$[ebp]
	mov	BYTE PTR _d$1[ebp], al

; 183  : 				d+=128;

	movsx	ecx, BYTE PTR _d$1[ebp]
	add	ecx, 128				; 00000080H
	mov	BYTE PTR _d$1[ebp], cl

; 184  : 				tileindex = d;

	mov	dl, BYTE PTR _d$1[ebp]
	mov	BYTE PTR _tileindex$[ebp], dl
$LN1@operator:

; 185  : 			}
; 186  : 			return tileindex;

	mov	al, BYTE PTR _tileindex$[ebp]

; 187  : 	};

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QBEEXZ ENDP ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This$ = 8						; size = 4
__Mapoffset$ = 12					; size = 4
??0<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QAE@PAVLCDDriver@gb@emulation@@AAH@Z PROC ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>
; _this$ = ecx

; 187  : 	};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __This$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Mapoffset$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QAE@PAVLCDDriver@gb@emulation@@AAH@Z ENDP ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ PROC ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator(), COMDAT
; _this$ = ecx

; 514  : _VARIADIC_EXPAND_P1_0(_CLASS_FUNC_CLASS_0, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN1@operator
	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_function_call@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator:
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ ENDP ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\emu.h
;	COMDAT ?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ PROC	; emulation::gb::Emu::memory, COMDAT
; _this$ = ecx

; 21   :   Memory* memory() { return &memory_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1144				; 00000478H
	mov	esp, ebp
	pop	ebp
	ret	0
?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ENDP	; emulation::gb::Emu::memory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv139 = -64						; size = 4
_tile$1 = -60						; size = 4
_tileindex$2 = -56					; size = 4
_i$3 = -52						; size = 4
_tiledata$4 = -48					; size = 4
_i$5 = -44						; size = 4
_readTile$ = -36					; size = 8
_x$ = -24						; size = 4
_y$ = -20						; size = 4
_mapoffset$ = -12					; size = 4
_this$ = -4						; size = 4
?RenderAllBGTiles@LCDDriver@gb@emulation@@QAEXXZ PROC	; emulation::gb::LCDDriver::RenderAllBGTiles
; _this$ = ecx

; 174  : void LCDDriver::RenderAllBGTiles() {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 	auto mapoffset = ((ly)&0xFF) >> 3;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	and	ecx, 255				; 000000ffH
	sar	ecx, 3
	mov	DWORD PTR _mapoffset$[ebp], ecx

; 176  : 	auto y = (ly) & 7;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	and	eax, 7
	mov	DWORD PTR _y$[ebp], eax

; 177  : 	auto x = 0;

	mov	DWORD PTR _x$[ebp], 0

; 178  : 	auto readTile = [&](){
; 179  : 		  uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];
; 180  : 			auto tileindex = bgtilemap[(mapoffset<<5)];
; 181  : 			if(lcdc_.tile_data == 0) {
; 182  : 				int8_t d = tileindex;
; 183  : 				d+=128;
; 184  : 				tileindex = d;
; 185  : 			}
; 186  : 			return tileindex;
; 187  : 	};

	lea	ecx, DWORD PTR _mapoffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	ecx, DWORD PTR _readTile$[ebp]
	call	??0<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QAE@PAVLCDDriver@gb@emulation@@AAH@Z ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>

; 188  : 
; 189  : 	if (lcdc_.bgdisplay == 0) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+12]
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN9@RenderAllB

; 190  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN8@RenderAllB
$LN7@RenderAllB:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN8@RenderAllB:
	cmp	DWORD PTR _i$5[ebp], 256		; 00000100H
	jge	SHORT $LN6@RenderAllB

; 191  : 			frame_buffer[((ly)<<8)+(i)] = colormap[0];

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	shl	eax, 8
	add	eax, DWORD PTR _i$5[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _colormap[ecx]
	mov	DWORD PTR [edx+eax*4], ecx

; 192  : 		}

	jmp	SHORT $LN7@RenderAllB
$LN6@RenderAllB:
	jmp	$LN10@RenderAllB
$LN9@RenderAllB:

; 193  : 	} else {
; 194  : 		uint8_t* tiledata = &emu_->memory()->vram()[lcdc_.tile_data ==0?0x0800:0x0000];

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+12]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN12@RenderAllB
	mov	DWORD PTR tv139[ebp], 2048		; 00000800H
	jmp	SHORT $LN13@RenderAllB
$LN12@RenderAllB:
	mov	DWORD PTR tv139[ebp], 0
$LN13@RenderAllB:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv139[ebp]
	mov	DWORD PTR _tiledata$4[ebp], eax

; 195  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@RenderAllB
$LN3@RenderAllB:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@RenderAllB:
	cmp	DWORD PTR _i$3[ebp], 256		; 00000100H
	jge	$LN10@RenderAllB

; 196  : 			auto tileindex = (i>>3)+(ly>>3)*32;

	mov	ecx, DWORD PTR _i$3[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	sar	eax, 3
	shl	eax, 5
	add	ecx, eax
	mov	DWORD PTR _tileindex$2[ebp], ecx

; 197  : 			uint8_t* tile = &tiledata[(tileindex<<4)];

	mov	ecx, DWORD PTR _tileindex$2[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _tiledata$4[ebp]
	mov	DWORD PTR _tile$1[ebp], ecx

; 198  : 			#define pixel(bit) ((tile[y<<1]>>(bit))&0x1+((tile[(y<<1)+1]>>(bit))<<1))
; 199  : 			frame_buffer[((ly)<<8)+i] = colormap[bg_pal[pixel((7-x))]];

	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _tile$1[ebp]
	movzx	edx, BYTE PTR [eax+edx*2]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$[ebp]
	sar	edx, cl
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _tile$1[ebp]
	movzx	eax, BYTE PTR [ecx+eax*2+1]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$[ebp]
	sar	eax, cl
	lea	ecx, DWORD PTR [eax+eax+1]
	and	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+20]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	shl	eax, 8
	add	eax, DWORD PTR _i$3[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _colormap[ecx*4]
	mov	DWORD PTR [edx+eax*4], ecx

; 200  : 			#undef pixel
; 201  : 			++x;

	mov	edx, DWORD PTR _x$[ebp]
	add	edx, 1
	mov	DWORD PTR _x$[ebp], edx

; 202  : 			if (x==8) {

	cmp	DWORD PTR _x$[ebp], 8
	jne	SHORT $LN1@RenderAllB

; 203  : 				x = 0;

	mov	DWORD PTR _x$[ebp], 0
$LN1@RenderAllB:

; 204  : 			}
; 205  : 		}

	jmp	$LN3@RenderAllB
$LN10@RenderAllB:

; 206  : 	}
; 207  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@RenderAllB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@RenderAllB:
	DD	2
	DD	$LN16@RenderAllB
$LN16@RenderAllB:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN14@RenderAllB
	DD	-36					; ffffffdcH
	DD	8
	DD	$LN15@RenderAllB
$LN15@RenderAllB:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$LN14@RenderAllB:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?RenderAllBGTiles@LCDDriver@gb@emulation@@QAEXXZ ENDP	; emulation::gb::LCDDriver::RenderAllBGTiles
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RenderLine@LCDDriver@gb@emulation@@QAEXXZ PROC		; emulation::gb::LCDDriver::RenderLine
; _this$ = ecx

; 287  : void LCDDriver::RenderLine() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 	RenderBGLine();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenderBGLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderBGLine

; 289  : 	RenderWindowLine();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenderWindowLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderWindowLine

; 290  : 	RenderSpriteLine();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenderSpriteLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderSpriteLine

; 291  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderLine@LCDDriver@gb@emulation@@QAEXXZ ENDP		; emulation::gb::LCDDriver::RenderLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_a$1 = -8						; size = 4
_this$ = -4						; size = 4
?RenderSpriteLine@LCDDriver@gb@emulation@@QAEXXZ PROC	; emulation::gb::LCDDriver::RenderSpriteLine
; _this$ = ecx

; 281  : void LCDDriver::RenderSpriteLine() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 282  : 	if (lcdc_.sprite_enable == 1) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+12]
	shr	cl, 1
	and	cl, 1
	movzx	edx, cl
	cmp	edx, 1
	jne	SHORT $LN2@RenderSpri

; 283  : 		int a =1;

	mov	DWORD PTR _a$1[ebp], 1
$LN2@RenderSpri:

; 284  : 	}
; 285  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RenderSpriteLine@LCDDriver@gb@emulation@@QAEXXZ ENDP	; emulation::gb::LCDDriver::RenderSpriteLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv137 = -52						; size = 4
tv86 = -48						; size = 4
_tile$1 = -44						; size = 4
_d$2 = -37						; size = 1
_x$3 = -36						; size = 4
_y$4 = -32						; size = 4
_tileindex$5 = -25					; size = 1
_lineoffset$6 = -24					; size = 4
_mapoffset$7 = -20					; size = 4
_i$8 = -16						; size = 4
_tilemap$9 = -12					; size = 4
_tiledata$10 = -8					; size = 4
_this$ = -4						; size = 4
?RenderWindowLine@LCDDriver@gb@emulation@@QAEXXZ PROC	; emulation::gb::LCDDriver::RenderWindowLine
; _this$ = ecx

; 246  : void LCDDriver::RenderWindowLine() {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 	if (lcdc_.window_enable == 1) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+12]
	shr	cl, 5
	and	cl, 1
	movzx	edx, cl
	cmp	edx, 1
	jne	$LN6@RenderWind

; 248  : 		uint8_t* tiledata = &emu_->memory()->vram()[lcdc_.tile_data ==0?0x0800:0x0000];

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+12]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN8@RenderWind
	mov	DWORD PTR tv86[ebp], 2048		; 00000800H
	jmp	SHORT $LN9@RenderWind
$LN8@RenderWind:
	mov	DWORD PTR tv86[ebp], 0
$LN9@RenderWind:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR _tiledata$10[ebp], eax

; 249  : 		uint8_t* tilemap = &emu_->memory()->vram()[lcdc_.window_tile_map ==0?0x1800:0x1C00];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+12]
	shr	dl, 6
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN10@RenderWind
	mov	DWORD PTR tv137[ebp], 6144		; 00001800H
	jmp	SHORT $LN11@RenderWind
$LN10@RenderWind:
	mov	DWORD PTR tv137[ebp], 7168		; 00001c00H
$LN11@RenderWind:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv137[ebp]
	mov	DWORD PTR _tilemap$9[ebp], eax

; 250  : 		for (int i=0;i<32;++i) {

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN4@RenderWind
$LN3@RenderWind:
	mov	edx, DWORD PTR _i$8[ebp]
	add	edx, 1
	mov	DWORD PTR _i$8[ebp], edx
$LN4@RenderWind:
	cmp	DWORD PTR _i$8[ebp], 32			; 00000020H
	jge	$LN6@RenderWind

; 251  : 			auto mapoffset = ((ly)&0xFF) >> 3;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	and	ecx, 255				; 000000ffH
	sar	ecx, 3
	mov	DWORD PTR _mapoffset$7[ebp], ecx

; 252  : 			auto lineoffset = (i)&0x1F;

	mov	edx, DWORD PTR _i$8[ebp]
	and	edx, 31					; 0000001fH
	mov	DWORD PTR _lineoffset$6[ebp], edx

; 253  : 			auto tileindex = tilemap[(mapoffset<<5) + lineoffset];

	mov	eax, DWORD PTR _mapoffset$7[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _lineoffset$6[ebp]
	mov	ecx, DWORD PTR _tilemap$9[ebp]
	mov	dl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _tileindex$5[ebp], dl

; 254  : 			auto y = (ly) & 7;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	and	ecx, 7
	mov	DWORD PTR _y$4[ebp], ecx

; 255  : 			auto x = 0;

	mov	DWORD PTR _x$3[ebp], 0

; 256  : 			if(lcdc_.tile_data == 0) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+12]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@RenderWind

; 257  : 				int8_t d = tileindex;

	mov	dl, BYTE PTR _tileindex$5[ebp]
	mov	BYTE PTR _d$2[ebp], dl

; 258  : 				d+=128;

	movsx	eax, BYTE PTR _d$2[ebp]
	add	eax, 128				; 00000080H
	mov	BYTE PTR _d$2[ebp], al

; 259  : 				tileindex = d;

	mov	cl, BYTE PTR _d$2[ebp]
	mov	BYTE PTR _tileindex$5[ebp], cl
$LN1@RenderWind:

; 260  : 			}
; 261  : 			uint8_t* tile = &tiledata[(tileindex<<4)];

	movzx	edx, BYTE PTR _tileindex$5[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _tiledata$10[ebp]
	mov	DWORD PTR _tile$1[ebp], edx

; 262  : 
; 263  : 			#define pixel(bit) ((tile[y<<1]>>bit)&0x1+((tile[(y<<1)+1]>>bit)<<1))
; 264  : 
; 265  : 			frame_buffer[((ly)<<8)+((i<<3)+0)] = colormap[bg_pal[pixel(7)]];

	mov	eax, DWORD PTR _y$4[ebp]
	mov	ecx, DWORD PTR _tile$1[ebp]
	movzx	edx, BYTE PTR [ecx+eax*2]
	sar	edx, 7
	mov	eax, DWORD PTR _y$4[ebp]
	mov	ecx, DWORD PTR _tile$1[ebp]
	movzx	eax, BYTE PTR [ecx+eax*2+1]
	sar	eax, 7
	lea	ecx, DWORD PTR [eax+eax+1]
	and	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+20]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	shl	eax, 8
	mov	edx, DWORD PTR _i$8[ebp]
	lea	eax, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _colormap[ecx*4]
	mov	DWORD PTR [edx+eax*4], ecx

; 266  : 			frame_buffer[((ly)<<8)+((i<<3)+1)] = colormap[bg_pal[pixel(6)]];

	mov	edx, DWORD PTR _y$4[ebp]
	mov	eax, DWORD PTR _tile$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx*2]
	sar	ecx, 6
	mov	edx, DWORD PTR _y$4[ebp]
	mov	eax, DWORD PTR _tile$1[ebp]
	movzx	edx, BYTE PTR [eax+edx*2+1]
	sar	edx, 6
	lea	eax, DWORD PTR [edx+edx+1]
	and	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	shl	edx, 8
	mov	ecx, DWORD PTR _i$8[ebp]
	lea	edx, DWORD PTR [edx+ecx*8+1]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _colormap[eax*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 267  : 			frame_buffer[((ly)<<8)+((i<<3)+2)] = colormap[bg_pal[pixel(5)]];

	mov	ecx, DWORD PTR _y$4[ebp]
	mov	edx, DWORD PTR _tile$1[ebp]
	movzx	eax, BYTE PTR [edx+ecx*2]
	sar	eax, 5
	mov	ecx, DWORD PTR _y$4[ebp]
	mov	edx, DWORD PTR _tile$1[ebp]
	movzx	ecx, BYTE PTR [edx+ecx*2+1]
	sar	ecx, 5
	lea	edx, DWORD PTR [ecx+ecx+1]
	and	eax, edx
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+20]
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	shl	ecx, 8
	mov	eax, DWORD PTR _i$8[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8+2]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _colormap[edx*4]
	mov	DWORD PTR [eax+ecx*4], edx

; 268  : 			frame_buffer[((ly)<<8)+((i<<3)+3)] = colormap[bg_pal[pixel(4)]];

	mov	eax, DWORD PTR _y$4[ebp]
	mov	ecx, DWORD PTR _tile$1[ebp]
	movzx	edx, BYTE PTR [ecx+eax*2]
	sar	edx, 4
	mov	eax, DWORD PTR _y$4[ebp]
	mov	ecx, DWORD PTR _tile$1[ebp]
	movzx	eax, BYTE PTR [ecx+eax*2+1]
	sar	eax, 4
	lea	ecx, DWORD PTR [eax+eax+1]
	and	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+20]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	shl	eax, 8
	mov	edx, DWORD PTR _i$8[ebp]
	lea	eax, DWORD PTR [eax+edx*8+3]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _colormap[ecx*4]
	mov	DWORD PTR [edx+eax*4], ecx

; 269  : 			
; 270  : 			
; 271  : 			frame_buffer[((ly)<<8)+((i<<3)+4)] = colormap[bg_pal[pixel(3)]];

	mov	edx, DWORD PTR _y$4[ebp]
	mov	eax, DWORD PTR _tile$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx*2]
	sar	ecx, 3
	mov	edx, DWORD PTR _y$4[ebp]
	mov	eax, DWORD PTR _tile$1[ebp]
	movzx	edx, BYTE PTR [eax+edx*2+1]
	sar	edx, 3
	lea	eax, DWORD PTR [edx+edx+1]
	and	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	shl	edx, 8
	mov	ecx, DWORD PTR _i$8[ebp]
	lea	edx, DWORD PTR [edx+ecx*8+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _colormap[eax*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 272  : 			frame_buffer[((ly)<<8)+((i<<3)+5)] = colormap[bg_pal[pixel(2)]];

	mov	ecx, DWORD PTR _y$4[ebp]
	mov	edx, DWORD PTR _tile$1[ebp]
	movzx	eax, BYTE PTR [edx+ecx*2]
	sar	eax, 2
	mov	ecx, DWORD PTR _y$4[ebp]
	mov	edx, DWORD PTR _tile$1[ebp]
	movzx	ecx, BYTE PTR [edx+ecx*2+1]
	sar	ecx, 2
	lea	edx, DWORD PTR [ecx+ecx+1]
	and	eax, edx
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+20]
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	shl	ecx, 8
	mov	eax, DWORD PTR _i$8[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8+5]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _colormap[edx*4]
	mov	DWORD PTR [eax+ecx*4], edx

; 273  : 			frame_buffer[((ly)<<8)+((i<<3)+6)] = colormap[bg_pal[pixel(1)]];

	mov	eax, DWORD PTR _y$4[ebp]
	mov	ecx, DWORD PTR _tile$1[ebp]
	movzx	edx, BYTE PTR [ecx+eax*2]
	sar	edx, 1
	mov	eax, DWORD PTR _y$4[ebp]
	mov	ecx, DWORD PTR _tile$1[ebp]
	movzx	eax, BYTE PTR [ecx+eax*2+1]
	sar	eax, 1
	lea	ecx, DWORD PTR [eax+eax+1]
	and	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+20]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	shl	eax, 8
	mov	edx, DWORD PTR _i$8[ebp]
	lea	eax, DWORD PTR [eax+edx*8+6]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _colormap[ecx*4]
	mov	DWORD PTR [edx+eax*4], ecx

; 274  : 			frame_buffer[((ly)<<8)+((i<<3)+7)] = colormap[bg_pal[pixel(0)]];

	mov	edx, DWORD PTR _y$4[ebp]
	mov	eax, DWORD PTR _tile$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx*2]
	sar	ecx, 0
	mov	edx, DWORD PTR _y$4[ebp]
	mov	eax, DWORD PTR _tile$1[ebp]
	movzx	edx, BYTE PTR [eax+edx*2+1]
	sar	edx, 0
	lea	eax, DWORD PTR [edx+edx+1]
	and	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	shl	edx, 8
	mov	ecx, DWORD PTR _i$8[ebp]
	lea	edx, DWORD PTR [edx+ecx*8+7]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _colormap[eax*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 275  : 
; 276  : 			#undef pixel
; 277  : 		}

	jmp	$LN3@RenderWind
$LN6@RenderWind:

; 278  : 	}
; 279  : }

	pop	edi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderWindowLine@LCDDriver@gb@emulation@@QAEXXZ ENDP	; emulation::gb::LCDDriver::RenderWindowLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv153 = -80						; size = 4
_tile$1 = -76						; size = 4
_tileindex$2 = -69					; size = 1
_i$3 = -68						; size = 4
_tiledata$4 = -64					; size = 4
_i$5 = -60						; size = 4
_readTile$ = -52					; size = 12
_x$ = -36						; size = 4
_y$ = -32						; size = 4
_lineoffset$ = -24					; size = 4
_mapoffset$ = -12					; size = 4
_this$ = -4						; size = 4
?RenderBGLine@LCDDriver@gb@emulation@@QAEXXZ PROC	; emulation::gb::LCDDriver::RenderBGLine
; _this$ = ecx

; 209  : void LCDDriver::RenderBGLine() {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 210  : 	auto mapoffset = ((ly+scroll_y)&0xFF) >> 3;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+15]
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	sar	ecx, 3
	mov	DWORD PTR _mapoffset$[ebp], ecx

; 211  : 	auto lineoffset = ((scroll_x>>3))&0x1F;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+14]
	sar	edx, 3
	and	edx, 31					; 0000001fH
	mov	DWORD PTR _lineoffset$[ebp], edx

; 212  : 	auto y = (ly + scroll_y) & 7;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+15]
	add	ecx, eax
	and	ecx, 7
	mov	DWORD PTR _y$[ebp], ecx

; 213  : 	auto x = scroll_x & 7;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+14]
	and	edx, 7
	mov	DWORD PTR _x$[ebp], edx

; 214  : 	auto readTile = [&](){
; 215  : 		  uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];
; 216  : 			auto tileindex = bgtilemap[(mapoffset<<5) + lineoffset];
; 217  : 			if(lcdc_.tile_data == 0) {
; 218  : 				int8_t d = tileindex;
; 219  : 				d+=128;
; 220  : 				tileindex = d;
; 221  : 			}
; 222  : 			return tileindex;
; 223  : 	};

	lea	eax, DWORD PTR _lineoffset$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mapoffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	ecx, DWORD PTR _readTile$[ebp]
	call	??0<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QAE@PAVLCDDriver@gb@emulation@@AAH1@Z ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::<lambda_97bc8e9b09435192667e87dfa941ef5a>

; 224  : 
; 225  : 	if (lcdc_.bgdisplay == 0) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+12]
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN9@RenderBGLi

; 226  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN8@RenderBGLi
$LN7@RenderBGLi:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN8@RenderBGLi:
	cmp	DWORD PTR _i$5[ebp], 256		; 00000100H
	jge	SHORT $LN6@RenderBGLi

; 227  : 			frame_buffer[((ly)<<8)+(i)] = colormap[0];

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	shl	eax, 8
	add	eax, DWORD PTR _i$5[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _colormap[ecx]
	mov	DWORD PTR [edx+eax*4], ecx

; 228  : 		}

	jmp	SHORT $LN7@RenderBGLi
$LN6@RenderBGLi:
	jmp	$LN10@RenderBGLi
$LN9@RenderBGLi:

; 229  : 	} else {
; 230  : 		uint8_t* tiledata = &emu_->memory()->vram()[lcdc_.tile_data ==0?0x0800:0x0000];

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+12]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN12@RenderBGLi
	mov	DWORD PTR tv153[ebp], 2048		; 00000800H
	jmp	SHORT $LN13@RenderBGLi
$LN12@RenderBGLi:
	mov	DWORD PTR tv153[ebp], 0
$LN13@RenderBGLi:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv153[ebp]
	mov	DWORD PTR _tiledata$4[ebp], eax

; 231  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@RenderBGLi
$LN3@RenderBGLi:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@RenderBGLi:
	cmp	DWORD PTR _i$3[ebp], 256		; 00000100H
	jge	$LN10@RenderBGLi

; 232  : 			auto tileindex = readTile();

	lea	ecx, DWORD PTR _readTile$[ebp]
	call	??R<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QBEEXZ ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::operator()
	mov	BYTE PTR _tileindex$2[ebp], al

; 233  : 			uint8_t* tile = &tiledata[(tileindex<<4)];

	movzx	ecx, BYTE PTR _tileindex$2[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _tiledata$4[ebp]
	mov	DWORD PTR _tile$1[ebp], ecx

; 234  : 			#define pixel(bit) ((tile[y<<1]>>(bit))&0x1+((tile[(y<<1)+1]>>(bit))<<1))
; 235  : 			frame_buffer[((ly)<<8)+i] = colormap[bg_pal[pixel((7-x))]];

	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _tile$1[ebp]
	movzx	edx, BYTE PTR [eax+edx*2]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$[ebp]
	sar	edx, cl
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _tile$1[ebp]
	movzx	eax, BYTE PTR [ecx+eax*2+1]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$[ebp]
	sar	eax, cl
	lea	ecx, DWORD PTR [eax+eax+1]
	and	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+20]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	shl	eax, 8
	add	eax, DWORD PTR _i$3[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _colormap[ecx*4]
	mov	DWORD PTR [edx+eax*4], ecx

; 236  : 			#undef pixel
; 237  : 			++x;

	mov	edx, DWORD PTR _x$[ebp]
	add	edx, 1
	mov	DWORD PTR _x$[ebp], edx

; 238  : 			if (x==8) {

	cmp	DWORD PTR _x$[ebp], 8
	jne	SHORT $LN1@RenderBGLi

; 239  : 				x = 0;

	mov	DWORD PTR _x$[ebp], 0

; 240  : 				lineoffset = (lineoffset+1)&0x1F;

	mov	eax, DWORD PTR _lineoffset$[ebp]
	add	eax, 1
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _lineoffset$[ebp], eax
$LN1@RenderBGLi:

; 241  : 			}
; 242  : 		}

	jmp	$LN3@RenderBGLi
$LN10@RenderBGLi:

; 243  : 	}
; 244  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@RenderBGLi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@RenderBGLi:
	DD	3
	DD	$LN17@RenderBGLi
$LN17@RenderBGLi:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN14@RenderBGLi
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN15@RenderBGLi
	DD	-52					; ffffffccH
	DD	12					; 0000000cH
	DD	$LN16@RenderBGLi
$LN16@RenderBGLi:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$LN15@RenderBGLi:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN14@RenderBGLi:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?RenderBGLine@LCDDriver@gb@emulation@@QAEXXZ ENDP	; emulation::gb::LCDDriver::RenderBGLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv140 = -22						; size = 2
tv65 = -20						; size = 4
_i$1 = -16						; size = 4
_dest$2 = -12						; size = 4
_srcaddr$3 = -8						; size = 2
_this$ = -4						; size = 4
_address$ = 8						; size = 2
_data$ = 12						; size = 1
?Write@LCDDriver@gb@emulation@@QAEXGE@Z PROC		; emulation::gb::LCDDriver::Write
; _this$ = ecx

; 115  : void LCDDriver::Write(uint16_t address, uint8_t data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 116  :   switch (address) {

	movzx	eax, WORD PTR _address$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 65344				; 0000ff40H
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 11			; 0000000bH
	ja	$LN18@Write
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN20@Write[edx*4]
$LN15@Write:

; 117  :     case 0xFF40:
; 118  :       lcdc_.raw = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax+12], cl

; 119  :       break;

	jmp	$LN18@Write
$LN14@Write:

; 120  :     case 0xFF41:
; 121  :       stat_.raw = (data & ~0x7) | (stat_.raw&0x7);

	movzx	edx, BYTE PTR _data$[ebp]
	and	edx, -8					; fffffff8H
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+13]
	and	ecx, 7
	or	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+13], dl

; 122  :       break;

	jmp	$LN18@Write
$LN13@Write:

; 123  :     case 0xFF42:
; 124  :       scroll_y = data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [ecx+15], dl

; 125  :       break;

	jmp	$LN18@Write
$LN12@Write:

; 126  :     case 0xFF43:
; 127  :       scroll_x = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax+14], cl

; 128  :       break;

	jmp	$LN18@Write

; 129  :       break;

	jmp	$LN18@Write
$LN11@Write:

; 130  :     case 0xFF44:
; 131  :       ly = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+16], 0

; 132  :       break;

	jmp	$LN18@Write
$LN10@Write:

; 133  :     case 0xFF45:
; 134  :       lyc = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax+17], cl

; 135  :       break;

	jmp	$LN18@Write
$LN9@Write:

; 136  :     case 0xFF46: {
; 137  :       uint16_t srcaddr = data<<8;

	movzx	edx, BYTE PTR _data$[ebp]
	shl	edx, 8
	mov	WORD PTR _srcaddr$3[ebp], dx

; 138  :       auto dest = emu_->memory()->oam();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?oam@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::oam
	mov	DWORD PTR _dest$2[ebp], eax

; 139  :       for (int i=0;i<160;++i)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN8@Write
$LN7@Write:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN8@Write:
	cmp	DWORD PTR _i$1[ebp], 160		; 000000a0H
	jge	SHORT $LN6@Write

; 140  :         dest[i] = emu_->memory()->Read8(srcaddr++);

	mov	dx, WORD PTR _srcaddr$3[ebp]
	mov	WORD PTR tv140[ebp], dx
	mov	ax, WORD PTR _srcaddr$3[ebp]
	add	ax, 1
	mov	WORD PTR _srcaddr$3[ebp], ax
	movzx	ecx, WORD PTR tv140[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, DWORD PTR _dest$2[ebp]
	add	ecx, DWORD PTR _i$1[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN7@Write
$LN6@Write:

; 141  :       break;

	jmp	$LN18@Write
$LN5@Write:

; 142  :     }
; 143  :     case 0xFF47:
; 144  :       bg_pallete_data = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _data$[ebp]
	mov	BYTE PTR [edx+32], al

; 145  :       bg_pal[0] = data&0x3;

	movzx	ecx, BYTE PTR _data$[ebp]
	and	ecx, 3
	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+20], cl

; 146  :       bg_pal[1] = (data>>2)&0x3;

	movzx	ecx, BYTE PTR _data$[ebp]
	sar	ecx, 2
	and	ecx, 3
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+20], cl

; 147  :       bg_pal[2] = (data>>4)&0x3;

	movzx	ecx, BYTE PTR _data$[ebp]
	sar	ecx, 4
	and	ecx, 3
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+20], cl

; 148  :       bg_pal[3] = (data>>6)&0x3;

	movzx	ecx, BYTE PTR _data$[ebp]
	sar	ecx, 6
	and	ecx, 3
	mov	edx, 1
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+20], cl

; 149  :       break;

	jmp	$LN18@Write
$LN4@Write:

; 150  :     case 0xFF48:
; 151  :       obj_pallete1_data = data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [ecx+33], dl

; 152  :       obj_pal1[0] = data&0x3;

	movzx	eax, BYTE PTR _data$[ebp]
	and	eax, 3
	mov	ecx, 1
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+24], al

; 153  :       obj_pal1[1] = (data>>2)&0x3;

	movzx	eax, BYTE PTR _data$[ebp]
	sar	eax, 2
	and	eax, 3
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+24], al

; 154  :       obj_pal1[2] = (data>>4)&0x3;

	movzx	eax, BYTE PTR _data$[ebp]
	sar	eax, 4
	and	eax, 3
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+24], al

; 155  :       obj_pal1[3] = (data>>6)&0x3;

	movzx	eax, BYTE PTR _data$[ebp]
	sar	eax, 6
	and	eax, 3
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+24], al

; 156  :       break;

	jmp	SHORT $LN18@Write
$LN3@Write:

; 157  :     case 0xFF49:
; 158  :       obj_pallete2_data = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax+34], cl

; 159  :       obj_pal2[0] = data&0x3;

	movzx	edx, BYTE PTR _data$[ebp]
	and	edx, 3
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+28], dl

; 160  :       obj_pal2[1] = (data>>2)&0x3;

	movzx	edx, BYTE PTR _data$[ebp]
	sar	edx, 2
	and	edx, 3
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+28], dl

; 161  :       obj_pal2[2] = (data>>4)&0x3;

	movzx	edx, BYTE PTR _data$[ebp]
	sar	edx, 4
	and	edx, 3
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+28], dl

; 162  :       obj_pal2[3] = (data>>6)&0x3;

	movzx	edx, BYTE PTR _data$[ebp]
	sar	edx, 6
	and	edx, 3
	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+28], dl

; 163  :       break;

	jmp	SHORT $LN18@Write
$LN2@Write:

; 164  :     case 0xFF4A:
; 165  :       wy = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _data$[ebp]
	mov	BYTE PTR [edx+19], al

; 166  :       break;

	jmp	SHORT $LN18@Write
$LN1@Write:

; 167  :     case 0xFF4B:
; 168  :       wx = data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [ecx+18], dl
$LN18@Write:

; 169  :       break;
; 170  :   }
; 171  : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN20@Write:
	DD	$LN15@Write
	DD	$LN14@Write
	DD	$LN13@Write
	DD	$LN12@Write
	DD	$LN11@Write
	DD	$LN10@Write
	DD	$LN9@Write
	DD	$LN5@Write
	DD	$LN4@Write
	DD	$LN3@Write
	DD	$LN2@Write
	DD	$LN1@Write
?Write@LCDDriver@gb@emulation@@QAEXGE@Z ENDP		; emulation::gb::LCDDriver::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
_address$ = 8						; size = 2
?Read@LCDDriver@gb@emulation@@QAEEG@Z PROC		; emulation::gb::LCDDriver::Read
; _this$ = ecx

; 86   : uint8_t LCDDriver::Read(uint16_t address) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 
; 88   :   switch (address) {

	movzx	eax, WORD PTR _address$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 65344				; 0000ff40H
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 11			; 0000000bH
	ja	SHORT $LN12@Read
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN16@Read[edx*4]
$LN11@Read:

; 89   :     case 0xFF40:
; 90   :       return lcdc_.raw;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+12]
	jmp	SHORT $LN14@Read
$LN10@Read:

; 91   :     case 0xFF41:
; 92   :       return stat_.raw;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+13]
	jmp	SHORT $LN14@Read
$LN9@Read:

; 93   :     case 0xFF42:
; 94   :       return scroll_y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+15]
	jmp	SHORT $LN14@Read
$LN8@Read:

; 95   :     case 0xFF43:
; 96   :       return scroll_x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+14]
	jmp	SHORT $LN14@Read
$LN7@Read:

; 97   :     case 0xFF44:
; 98   :       return ly;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+16]
	jmp	SHORT $LN14@Read
$LN6@Read:

; 99   :     case 0xFF45:
; 100  :       return lyc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+17]
	jmp	SHORT $LN14@Read
$LN5@Read:

; 101  :     case 0xFF47:
; 102  :       return bg_pallete_data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+32]
	jmp	SHORT $LN14@Read
$LN4@Read:

; 103  :     case 0xFF48:
; 104  :       return obj_pallete1_data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+33]
	jmp	SHORT $LN14@Read
$LN3@Read:

; 105  :     case 0xFF49:
; 106  :       return obj_pallete2_data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+34]
	jmp	SHORT $LN14@Read
$LN2@Read:

; 107  :     case 0xFF4A:
; 108  :       return wy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+19]
	jmp	SHORT $LN14@Read
$LN1@Read:

; 109  :     case 0xFF4B:
; 110  :       return wx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+18]
	jmp	SHORT $LN14@Read
$LN12@Read:

; 111  :   }
; 112  : 	return 0;

	xor	al, al
$LN14@Read:

; 113  : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN16@Read:
	DD	$LN11@Read
	DD	$LN10@Read
	DD	$LN9@Read
	DD	$LN8@Read
	DD	$LN7@Read
	DD	$LN6@Read
	DD	$LN12@Read
	DD	$LN5@Read
	DD	$LN4@Read
	DD	$LN3@Read
	DD	$LN2@Read
	DD	$LN1@Read
?Read@LCDDriver@gb@emulation@@QAEEG@Z ENDP		; emulation::gb::LCDDriver::Read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv250 = -36						; size = 4
tv244 = -32						; size = 4
tv156 = -28						; size = 4
tv227 = -24						; size = 4
tv219 = -20						; size = 4
tv211 = -16						; size = 4
tv82 = -12						; size = 4
tv71 = -5						; size = 1
_this$ = -4						; size = 4
_dt$ = 8						; size = 8
?Step@LCDDriver@gb@emulation@@QAEXN@Z PROC		; emulation::gb::LCDDriver::Step
; _this$ = ecx

; 28   : void LCDDriver::Step(double dt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 29   : 	stat_.coincidence = lyc == ly;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	cmp	ecx, eax
	jne	SHORT $LN16@Step
	mov	BYTE PTR tv71[ebp], 1
	jmp	SHORT $LN17@Step
$LN16@Step:
	mov	BYTE PTR tv71[ebp], 0
$LN17@Step:
	mov	cl, BYTE PTR tv71[ebp]
	and	cl, 1
	shl	cl, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+13]
	and	al, 251					; 000000fbH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+13], al

; 30   :   
; 31   : 
; 32   : 	switch (stat_.mode) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+13]
	and	al, 3
	mov	BYTE PTR tv82[ebp], al
	je	SHORT $LN11@Step
	cmp	BYTE PTR tv82[ebp], 2
	je	SHORT $LN9@Step
	cmp	BYTE PTR tv82[ebp], 3
	je	SHORT $LN7@Step
	jmp	$LN12@Step
$LN11@Step:

; 33   : 		case 0:
; 34   : 			if (counter2==204)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv211[ebp], ecx
	mov	edx, DWORD PTR tv211[ebp]
	cmp	DWORD PTR [edx+48], 204			; 000000ccH
	jne	SHORT $LN10@Step
	mov	eax, DWORD PTR tv211[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN10@Step

; 35   : 				stat_.mode = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+13]
	and	dl, 252					; 000000fcH
	or	dl, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+13], dl
$LN10@Step:

; 36   : 			break;

	jmp	$LN12@Step
$LN9@Step:

; 37   : 		case 2:
; 38   : 			if (counter2==284)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv219[ebp], ecx
	mov	edx, DWORD PTR tv219[ebp]
	cmp	DWORD PTR [edx+48], 284			; 0000011cH
	jne	SHORT $LN8@Step
	mov	eax, DWORD PTR tv219[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN8@Step

; 39   : 				stat_.mode = 3;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+13]
	or	dl, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+13], dl
$LN8@Step:

; 40   : 			break;

	jmp	SHORT $LN12@Step
$LN7@Step:

; 41   : 		case 3:
; 42   : 		  if (counter2 == 456) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv227[ebp], ecx
	mov	edx, DWORD PTR tv227[ebp]
	cmp	DWORD PTR [edx+48], 456			; 000001c8H
	jne	SHORT $LN12@Step
	mov	eax, DWORD PTR tv227[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN12@Step

; 43   : 	  		RenderLine();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenderLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderLine

; 44   : 				stat_.mode = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+13]
	and	dl, 252					; 000000fcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+13], dl

; 45   : 				if (ly == 143) 

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 143				; 0000008fH
	jne	SHORT $LN5@Step

; 46   : 					stat_.mode = 1;//vblank period

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+13]
	and	cl, 252					; 000000fcH
	or	cl, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+13], cl
$LN5@Step:

; 47   : 					emu_->memory()->interrupt_flag() |= 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv156[ebp], eax
	mov	ecx, DWORD PTR tv156[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR tv156[ebp]
	mov	BYTE PTR [eax], dl
$LN12@Step:

; 48   : 			}
; 49   : 			break;
; 50   : 		case 1:
; 51   : 			
; 52   : 			break;
; 53   : 	}
; 54   : 
; 55   : 	
; 56   :   if (counter2 == 456) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv244[ebp], ecx
	mov	edx, DWORD PTR tv244[ebp]
	cmp	DWORD PTR [edx+48], 456			; 000001c8H
	jne	$LN3@Step
	mov	eax, DWORD PTR tv244[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	$LN3@Step

; 57   : 		if (ly == 153 && counter2 == 456) {

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 153				; 00000099H
	jne	SHORT $LN2@Step
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv250[ebp], eax
	mov	ecx, DWORD PTR tv250[ebp]
	cmp	DWORD PTR [ecx+48], 456			; 000001c8H
	jne	SHORT $LN2@Step
	mov	edx, DWORD PTR tv250[ebp]
	cmp	DWORD PTR [edx+52], 0
	jne	SHORT $LN2@Step

; 58   : 			emu_->on_render();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()

; 59   : 			stat_.mode = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+13]
	and	dl, 252					; 000000fcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+13], dl

; 60   : 			ly = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+16], 0

; 61   : 			counter1 = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0
	mov	DWORD PTR [edx+44], 0

; 62   : 			counter2 = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+52], 0

; 63   : 		} else

	jmp	SHORT $LN1@Step
$LN2@Step:

; 64   : 			++ly;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+16]
	add	dl, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+16], dl
$LN1@Step:

; 65   : 		counter2 = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
$LN3@Step:

; 66   : 	}
; 67   : 
; 68   :   ++counter2; //line clock

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	add	eax, 1
	mov	ecx, DWORD PTR [edx+52]
	adc	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], eax
	mov	DWORD PTR [edx+52], ecx

; 69   :   ++counter1;//screen clock

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	add	ecx, 1
	mov	edx, DWORD PTR [eax+44]
	adc	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], edx

; 70   : 
; 71   : 	/*hsync += dt;
; 72   :   if (hsync >= 0.10871928680147858230050010871929) {
; 73   :     hsync = 0;
; 74   :   }
; 75   : 
; 76   :   vsync += dt;
; 77   :   if (vsync >= 16.742005692281935375858027791729) {
; 78   : 
; 79   : 		
; 80   :     vsync = 0;
; 81   :     
; 82   : 		
; 83   :   }*/
; 84   : }

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Step@LCDDriver@gb@emulation@@QAEXN@Z ENDP		; emulation::gb::LCDDriver::Step
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
_ioports$ = -8						; size = 4
_this$ = -4						; size = 4
?Deinitialize@LCDDriver@gb@emulation@@UAEXXZ PROC	; emulation::gb::LCDDriver::Deinitialize
; _this$ = ecx

; 23   : void LCDDriver::Deinitialize() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 24   :   auto ioports = emu_->memory()->ioports();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?ioports@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::ioports
	mov	DWORD PTR _ioports$[ebp], eax

; 25   :   delete [] frame_buffer;  

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 26   : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Deinitialize@LCDDriver@gb@emulation@@UAEXXZ ENDP	; emulation::gb::LCDDriver::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_emu$ = 8						; size = 4
?Initialize@LCDDriver@gb@emulation@@UAEXPAVEmu@23@@Z PROC ; emulation::gb::LCDDriver::Initialize
; _this$ = ecx

; 9    : void LCDDriver::Initialize(Emu* emu) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 10   :   Component::Initialize(emu);

	mov	eax, DWORD PTR _emu$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ; emulation::gb::Component::Initialize

; 11   :   frame_buffer = new uint32_t[256*256];

	push	11					; 0000000bH
	push	OFFSET $SG130094
	push	1
	push	262144					; 00040000H
	call	??_U@YAPAXIHPBDH@Z			; operator new[]
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+8], edx

; 12   :   lcdc_.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+12], 0

; 13   :   stat_.raw = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+13], 0

; 14   :   ly = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+16], 0

; 15   :   lyc = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+17], 0

; 16   :   scroll_x = scroll_y = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+15], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+14], 0

; 17   :   wx = wy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+19], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+18], 0

; 18   :   counter1 = counter2 = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0
	mov	DWORD PTR [edx+52], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0

; 19   :   vsync = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [ecx+56], xmm0

; 20   :   hsync = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [edx+64], xmm0

; 21   : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Initialize@LCDDriver@gb@emulation@@UAEXPAVEmu@23@@Z ENDP ; emulation::gb::LCDDriver::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ PROC	; emulation::gb::Memory::interrupt_flag, COMDAT
; _this$ = ecx

; 20   :   uint8_t& interrupt_flag() {  return ioports_[0x0F]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	imul	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+184]
	mov	esp, ebp
	pop	ebp
	ret	0
?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ENDP	; emulation::gb::Memory::interrupt_flag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?ioports@Memory@gb@emulation@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ioports@Memory@gb@emulation@@QAEPAEXZ PROC		; emulation::gb::Memory::ioports, COMDAT
; _this$ = ecx

; 18   :   uint8_t* ioports() { return ioports_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 184				; 000000b8H
	mov	esp, ebp
	pop	ebp
	ret	0
?ioports@Memory@gb@emulation@@QAEPAEXZ ENDP		; emulation::gb::Memory::ioports
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?oam@Memory@gb@emulation@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?oam@Memory@gb@emulation@@QAEPAEXZ PROC			; emulation::gb::Memory::oam, COMDAT
; _this$ = ecx

; 17   :   uint8_t* oam() { return oam_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	esp, ebp
	pop	ebp
	ret	0
?oam@Memory@gb@emulation@@QAEPAEXZ ENDP			; emulation::gb::Memory::oam
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?vram@Memory@gb@emulation@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?vram@Memory@gb@emulation@@QAEPAEXZ PROC		; emulation::gb::Memory::vram, COMDAT
; _this$ = ecx

; 16   : 	uint8_t* vram() { return vram_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?vram@Memory@gb@emulation@@QAEPAEXZ ENDP		; emulation::gb::Memory::vram
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\gb.h
;	COMDAT ?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_emu$ = 8						; size = 4
?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z PROC ; emulation::gb::Component::Initialize, COMDAT
; _this$ = ecx

; 28   :   virtual void Initialize(Emu* emu) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 29   :     emu_ = emu;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _emu$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 30   :   }

	mov	esp, ebp
	pop	ebp
	ret	4
?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ENDP ; emulation::gb::Component::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 137  : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$yc	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 130  : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Ignore@std@@QAE@XZ PROC				; std::_Ignore::_Ignore, COMDAT
; _this$ = ecx

; 120  : 	_Ignore()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Ignore@std@@QAE@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
