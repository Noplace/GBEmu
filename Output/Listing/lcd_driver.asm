; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

	TITLE	C:\Users\Khalid\Documents\GitHub\GBEmu\Solution\Code\emulation\gb\lcd_driver.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?value@?$_Abs@$0GE@@std@@2_JB			; std::_Abs<100>::value
PUBLIC	?value@?$_Abs@$0DLJKMKAA@@std@@2_JB		; std::_Abs<1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?value@?$_GcdX@$0GE@$0A@@std@@2_JB		; std::_GcdX<100,0>::value
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB	; std::_GcdX<1000000000,100>::value
PUBLIC	?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
PUBLIC	?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
PUBLIC	?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<100,1000000000>::value
PUBLIC	?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
PUBLIC	?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
PUBLIC	?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<100,1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$_Abs@$00@std@@2_JB			; std::_Abs<1>::value
PUBLIC	?value@?$_GcdX@$00$0A@@std@@2_JB		; std::_GcdX<1,0>::value
PUBLIC	?value@?$_GcdX@$00$00@std@@2_JB			; std::_GcdX<1,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?value@?$_Gcd@$00$00@std@@2_JB			; std::_Gcd<1,1>::value
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_monotonic@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_monotonic
PUBLIC	?is_steady@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_steady
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?value@?$integral_constant@H$0A@@std@@2HB	; std::integral_constant<int,0>::value
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
PUBLIC	?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
PUBLIC	?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_nonNull
PUBLIC	?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelException
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_notInlined
PUBLIC	?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_structured
PUBLIC	?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_localCancel
PUBLIC	?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_reserved
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB		; std::_GcdX<10000000,1>::value
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB		; std::_GcdX<1,10000000>::value
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB		; std::_Gcd<1,10000000>::value
PUBLIC	?num@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::num
PUBLIC	?den@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::den
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
PUBLIC	?value@?$_Abs@$0JIJGIA@@std@@2_JB		; std::_Abs<10000000>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB		; std::_GcdX<10000000,0>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_GcdX<10000000,10000000>::value
PUBLIC	?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Gcd<10000000,10000000>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?num@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::num
PUBLIC	?den@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::den
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?is_monotonic@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_monotonic
PUBLIC	?is_steady@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_steady
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	_ConcRT_ProviderGuid
PUBLIC	_ConcRTEventGuid
PUBLIC	_SchedulerEventGuid
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	_ScheduleGroupEventGuid
PUBLIC	_ContextEventGuid
PUBLIC	_ChoreEventGuid
PUBLIC	_VirtualProcessorEventGuid
PUBLIC	_LockEventGuid
PUBLIC	_ResourceManagerEventGuid
PUBLIC	_PPLParallelInvokeEventGuid
PUBLIC	_PPLParallelForEventGuid
PUBLIC	_PPLParallelForeachEventGuid
PUBLIC	_AgentEventGuid
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT _AgentEventGuid
CONST	SEGMENT
_AgentEventGuid DD 0b9b5b78cH
	DW	0713H
	DW	04898H
	DB	0a2H
	DB	01aH
	DB	0c6H
	DB	079H
	DB	049H
	DB	0dcH
	DB	0edH
	DB	07H
CONST	ENDS
;	COMDAT _PPLParallelForeachEventGuid
CONST	SEGMENT
_PPLParallelForeachEventGuid DD 05cb7d785H
	DW	09d66H
	DW	0465dH
	DB	0baH
	DB	0e1H
	DB	046H
	DB	011H
	DB	06H
	DB	01bH
	DB	054H
	DB	034H
CONST	ENDS
;	COMDAT _PPLParallelForEventGuid
CONST	SEGMENT
_PPLParallelForEventGuid DD 031c8da6bH
	DW	06165H
	DW	04042H
	DB	08bH
	DB	092H
	DB	094H
	DB	09eH
	DB	031H
	DB	05fH
	DB	04dH
	DB	084H
CONST	ENDS
;	COMDAT _PPLParallelInvokeEventGuid
CONST	SEGMENT
_PPLParallelInvokeEventGuid DD 0d1b5b133H
	DW	0ec3dH
	DW	049f4H
	DB	098H
	DB	0a3H
	DB	046H
	DB	04dH
	DB	01aH
	DB	09eH
	DB	046H
	DB	082H
CONST	ENDS
;	COMDAT _ResourceManagerEventGuid
CONST	SEGMENT
_ResourceManagerEventGuid DD 02718d25bH
	DW	05bf5H
	DW	04479H
	DB	08eH
	DB	088H
	DB	0baH
	DB	0bcH
	DB	064H
	DB	0bdH
	DB	0bfH
	DB	0caH
CONST	ENDS
;	COMDAT _LockEventGuid
CONST	SEGMENT
_LockEventGuid DD 079a60dc6H
	DW	05fc8H
	DW	04952H
	DB	0a4H
	DB	01cH
	DB	011H
	DB	063H
	DB	0aeH
	DB	0ecH
	DB	05eH
	DB	0b8H
CONST	ENDS
;	COMDAT _VirtualProcessorEventGuid
CONST	SEGMENT
_VirtualProcessorEventGuid DD 02f27805fH
	DW	01676H
	DW	04eccH
	DB	096H
	DB	0faH
	DB	07eH
	DB	0b0H
	DB	09dH
	DB	044H
	DB	030H
	DB	02fH
CONST	ENDS
;	COMDAT _ChoreEventGuid
CONST	SEGMENT
_ChoreEventGuid DD 07e854ec7H
	DW	0cdc4H
	DW	0405aH
	DB	0b5H
	DB	0b2H
	DB	0aaH
	DB	0f7H
	DB	0c9H
	DB	0e7H
	DB	0d4H
	DB	0cH
CONST	ENDS
;	COMDAT _ContextEventGuid
CONST	SEGMENT
_ContextEventGuid DD 05727a00fH
	DW	050beH
	DW	04519H
	DB	082H
	DB	056H
	DB	0f7H
	DB	069H
	DB	098H
	DB	071H
	DB	0feH
	DB	0cbH
CONST	ENDS
;	COMDAT _ScheduleGroupEventGuid
CONST	SEGMENT
_ScheduleGroupEventGuid DD 0e8a3bf1fH
	DW	0a86bH
	DW	04390H
	DB	09cH
	DB	060H
	DB	053H
	DB	090H
	DB	0b9H
	DB	069H
	DB	0d2H
	DB	02cH
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT _SchedulerEventGuid
CONST	SEGMENT
_SchedulerEventGuid DD 0e2091f8aH
	DW	01e0aH
	DW	04731H
	DB	084H
	DB	0a2H
	DB	0dH
	DB	0d5H
	DB	07cH
	DB	08aH
	DB	052H
	DB	061H
CONST	ENDS
;	COMDAT _ConcRTEventGuid
CONST	SEGMENT
_ConcRTEventGuid DD 072b14a7dH
	DW	0704cH
	DW	0423eH
	DB	092H
	DB	0f8H
	DB	07eH
	DB	06dH
	DB	064H
	DB	0bcH
	DB	0b9H
	DB	02aH
CONST	ENDS
;	COMDAT _ConcRT_ProviderGuid
CONST	SEGMENT
_ConcRT_ProviderGuid DD 0f7b697a3H
	DW	04db5H
	DW	04d3bH
	DB	0beH
	DB	071H
	DB	0c4H
	DB	0d2H
	DB	084H
	DB	0e6H
	DB	059H
	DB	02fH
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?is_steady@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@steady_clock@chrono@std@@2_NB DB 01H		; std::chrono::steady_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@steady_clock@chrono@std@@2_NB DB 01H	; std::chrono::steady_clock::is_monotonic
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::num
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0JIJGIA@@std@@2_JB DQ 0000000000989680H	; std::_Abs<10000000>::value
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::ratio<1,10000000>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,10000000>::num
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,10000000>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000000>::value
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000000,1>::value
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_reserved
CONST	ENDS
;	COMDAT ?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_localCancel
CONST	ENDS
;	COMDAT ?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_structured
CONST	ENDS
;	COMDAT ?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB DD 0ffffffffH ; Concurrency::details::_TaskCollectionBase::_S_notInlined
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_cancelException
CONST	ENDS
;	COMDAT ?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB DD 08H ; Concurrency::details::_TaskCollectionBase::_S_nonNull
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
CONST	ENDS
;	COMDAT ?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
CONST	ENDS
;	COMDAT ?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB DD 00H ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@H$0A@@std@@2HB
CONST	SEGMENT
?value@?$integral_constant@H$0A@@std@@2HB DD 00H	; std::integral_constant<int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?is_steady@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@system_clock@chrono@std@@2_NB DB 00H		; std::chrono::system_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@system_clock@chrono@std@@2_NB DB 00H	; std::chrono::system_clock::is_monotonic
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0A@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$00@std@@2_JB DQ 0000000000000001H	; std::_Abs<1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_Gcd<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB DD 03H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
CONST	ENDS
;	COMDAT ?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 02H ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 01H ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
CONST	ENDS
;	COMDAT ?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB DD 00H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<1000000000,100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0A@@std@@2_JB DQ 0000000000000064H	; std::_GcdX<100,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Abs<1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0GE@@std@@2_JB DQ 0000000000000064H	; std::_Abs<100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
CONST	SEGMENT
_pal32	DD	0ffffffffH
	DD	0ffaaaaaaH
	DD	0ff545454H
	DD	0ff000000H
$SG153652 DB	'Code\emulation\gb\lcd_driver.cpp', 00H
	ORG $+3
$SG153655 DB	'Code\emulation\gb\lcd_driver.cpp', 00H
	ORG $+3
_dutycycletable DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
PUBLIC	??0_Ignore@std@@QAE@XZ				; std::_Ignore::_Ignore
PUBLIC	?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ; emulation::gb::Component::Initialize
PUBLIC	?vram@Memory@gb@emulation@@QAEPAEXZ		; emulation::gb::Memory::vram
PUBLIC	?oam@Memory@gb@emulation@@QAEPAEXZ		; emulation::gb::Memory::oam
PUBLIC	?ioports@Memory@gb@emulation@@QAEPAEXZ		; emulation::gb::Memory::ioports
PUBLIC	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ	; emulation::gb::Memory::interrupt_flag
PUBLIC	?Initialize@LCDDriver@gb@emulation@@UAEXPAVEmu@23@@Z ; emulation::gb::LCDDriver::Initialize
PUBLIC	?Deinitialize@LCDDriver@gb@emulation@@UAEXXZ	; emulation::gb::LCDDriver::Deinitialize
PUBLIC	?Step@LCDDriver@gb@emulation@@QAEXN@Z		; emulation::gb::LCDDriver::Step
PUBLIC	?Read@LCDDriver@gb@emulation@@QAEEG@Z		; emulation::gb::LCDDriver::Read
PUBLIC	?Write@LCDDriver@gb@emulation@@QAEXGE@Z		; emulation::gb::LCDDriver::Write
PUBLIC	?RenderBGLine@LCDDriver@gb@emulation@@QAEXXZ	; emulation::gb::LCDDriver::RenderBGLine
PUBLIC	?RenderWindowLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderWindowLine
PUBLIC	?RenderSpriteLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderSpriteLine
PUBLIC	?RenderLine@LCDDriver@gb@emulation@@QAEXXZ	; emulation::gb::LCDDriver::RenderLine
PUBLIC	?RenderAllBGTiles@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderAllBGTiles
PUBLIC	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ	; emulation::gb::Emu::memory
PUBLIC	??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
PUBLIC	__real@0000000000000000
EXTRN	__imp__rand:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXIHPBDH@Z:PROC				; operator new[]
EXTRN	__imp_?_Xbad_function_call@std@@YAXXZ:PROC
EXTRN	?Read8@Memory@gb@emulation@@QAEEG@Z:PROC	; emulation::gb::Memory::Read8
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_ignore	DB	01H DUP (?)
__Tuple_alloc DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??R<lambda_d876a496851e5bf936ee13891bce77b7>@@QBEXXZ PROC ; <lambda_d876a496851e5bf936ee13891bce77b7>::operator()
; _this$ = ecx

; 280  :     auto incx = [&x,&lineoffset](){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 281  : 			  ++x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 282  : 			  if (x==8) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax], 8
	jne	SHORT $LN2@operator

; 283  : 				  x = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], 0

; 284  : 				  lineoffset = (lineoffset+1)&0x1F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], edx
$LN2@operator:

; 285  :         }
; 286  :     };

	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_d876a496851e5bf936ee13891bce77b7>@@QBEXXZ ENDP ; <lambda_d876a496851e5bf936ee13891bce77b7>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__X$ = 8						; size = 4
__Lineoffset$ = 12					; size = 4
??0<lambda_d876a496851e5bf936ee13891bce77b7>@@QAE@AAH0@Z PROC ; <lambda_d876a496851e5bf936ee13891bce77b7>::<lambda_d876a496851e5bf936ee13891bce77b7>
; _this$ = ecx

; 286  :     };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Lineoffset$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0<lambda_d876a496851e5bf936ee13891bce77b7>@@QAE@AAH0@Z ENDP ; <lambda_d876a496851e5bf936ee13891bce77b7>::<lambda_d876a496851e5bf936ee13891bce77b7>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv82 = -16						; size = 4
_d$1 = -10						; size = 1
_tileindex$ = -9					; size = 1
_bgtilemap$ = -8					; size = 4
_this$ = -4						; size = 4
??R<lambda_e951570ade190f663a6caa89ada630c3>@@QBEEXZ PROC ; <lambda_e951570ade190f663a6caa89ada630c3>::operator()
; _this$ = ecx

; 269  : 	  auto readTile = [&](){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 270  :         uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.window_tile_map ==0?0x1800:0x1C00];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx+20]
	shr	dl, 6
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN4@operator
	mov	DWORD PTR tv82[ebp], 6144		; 00001800H
	jmp	SHORT $LN5@operator
$LN4@operator:
	mov	DWORD PTR tv82[ebp], 7168		; 00001c00H
$LN5@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR _bgtilemap$[ebp], eax

; 271  : 			  auto tileindex = bgtilemap[(mapoffset<<5) + lineoffset];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _bgtilemap$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR _tileindex$[ebp], cl

; 272  : 			  if(lcdc_.tile_data == 0) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cl, BYTE PTR [eax+20]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN1@operator

; 273  : 				  int8_t d = tileindex;

	mov	al, BYTE PTR _tileindex$[ebp]
	mov	BYTE PTR _d$1[ebp], al

; 274  : 				  d+=128;

	movsx	ecx, BYTE PTR _d$1[ebp]
	add	ecx, 128				; 00000080H
	mov	BYTE PTR _d$1[ebp], cl

; 275  : 				  tileindex = d;

	mov	dl, BYTE PTR _d$1[ebp]
	mov	BYTE PTR _tileindex$[ebp], dl
$LN1@operator:

; 276  : 			  }
; 277  : 			  return tileindex;

	mov	al, BYTE PTR _tileindex$[ebp]

; 278  : 	  };

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_e951570ade190f663a6caa89ada630c3>@@QBEEXZ ENDP ; <lambda_e951570ade190f663a6caa89ada630c3>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This$ = 8						; size = 4
__Mapoffset$ = 12					; size = 4
__Lineoffset$ = 16					; size = 4
??0<lambda_e951570ade190f663a6caa89ada630c3>@@QAE@PAVLCDDriver@gb@emulation@@AAH1@Z PROC ; <lambda_e951570ade190f663a6caa89ada630c3>::<lambda_e951570ade190f663a6caa89ada630c3>
; _this$ = ecx

; 278  : 	  };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __This$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Mapoffset$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Lineoffset$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0<lambda_e951570ade190f663a6caa89ada630c3>@@QAE@PAVLCDDriver@gb@emulation@@AAH1@Z ENDP ; <lambda_e951570ade190f663a6caa89ada630c3>::<lambda_e951570ade190f663a6caa89ada630c3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??R<lambda_9915241f12bdba8023c4d69393c1c5d7>@@QBEXXZ PROC ; <lambda_9915241f12bdba8023c4d69393c1c5d7>::operator()
; _this$ = ecx

; 238  :   auto incx = [&x,&lineoffset](){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 			++x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 240  : 			if (x==8) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax], 8
	jne	SHORT $LN2@operator

; 241  : 				x = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], 0

; 242  : 				lineoffset = (lineoffset+1)&0x1F;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], edx
$LN2@operator:

; 243  :       }
; 244  :   };

	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_9915241f12bdba8023c4d69393c1c5d7>@@QBEXXZ ENDP ; <lambda_9915241f12bdba8023c4d69393c1c5d7>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__X$ = 8						; size = 4
__Lineoffset$ = 12					; size = 4
??0<lambda_9915241f12bdba8023c4d69393c1c5d7>@@QAE@AAH0@Z PROC ; <lambda_9915241f12bdba8023c4d69393c1c5d7>::<lambda_9915241f12bdba8023c4d69393c1c5d7>
; _this$ = ecx

; 244  :   };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Lineoffset$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0<lambda_9915241f12bdba8023c4d69393c1c5d7>@@QAE@AAH0@Z ENDP ; <lambda_9915241f12bdba8023c4d69393c1c5d7>::<lambda_9915241f12bdba8023c4d69393c1c5d7>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv82 = -16						; size = 4
_d$1 = -10						; size = 1
_tileindex$ = -9					; size = 1
_bgtilemap$ = -8					; size = 4
_this$ = -4						; size = 4
??R<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QBEEXZ PROC ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::operator()
; _this$ = ecx

; 227  : 	auto readTile = [&](){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 228  : 		  uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx+20]
	shr	dl, 3
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN4@operator
	mov	DWORD PTR tv82[ebp], 6144		; 00001800H
	jmp	SHORT $LN5@operator
$LN4@operator:
	mov	DWORD PTR tv82[ebp], 7168		; 00001c00H
$LN5@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR _bgtilemap$[ebp], eax

; 229  : 			auto tileindex = bgtilemap[(mapoffset<<5) + lineoffset];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _bgtilemap$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR _tileindex$[ebp], cl

; 230  : 			if(lcdc_.tile_data == 0) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cl, BYTE PTR [eax+20]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN1@operator

; 231  : 				int8_t d = tileindex;

	mov	al, BYTE PTR _tileindex$[ebp]
	mov	BYTE PTR _d$1[ebp], al

; 232  : 				d+=128;

	movsx	ecx, BYTE PTR _d$1[ebp]
	add	ecx, 128				; 00000080H
	mov	BYTE PTR _d$1[ebp], cl

; 233  : 				tileindex = d;

	mov	dl, BYTE PTR _d$1[ebp]
	mov	BYTE PTR _tileindex$[ebp], dl
$LN1@operator:

; 234  : 			}
; 235  : 			return tileindex;

	mov	al, BYTE PTR _tileindex$[ebp]

; 236  : 	};

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QBEEXZ ENDP ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This$ = 8						; size = 4
__Mapoffset$ = 12					; size = 4
__Lineoffset$ = 16					; size = 4
??0<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QAE@PAVLCDDriver@gb@emulation@@AAH1@Z PROC ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::<lambda_97bc8e9b09435192667e87dfa941ef5a>
; _this$ = ecx

; 236  : 	};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __This$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Mapoffset$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Lineoffset$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QAE@PAVLCDDriver@gb@emulation@@AAH1@Z ENDP ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::<lambda_97bc8e9b09435192667e87dfa941ef5a>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv82 = -16						; size = 4
_d$1 = -10						; size = 1
_tileindex$ = -9					; size = 1
_bgtilemap$ = -8					; size = 4
_this$ = -4						; size = 4
??R<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QBEEXZ PROC ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::operator()
; _this$ = ecx

; 191  : 	auto readTile = [&](){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 192  : 		  uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx+20]
	shr	dl, 3
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN4@operator
	mov	DWORD PTR tv82[ebp], 6144		; 00001800H
	jmp	SHORT $LN5@operator
$LN4@operator:
	mov	DWORD PTR tv82[ebp], 7168		; 00001c00H
$LN5@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR _bgtilemap$[ebp], eax

; 193  : 			auto tileindex = bgtilemap[(mapoffset<<5)];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 5
	mov	eax, DWORD PTR _bgtilemap$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR _tileindex$[ebp], cl

; 194  : 			if(lcdc_.tile_data == 0) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cl, BYTE PTR [eax+20]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN1@operator

; 195  : 				int8_t d = tileindex;

	mov	al, BYTE PTR _tileindex$[ebp]
	mov	BYTE PTR _d$1[ebp], al

; 196  : 				d+=128;

	movsx	ecx, BYTE PTR _d$1[ebp]
	add	ecx, 128				; 00000080H
	mov	BYTE PTR _d$1[ebp], cl

; 197  : 				tileindex = d;

	mov	dl, BYTE PTR _d$1[ebp]
	mov	BYTE PTR _tileindex$[ebp], dl
$LN1@operator:

; 198  : 			}
; 199  : 			return tileindex;

	mov	al, BYTE PTR _tileindex$[ebp]

; 200  : 	};

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QBEEXZ ENDP ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This$ = 8						; size = 4
__Mapoffset$ = 12					; size = 4
??0<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QAE@PAVLCDDriver@gb@emulation@@AAH@Z PROC ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>
; _this$ = ecx

; 200  : 	};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __This$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Mapoffset$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QAE@PAVLCDDriver@gb@emulation@@AAH@Z ENDP ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ PROC ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator(), COMDAT
; _this$ = ecx

; 514  : _VARIADIC_EXPAND_P1_0(_CLASS_FUNC_CLASS_0, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN1@operator
	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_function_call@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator:
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ ENDP ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\emu.h
;	COMDAT ?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ PROC	; emulation::gb::Emu::memory, COMDAT
; _this$ = ecx

; 21   :   Memory* memory() { return &memory_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1160				; 00000488H
	mov	esp, ebp
	pop	ebp
	ret	0
?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ENDP	; emulation::gb::Emu::memory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv137 = -64						; size = 4
_tile$1 = -60						; size = 4
_tileindex$2 = -56					; size = 4
_i$3 = -52						; size = 4
_tiledata$4 = -48					; size = 4
_i$5 = -44						; size = 4
_readTile$ = -36					; size = 8
_x$ = -24						; size = 4
_y$ = -20						; size = 4
_mapoffset$ = -12					; size = 4
_this$ = -4						; size = 4
?RenderAllBGTiles@LCDDriver@gb@emulation@@QAEXXZ PROC	; emulation::gb::LCDDriver::RenderAllBGTiles
; _this$ = ecx

; 187  : void LCDDriver::RenderAllBGTiles() {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 188  : 	auto mapoffset = ((ly)&0xFF) >> 3;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	and	ecx, 255				; 000000ffH
	sar	ecx, 3
	mov	DWORD PTR _mapoffset$[ebp], ecx

; 189  : 	auto y = (ly) & 7;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+24]
	and	eax, 7
	mov	DWORD PTR _y$[ebp], eax

; 190  : 	auto x = 0;

	mov	DWORD PTR _x$[ebp], 0

; 191  : 	auto readTile = [&](){
; 192  : 		  uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];
; 193  : 			auto tileindex = bgtilemap[(mapoffset<<5)];
; 194  : 			if(lcdc_.tile_data == 0) {
; 195  : 				int8_t d = tileindex;
; 196  : 				d+=128;
; 197  : 				tileindex = d;
; 198  : 			}
; 199  : 			return tileindex;
; 200  : 	};

	lea	ecx, DWORD PTR _mapoffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	ecx, DWORD PTR _readTile$[ebp]
	call	??0<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>@@QAE@PAVLCDDriver@gb@emulation@@AAH@Z ; <lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>::<lambda_ce7ad4cd1412fe00586b4ffb596c5c8d>

; 201  : 
; 202  : 	if (lcdc_.bgdisplay == 0) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+20]
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN9@RenderAllB

; 203  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN8@RenderAllB
$LN7@RenderAllB:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN8@RenderAllB:
	cmp	DWORD PTR _i$5[ebp], 256		; 00000100H
	jge	SHORT $LN6@RenderAllB

; 204  : 			colormap[((ly)<<8)+(i)] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+24]
	shl	edx, 8
	add	edx, DWORD PTR _i$5[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	BYTE PTR [ecx+edx], 0

; 205  : 		}

	jmp	SHORT $LN7@RenderAllB
$LN6@RenderAllB:
	jmp	$LN10@RenderAllB
$LN9@RenderAllB:

; 206  : 	} else {
; 207  : 		uint8_t* tiledata = &emu_->memory()->vram()[lcdc_.tile_data ==0?0x0800:0x0000];

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+20]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN12@RenderAllB
	mov	DWORD PTR tv137[ebp], 2048		; 00000800H
	jmp	SHORT $LN13@RenderAllB
$LN12@RenderAllB:
	mov	DWORD PTR tv137[ebp], 0
$LN13@RenderAllB:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv137[ebp]
	mov	DWORD PTR _tiledata$4[ebp], eax

; 208  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@RenderAllB
$LN3@RenderAllB:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@RenderAllB:
	cmp	DWORD PTR _i$3[ebp], 256		; 00000100H
	jge	$LN10@RenderAllB

; 209  : 			auto tileindex = (i>>3)+(ly>>3)*32;

	mov	ecx, DWORD PTR _i$3[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+24]
	sar	eax, 3
	shl	eax, 5
	add	ecx, eax
	mov	DWORD PTR _tileindex$2[ebp], ecx

; 210  : 			uint8_t* tile = &tiledata[(tileindex<<4)];

	mov	ecx, DWORD PTR _tileindex$2[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _tiledata$4[ebp]
	mov	DWORD PTR _tile$1[ebp], ecx

; 211  : 			
; 212  : 			colormap[((ly)<<8)+i] = bg_pal[pixel((7-x))];

	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR _tile$1[ebp]
	movzx	edx, BYTE PTR [eax+edx*2]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$[ebp]
	and	ecx, 7
	sar	edx, cl
	and	edx, 1
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _tile$1[ebp]
	movzx	eax, BYTE PTR [ecx+eax*2+1]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$[ebp]
	and	ecx, 7
	sar	eax, cl
	shl	eax, 1
	and	eax, 2
	add	edx, eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [ecx+24]
	shl	eax, 8
	add	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	mov	esi, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [esi+edx+28]
	mov	BYTE PTR [ecx+eax], dl

; 213  : 
; 214  : 			++x;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax

; 215  : 			if (x==8) {

	cmp	DWORD PTR _x$[ebp], 8
	jne	SHORT $LN1@RenderAllB

; 216  : 				x = 0;

	mov	DWORD PTR _x$[ebp], 0
$LN1@RenderAllB:

; 217  : 			}
; 218  : 		}

	jmp	$LN3@RenderAllB
$LN10@RenderAllB:

; 219  : 	}
; 220  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@RenderAllB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@RenderAllB:
	DD	2
	DD	$LN16@RenderAllB
$LN16@RenderAllB:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN14@RenderAllB
	DD	-36					; ffffffdcH
	DD	8
	DD	$LN15@RenderAllB
$LN15@RenderAllB:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$LN14@RenderAllB:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?RenderAllBGTiles@LCDDriver@gb@emulation@@QAEXXZ ENDP	; emulation::gb::LCDDriver::RenderAllBGTiles
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RenderLine@LCDDriver@gb@emulation@@QAEXXZ PROC		; emulation::gb::LCDDriver::RenderLine
; _this$ = ecx

; 361  : void LCDDriver::RenderLine() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 362  :   //RenderAllBGTiles();
; 363  : 	RenderBGLine();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenderBGLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderBGLine

; 364  : 	RenderWindowLine();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenderWindowLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderWindowLine

; 365  : 	RenderSpriteLine();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenderSpriteLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderSpriteLine

; 366  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderLine@LCDDriver@gb@emulation@@QAEXXZ ENDP		; emulation::gb::LCDDriver::RenderLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv188 = -48						; size = 4
_p$1 = -41						; size = 1
_x$2 = -40						; size = 4
_pal$3 = -36						; size = 4
_y$4 = -29						; size = 1
_tile$5 = -28						; size = 4
_spritex$6 = -22					; size = 1
_spritey$7 = -21					; size = 1
_j$8 = -20						; size = 4
_sprites$9 = -16					; size = 4
_tiledata$10 = -12					; size = 4
_sprite_count$ = -5					; size = 1
_this$ = -4						; size = 4
?RenderSpriteLine@LCDDriver@gb@emulation@@QAEXXZ PROC	; emulation::gb::LCDDriver::RenderSpriteLine
; _this$ = ecx

; 301  : void LCDDriver::RenderSpriteLine() {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 302  :   uint8_t sprite_count = 10;

	mov	BYTE PTR _sprite_count$[ebp], 10	; 0000000aH

; 303  :   struct Sprite{
; 304  :     uint8_t y,x,tileindex;
; 305  : 
; 306  :     union {
; 307  :       struct {
; 308  :         uint8_t unused:4;
; 309  :         uint8_t pal:1;
; 310  :         uint8_t xflip:1;
; 311  :         uint8_t yflip:1;
; 312  :         uint8_t priority:1;
; 313  :         /* Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
; 314  :          (Used for both BG and Window. BG color 0 is always behind OBJ)
; 315  :   Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
; 316  :   Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
; 317  :   Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
; 318  :   Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
; 319  :   Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)
; 320  : */
; 321  :       };
; 322  :       uint8_t raw;
; 323  :     }attr;
; 324  : 
; 325  :   } ;
; 326  : 	if (lcdc_.sprite_enable == 1) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+20]
	shr	cl, 1
	and	cl, 1
	movzx	edx, cl
	cmp	edx, 1
	jne	$LN15@RenderSpri

; 327  : 		uint8_t* tiledata = &emu_->memory()->vram()[0x0000];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	mov	ecx, 1
	imul	ecx, 0
	add	eax, ecx
	mov	DWORD PTR _tiledata$10[ebp], eax

; 328  :     Sprite* sprites = (Sprite*)emu_->memory()->oam();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?oam@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::oam
	mov	DWORD PTR _sprites$9[ebp], eax

; 329  : 
; 330  :     for (int j=0;j<40;++j) {

	mov	DWORD PTR _j$8[ebp], 0
	jmp	SHORT $LN13@RenderSpri
$LN12@RenderSpri:
	mov	eax, DWORD PTR _j$8[ebp]
	add	eax, 1
	mov	DWORD PTR _j$8[ebp], eax
$LN13@RenderSpri:
	cmp	DWORD PTR _j$8[ebp], 40			; 00000028H
	jge	$LN15@RenderSpri

; 331  :        uint8_t spritey = sprites[j].y-16;

	mov	ecx, DWORD PTR _j$8[ebp]
	mov	edx, DWORD PTR _sprites$9[ebp]
	movzx	eax, BYTE PTR [edx+ecx*4]
	sub	eax, 16					; 00000010H
	mov	BYTE PTR _spritey$7[ebp], al

; 332  :        uint8_t spritex = sprites[j].x-8;

	mov	ecx, DWORD PTR _j$8[ebp]
	mov	edx, DWORD PTR _sprites$9[ebp]
	movzx	eax, BYTE PTR [edx+ecx*4+1]
	sub	eax, 8
	mov	BYTE PTR _spritex$6[ebp], al

; 333  :        if ( ly >= (spritey) && ly < (spritey+(8<<lcdc_.sprite_size))) { //same line

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+24]
	movzx	eax, BYTE PTR _spritey$7[ebp]
	cmp	edx, eax
	jl	$LN10@RenderSpri
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+24]
	movzx	eax, BYTE PTR _spritey$7[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [ecx+20]
	shr	cl, 2
	and	cl, 1
	movzx	ecx, cl
	mov	esi, 8
	shl	esi, cl
	add	eax, esi
	cmp	edx, eax
	jge	$LN10@RenderSpri

; 334  :          if (lcdc_.sprite_size)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+20]
	shr	al, 2
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@RenderSpri

; 335  :            sprites[j].tileindex &= ~0x01;

	mov	edx, DWORD PTR _j$8[ebp]
	mov	eax, DWORD PTR _sprites$9[ebp]
	movzx	ecx, BYTE PTR [eax+edx*4+2]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _j$8[ebp]
	mov	eax, DWORD PTR _sprites$9[ebp]
	mov	BYTE PTR [eax+edx*4+2], cl
$LN9@RenderSpri:

; 336  :           uint8_t* tile = &tiledata[(sprites[j].tileindex<<4)];

	mov	ecx, DWORD PTR _j$8[ebp]
	mov	edx, DWORD PTR _sprites$9[ebp]
	movzx	eax, BYTE PTR [edx+ecx*4+2]
	shl	eax, 4
	add	eax, DWORD PTR _tiledata$10[ebp]
	mov	DWORD PTR _tile$5[ebp], eax

; 337  :           uint8_t y = ly-spritey;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+24]
	movzx	eax, BYTE PTR _spritey$7[ebp]
	sub	edx, eax
	mov	BYTE PTR _y$4[ebp], dl

; 338  :           uint8_t* pal = sprites[j].attr.pal == 0?obj_pal1:obj_pal2;

	mov	ecx, DWORD PTR _j$8[ebp]
	mov	edx, DWORD PTR _sprites$9[ebp]
	mov	al, BYTE PTR [edx+ecx*4+3]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN17@RenderSpri
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR tv188[ebp], edx
	jmp	SHORT $LN18@RenderSpri
$LN17@RenderSpri:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR tv188[ebp], eax
$LN18@RenderSpri:
	mov	ecx, DWORD PTR tv188[ebp]
	mov	DWORD PTR _pal$3[ebp], ecx

; 339  :           if (sprites[j].attr.yflip)

	mov	edx, DWORD PTR _j$8[ebp]
	mov	eax, DWORD PTR _sprites$9[ebp]
	mov	cl, BYTE PTR [eax+edx*4+3]
	shr	cl, 6
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN8@RenderSpri

; 340  :             y = ((8<<lcdc_.sprite_size)) - y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+20]
	shr	cl, 2
	and	cl, 1
	movzx	ecx, cl
	mov	edx, 8
	shl	edx, cl
	movzx	eax, BYTE PTR _y$4[ebp]
	sub	edx, eax
	mov	BYTE PTR _y$4[ebp], dl
$LN8@RenderSpri:

; 341  : 			     
; 342  : 			    for (int x=0;x<8;++x) {

	mov	DWORD PTR _x$2[ebp], 0
	jmp	SHORT $LN7@RenderSpri
$LN6@RenderSpri:
	mov	ecx, DWORD PTR _x$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$2[ebp], ecx
$LN7@RenderSpri:
	cmp	DWORD PTR _x$2[ebp], 8
	jge	$LN5@RenderSpri

; 343  :             uint8_t p = 0;

	mov	BYTE PTR _p$1[ebp], 0

; 344  :             if (sprites[j].attr.xflip) {

	mov	edx, DWORD PTR _j$8[ebp]
	mov	eax, DWORD PTR _sprites$9[ebp]
	mov	cl, BYTE PTR [eax+edx*4+3]
	shr	cl, 5
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@RenderSpri

; 345  :               p = pixel((x));

	movzx	eax, BYTE PTR _y$4[ebp]
	mov	ecx, DWORD PTR _tile$5[ebp]
	movzx	edx, BYTE PTR [ecx+eax*2]
	mov	ecx, DWORD PTR _x$2[ebp]
	and	ecx, 7
	sar	edx, cl
	and	edx, 1
	movzx	eax, BYTE PTR _y$4[ebp]
	mov	ecx, DWORD PTR _tile$5[ebp]
	movzx	eax, BYTE PTR [ecx+eax*2+1]
	mov	ecx, DWORD PTR _x$2[ebp]
	and	ecx, 7
	sar	eax, cl
	shl	eax, 1
	and	eax, 2
	add	edx, eax
	mov	BYTE PTR _p$1[ebp], dl

; 346  :             } else {

	jmp	SHORT $LN3@RenderSpri
$LN4@RenderSpri:

; 347  :               p = pixel((7-x));

	movzx	ecx, BYTE PTR _y$4[ebp]
	mov	edx, DWORD PTR _tile$5[ebp]
	movzx	eax, BYTE PTR [edx+ecx*2]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$2[ebp]
	and	ecx, 7
	sar	eax, cl
	and	eax, 1
	movzx	ecx, BYTE PTR _y$4[ebp]
	mov	edx, DWORD PTR _tile$5[ebp]
	movzx	edx, BYTE PTR [edx+ecx*2+1]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$2[ebp]
	and	ecx, 7
	sar	edx, cl
	shl	edx, 1
	and	edx, 2
	add	eax, edx
	mov	BYTE PTR _p$1[ebp], al
$LN3@RenderSpri:

; 348  :             }
; 349  :             
; 350  :             if ((p!=0)&&((sprites[j].attr.priority==0)||(colormap[((ly)<<8)+x+spritex] == bg_pal[0])))

	movzx	eax, BYTE PTR _p$1[ebp]
	test	eax, eax
	je	SHORT $LN2@RenderSpri
	mov	ecx, DWORD PTR _j$8[ebp]
	mov	edx, DWORD PTR _sprites$9[ebp]
	mov	al, BYTE PTR [edx+ecx*4+3]
	shr	al, 7
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@RenderSpri
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+24]
	shl	eax, 8
	add	eax, DWORD PTR _x$2[ebp]
	movzx	ecx, BYTE PTR _spritex$6[ebp]
	add	eax, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+28]
	cmp	edx, eax
	jne	SHORT $LN2@RenderSpri
$LN1@RenderSpri:

; 351  :               colormap[((ly)<<8)+x+spritex] = pal[p];

	movzx	ecx, BYTE PTR _p$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+24]
	shl	eax, 8
	add	eax, DWORD PTR _x$2[ebp]
	movzx	edx, BYTE PTR _spritex$6[ebp]
	add	eax, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	esi, DWORD PTR _pal$3[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl
$LN2@RenderSpri:

; 352  :           }

	jmp	$LN6@RenderSpri
$LN5@RenderSpri:

; 353  : 
; 354  : 			  --sprite_count;

	mov	dl, BYTE PTR _sprite_count$[ebp]
	sub	dl, 1
	mov	BYTE PTR _sprite_count$[ebp], dl
$LN10@RenderSpri:

; 355  :        }
; 356  :      }

	jmp	$LN12@RenderSpri
$LN15@RenderSpri:

; 357  : 
; 358  : 	}
; 359  : }

	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderSpriteLine@LCDDriver@gb@emulation@@QAEXXZ ENDP	; emulation::gb::LCDDriver::RenderSpriteLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv143 = -104						; size = 4
_bgcolor$1 = -97					; size = 1
_tile$2 = -96						; size = 4
_tileindex$3 = -89					; size = 1
_i$4 = -88						; size = 4
_tiledata$5 = -84					; size = 4
_incx$6 = -76						; size = 8
_readTile$7 = -60					; size = 12
_x$8 = -40						; size = 4
_y$9 = -32						; size = 4
_lineoffset$10 = -24					; size = 4
_mapoffset$11 = -12					; size = 4
_this$ = -4						; size = 4
?RenderWindowLine@LCDDriver@gb@emulation@@QAEXXZ PROC	; emulation::gb::LCDDriver::RenderWindowLine
; _this$ = ecx

; 262  : void LCDDriver::RenderWindowLine() {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-104]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 263  : 	if (lcdc_.window_enable == 1) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+20]
	shr	cl, 5
	and	cl, 1
	movzx	edx, cl
	cmp	edx, 1
	jne	$LN6@RenderWind

; 264  :     ;
; 265  :     auto mapoffset = ((ly+0)&0xFF) >> 3;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	and	ecx, 255				; 000000ffH
	sar	ecx, 3
	mov	DWORD PTR _mapoffset$11[ebp], ecx

; 266  : 	  auto lineoffset = ((0>>3))&0x1F;

	mov	DWORD PTR _lineoffset$10[ebp], 0

; 267  : 	  auto y = (ly + 0) & 7;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+24]
	and	eax, 7
	mov	DWORD PTR _y$9[ebp], eax

; 268  : 	  auto x = 0 & 7;

	mov	DWORD PTR _x$8[ebp], 0

; 269  : 	  auto readTile = [&](){
; 270  :         uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.window_tile_map ==0?0x1800:0x1C00];
; 271  : 			  auto tileindex = bgtilemap[(mapoffset<<5) + lineoffset];
; 272  : 			  if(lcdc_.tile_data == 0) {
; 273  : 				  int8_t d = tileindex;
; 274  : 				  d+=128;
; 275  : 				  tileindex = d;
; 276  : 			  }
; 277  : 			  return tileindex;
; 278  : 	  };

	lea	ecx, DWORD PTR _lineoffset$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _mapoffset$11[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _readTile$7[ebp]
	call	??0<lambda_e951570ade190f663a6caa89ada630c3>@@QAE@PAVLCDDriver@gb@emulation@@AAH1@Z ; <lambda_e951570ade190f663a6caa89ada630c3>::<lambda_e951570ade190f663a6caa89ada630c3>

; 279  : 
; 280  :     auto incx = [&x,&lineoffset](){
; 281  : 			  ++x;
; 282  : 			  if (x==8) {
; 283  : 				  x = 0;
; 284  : 				  lineoffset = (lineoffset+1)&0x1F;
; 285  :         }
; 286  :     };

	lea	ecx, DWORD PTR _lineoffset$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$8[ebp]
	push	edx
	lea	ecx, DWORD PTR _incx$6[ebp]
	call	??0<lambda_d876a496851e5bf936ee13891bce77b7>@@QAE@AAH0@Z ; <lambda_d876a496851e5bf936ee13891bce77b7>::<lambda_d876a496851e5bf936ee13891bce77b7>

; 287  : 
; 288  :     if ((ly >= wy)&&(wx>=7&&wx<=166)) { 

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+27]
	cmp	ecx, eax
	jl	$LN6@RenderWind
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+26]
	cmp	edx, 7
	jl	$LN6@RenderWind
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+26]
	cmp	ecx, 166				; 000000a6H
	jg	$LN6@RenderWind

; 289  : 		  uint8_t* tiledata = &emu_->memory()->vram()[lcdc_.tile_data ==0?0x0800:0x0000];

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+20]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@RenderWind
	mov	DWORD PTR tv143[ebp], 2048		; 00000800H
	jmp	SHORT $LN9@RenderWind
$LN8@RenderWind:
	mov	DWORD PTR tv143[ebp], 0
$LN9@RenderWind:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv143[ebp]
	mov	DWORD PTR _tiledata$5[ebp], eax

; 290  : 		  for (int i=(wx-7);i<=(wx-7)+166-7;++i) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+26]
	sub	ecx, 7
	mov	DWORD PTR _i$4[ebp], ecx
	jmp	SHORT $LN3@RenderWind
$LN2@RenderWind:
	mov	edx, DWORD PTR _i$4[ebp]
	add	edx, 1
	mov	DWORD PTR _i$4[ebp], edx
$LN3@RenderWind:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+26]
	add	ecx, 152				; 00000098H
	cmp	DWORD PTR _i$4[ebp], ecx
	jg	$LN6@RenderWind

; 291  : 			  auto tileindex = readTile();

	lea	ecx, DWORD PTR _readTile$7[ebp]
	call	??R<lambda_e951570ade190f663a6caa89ada630c3>@@QBEEXZ ; <lambda_e951570ade190f663a6caa89ada630c3>::operator()
	mov	BYTE PTR _tileindex$3[ebp], al

; 292  : 			  uint8_t* tile = &tiledata[(tileindex<<4)];

	movzx	edx, BYTE PTR _tileindex$3[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _tiledata$5[ebp]
	mov	DWORD PTR _tile$2[ebp], edx

; 293  :         uint8_t bgcolor = pixel((7-x));

	mov	eax, DWORD PTR _y$9[ebp]
	mov	ecx, DWORD PTR _tile$2[ebp]
	movzx	edx, BYTE PTR [ecx+eax*2]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$8[ebp]
	and	ecx, 7
	sar	edx, cl
	and	edx, 1
	mov	eax, DWORD PTR _y$9[ebp]
	mov	ecx, DWORD PTR _tile$2[ebp]
	movzx	eax, BYTE PTR [ecx+eax*2+1]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$8[ebp]
	and	ecx, 7
	sar	eax, cl
	shl	eax, 1
	and	eax, 2
	add	edx, eax
	mov	BYTE PTR _bgcolor$1[ebp], dl

; 294  :         incx();

	lea	ecx, DWORD PTR _incx$6[ebp]
	call	??R<lambda_d876a496851e5bf936ee13891bce77b7>@@QBEXXZ ; <lambda_d876a496851e5bf936ee13891bce77b7>::operator()

; 295  :         colormap[((ly)<<8)+i] = bg_pal[bgcolor];

	movzx	ecx, BYTE PTR _bgcolor$1[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+24]
	shl	eax, 8
	add	eax, DWORD PTR _i$4[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	esi, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [esi+ecx+28]
	mov	BYTE PTR [edx+eax], cl

; 296  : 		  }

	jmp	$LN2@RenderWind
$LN6@RenderWind:

; 297  :     }
; 298  : 	}
; 299  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@RenderWind
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 104				; 00000068H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN16@RenderWind:
	DD	5
	DD	$LN15@RenderWind
$LN15@RenderWind:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN10@RenderWind
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN11@RenderWind
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN12@RenderWind
	DD	-60					; ffffffc4H
	DD	12					; 0000000cH
	DD	$LN13@RenderWind
	DD	-76					; ffffffb4H
	DD	8
	DD	$LN14@RenderWind
$LN14@RenderWind:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	120					; 00000078H
	DB	0
$LN13@RenderWind:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$LN12@RenderWind:
	DB	120					; 00000078H
	DB	0
$LN11@RenderWind:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN10@RenderWind:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?RenderWindowLine@LCDDriver@gb@emulation@@QAEXXZ ENDP	; emulation::gb::LCDDriver::RenderWindowLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv154 = -108						; size = 4
_bgcolor$1 = -101					; size = 1
_tile$2 = -100						; size = 4
_tileindex$3 = -93					; size = 1
_i$4 = -92						; size = 4
_tiledata$5 = -88					; size = 4
_i$6 = -84						; size = 4
_incx$ = -76						; size = 8
_readTile$ = -60					; size = 12
_x$ = -40						; size = 4
_y$ = -32						; size = 4
_lineoffset$ = -24					; size = 4
_mapoffset$ = -12					; size = 4
_this$ = -4						; size = 4
?RenderBGLine@LCDDriver@gb@emulation@@QAEXXZ PROC	; emulation::gb::LCDDriver::RenderBGLine
; _this$ = ecx

; 222  : void LCDDriver::RenderBGLine() {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-108]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 223  : 	auto mapoffset = ((ly+scroll_y)&0xFF) >> 3;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+23]
	add	ecx, eax
	and	ecx, 255				; 000000ffH
	sar	ecx, 3
	mov	DWORD PTR _mapoffset$[ebp], ecx

; 224  : 	auto lineoffset = ((scroll_x>>3))&0x1F;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+22]
	sar	edx, 3
	and	edx, 31					; 0000001fH
	mov	DWORD PTR _lineoffset$[ebp], edx

; 225  : 	auto y = (ly + scroll_y) & 7;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+23]
	add	ecx, eax
	and	ecx, 7
	mov	DWORD PTR _y$[ebp], ecx

; 226  : 	auto x = scroll_x & 7;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+22]
	and	edx, 7
	mov	DWORD PTR _x$[ebp], edx

; 227  : 	auto readTile = [&](){
; 228  : 		  uint8_t* bgtilemap = &emu_->memory()->vram()[lcdc_.bg_tile_map ==0?0x1800:0x1C00];
; 229  : 			auto tileindex = bgtilemap[(mapoffset<<5) + lineoffset];
; 230  : 			if(lcdc_.tile_data == 0) {
; 231  : 				int8_t d = tileindex;
; 232  : 				d+=128;
; 233  : 				tileindex = d;
; 234  : 			}
; 235  : 			return tileindex;
; 236  : 	};

	lea	eax, DWORD PTR _lineoffset$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mapoffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	ecx, DWORD PTR _readTile$[ebp]
	call	??0<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QAE@PAVLCDDriver@gb@emulation@@AAH1@Z ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::<lambda_97bc8e9b09435192667e87dfa941ef5a>

; 237  : 
; 238  :   auto incx = [&x,&lineoffset](){
; 239  : 			++x;
; 240  : 			if (x==8) {
; 241  : 				x = 0;
; 242  : 				lineoffset = (lineoffset+1)&0x1F;
; 243  :       }
; 244  :   };

	lea	eax, DWORD PTR _lineoffset$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _incx$[ebp]
	call	??0<lambda_9915241f12bdba8023c4d69393c1c5d7>@@QAE@AAH0@Z ; <lambda_9915241f12bdba8023c4d69393c1c5d7>::<lambda_9915241f12bdba8023c4d69393c1c5d7>

; 245  : 
; 246  : 	if (lcdc_.bgdisplay == 0) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+20]
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@RenderBGLi

; 247  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN7@RenderBGLi
$LN6@RenderBGLi:
	mov	edx, DWORD PTR _i$6[ebp]
	add	edx, 1
	mov	DWORD PTR _i$6[ebp], edx
$LN7@RenderBGLi:
	cmp	DWORD PTR _i$6[ebp], 256		; 00000100H
	jge	SHORT $LN5@RenderBGLi

; 248  : 			colormap[((ly)<<8)+(i)] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	shl	ecx, 8
	add	ecx, DWORD PTR _i$6[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	BYTE PTR [eax+ecx], 0

; 249  : 		}

	jmp	SHORT $LN6@RenderBGLi
$LN5@RenderBGLi:
	jmp	$LN9@RenderBGLi
$LN8@RenderBGLi:

; 250  : 	} else {
; 251  : 		uint8_t* tiledata = &emu_->memory()->vram()[lcdc_.tile_data ==0?0x0800:0x0000];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+20]
	shr	dl, 4
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN11@RenderBGLi
	mov	DWORD PTR tv154[ebp], 2048		; 00000800H
	jmp	SHORT $LN12@RenderBGLi
$LN11@RenderBGLi:
	mov	DWORD PTR tv154[ebp], 0
$LN12@RenderBGLi:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?vram@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::vram
	add	eax, DWORD PTR tv154[ebp]
	mov	DWORD PTR _tiledata$5[ebp], eax

; 252  : 		for (int i=0;i<256;++i) {

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN3@RenderBGLi
$LN2@RenderBGLi:
	mov	edx, DWORD PTR _i$4[ebp]
	add	edx, 1
	mov	DWORD PTR _i$4[ebp], edx
$LN3@RenderBGLi:
	cmp	DWORD PTR _i$4[ebp], 256		; 00000100H
	jge	$LN9@RenderBGLi

; 253  : 			auto tileindex = readTile();

	lea	ecx, DWORD PTR _readTile$[ebp]
	call	??R<lambda_97bc8e9b09435192667e87dfa941ef5a>@@QBEEXZ ; <lambda_97bc8e9b09435192667e87dfa941ef5a>::operator()
	mov	BYTE PTR _tileindex$3[ebp], al

; 254  : 			uint8_t* tile = &tiledata[(tileindex<<4)];

	movzx	eax, BYTE PTR _tileindex$3[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _tiledata$5[ebp]
	mov	DWORD PTR _tile$2[ebp], eax

; 255  :       uint8_t bgcolor = pixel((7-x));

	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR _tile$2[ebp]
	movzx	eax, BYTE PTR [edx+ecx*2]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$[ebp]
	and	ecx, 7
	sar	eax, cl
	and	eax, 1
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR _tile$2[ebp]
	movzx	edx, BYTE PTR [edx+ecx*2+1]
	mov	ecx, 7
	sub	ecx, DWORD PTR _x$[ebp]
	and	ecx, 7
	sar	edx, cl
	shl	edx, 1
	and	edx, 2
	add	eax, edx
	mov	BYTE PTR _bgcolor$1[ebp], al

; 256  :       incx();

	lea	ecx, DWORD PTR _incx$[ebp]
	call	??R<lambda_9915241f12bdba8023c4d69393c1c5d7>@@QBEXXZ ; <lambda_9915241f12bdba8023c4d69393c1c5d7>::operator()

; 257  :       colormap[((ly)<<8)+i] = bg_pal[bgcolor];

	movzx	eax, BYTE PTR _bgcolor$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+24]
	shl	edx, 8
	add	edx, DWORD PTR _i$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+28]
	mov	BYTE PTR [ecx+edx], al

; 258  : 		}

	jmp	$LN2@RenderBGLi
$LN9@RenderBGLi:

; 259  : 	}
; 260  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@RenderBGLi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 108				; 0000006cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@RenderBGLi:
	DD	5
	DD	$LN18@RenderBGLi
$LN18@RenderBGLi:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN13@RenderBGLi
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN14@RenderBGLi
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN15@RenderBGLi
	DD	-60					; ffffffc4H
	DD	12					; 0000000cH
	DD	$LN16@RenderBGLi
	DD	-76					; ffffffb4H
	DD	8
	DD	$LN17@RenderBGLi
$LN17@RenderBGLi:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	120					; 00000078H
	DB	0
$LN16@RenderBGLi:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$LN15@RenderBGLi:
	DB	120					; 00000078H
	DB	0
$LN14@RenderBGLi:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN13@RenderBGLi:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?RenderBGLine@LCDDriver@gb@emulation@@QAEXXZ ENDP	; emulation::gb::LCDDriver::RenderBGLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv154 = -22						; size = 2
tv65 = -20						; size = 4
_i$1 = -16						; size = 4
_dest$2 = -12						; size = 4
_srcaddr$3 = -8						; size = 2
_this$ = -4						; size = 4
_address$ = 8						; size = 2
_data$ = 12						; size = 1
?Write@LCDDriver@gb@emulation@@QAEXGE@Z PROC		; emulation::gb::LCDDriver::Write
; _this$ = ecx

; 121  : void LCDDriver::Write(uint16_t address, uint8_t data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 122  :   switch (address) {

	movzx	eax, WORD PTR _address$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 65344				; 0000ff40H
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 11			; 0000000bH
	ja	$LN19@Write
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN21@Write[edx*4]
$LN16@Write:

; 123  :     case 0xFF40:
; 124  :       lcdc_.raw = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax+20], cl

; 125  :       if (lcdc_.lcd_enable) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+20]
	shr	al, 7
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Write

; 126  :         counter1 = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0
	mov	DWORD PTR [edx+52], 0

; 127  :         counter2 = 4;//4-7 work

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 4
	mov	DWORD PTR [eax+60], 0

; 128  :         ly = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+24], 0

; 129  :         stat_.mode = 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+21]
	and	al, 252					; 000000fcH
	or	al, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+21], al
$LN15@Write:

; 130  :       }
; 131  :       break;

	jmp	$LN19@Write
$LN14@Write:

; 132  :     case 0xFF41:
; 133  :       stat_.raw = (data & ~0x7) | (stat_.raw&0x7);

	movzx	edx, BYTE PTR _data$[ebp]
	and	edx, -8					; fffffff8H
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+21]
	and	ecx, 7
	or	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], dl

; 134  :       break;

	jmp	$LN19@Write
$LN13@Write:

; 135  :     case 0xFF42:
; 136  :       scroll_y = data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [ecx+23], dl

; 137  :       break;

	jmp	$LN19@Write
$LN12@Write:

; 138  :     case 0xFF43:
; 139  :       scroll_x = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax+22], cl

; 140  :       break;

	jmp	$LN19@Write

; 141  :       break;

	jmp	$LN19@Write
$LN11@Write:

; 142  :     case 0xFF44:
; 143  :       ly = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+24], 0

; 144  :       break;

	jmp	$LN19@Write
$LN10@Write:

; 145  :     case 0xFF45:
; 146  :       lyc = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax+25], cl

; 147  :       break;

	jmp	$LN19@Write
$LN9@Write:

; 148  :     case 0xFF46: {
; 149  :       uint16_t srcaddr = data<<8;

	movzx	edx, BYTE PTR _data$[ebp]
	shl	edx, 8
	mov	WORD PTR _srcaddr$3[ebp], dx

; 150  :       auto dest = emu_->memory()->oam();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?oam@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::oam
	mov	DWORD PTR _dest$2[ebp], eax

; 151  :       for (int i=0;i<160;++i)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN8@Write
$LN7@Write:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN8@Write:
	cmp	DWORD PTR _i$1[ebp], 160		; 000000a0H
	jge	SHORT $LN6@Write

; 152  :         *dest++ = emu_->memory()->Read8(srcaddr++);

	mov	dx, WORD PTR _srcaddr$3[ebp]
	mov	WORD PTR tv154[ebp], dx
	mov	ax, WORD PTR _srcaddr$3[ebp]
	add	ax, 1
	mov	WORD PTR _srcaddr$3[ebp], ax
	movzx	ecx, WORD PTR tv154[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, DWORD PTR _dest$2[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _dest$2[ebp]
	add	edx, 1
	mov	DWORD PTR _dest$2[ebp], edx
	jmp	SHORT $LN7@Write
$LN6@Write:

; 153  :       break;

	jmp	$LN19@Write
$LN5@Write:

; 154  :     }
; 155  :     case 0xFF47:
; 156  :       bg_pallete_data = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax+40], cl

; 157  :       bg_pal[0] = data&0x3;

	movzx	edx, BYTE PTR _data$[ebp]
	and	edx, 3
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+28], dl

; 158  :       bg_pal[1] = (data>>2)&0x3;

	movzx	edx, BYTE PTR _data$[ebp]
	sar	edx, 2
	and	edx, 3
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+28], dl

; 159  :       bg_pal[2] = (data>>4)&0x3;

	movzx	edx, BYTE PTR _data$[ebp]
	sar	edx, 4
	and	edx, 3
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+28], dl

; 160  :       bg_pal[3] = (data>>6)&0x3;

	movzx	edx, BYTE PTR _data$[ebp]
	sar	edx, 6
	and	edx, 3
	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+28], dl

; 161  :       break;

	jmp	$LN19@Write
$LN4@Write:

; 162  :     case 0xFF48:
; 163  :       obj_pallete1_data = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _data$[ebp]
	mov	BYTE PTR [edx+41], al

; 164  :       obj_pal1[0] = data&0x3;

	movzx	ecx, BYTE PTR _data$[ebp]
	and	ecx, 3
	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+32], cl

; 165  :       obj_pal1[1] = (data>>2)&0x3;

	movzx	ecx, BYTE PTR _data$[ebp]
	sar	ecx, 2
	and	ecx, 3
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+32], cl

; 166  :       obj_pal1[2] = (data>>4)&0x3;

	movzx	ecx, BYTE PTR _data$[ebp]
	sar	ecx, 4
	and	ecx, 3
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+32], cl

; 167  :       obj_pal1[3] = (data>>6)&0x3;

	movzx	ecx, BYTE PTR _data$[ebp]
	sar	ecx, 6
	and	ecx, 3
	mov	edx, 1
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+32], cl

; 168  :       break;

	jmp	SHORT $LN19@Write
$LN3@Write:

; 169  :     case 0xFF49:
; 170  :       obj_pallete2_data = data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [ecx+42], dl

; 171  :       obj_pal2[0] = data&0x3;

	movzx	eax, BYTE PTR _data$[ebp]
	and	eax, 3
	mov	ecx, 1
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+36], al

; 172  :       obj_pal2[1] = (data>>2)&0x3;

	movzx	eax, BYTE PTR _data$[ebp]
	sar	eax, 2
	and	eax, 3
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+36], al

; 173  :       obj_pal2[2] = (data>>4)&0x3;

	movzx	eax, BYTE PTR _data$[ebp]
	sar	eax, 4
	and	eax, 3
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+36], al

; 174  :       obj_pal2[3] = (data>>6)&0x3;

	movzx	eax, BYTE PTR _data$[ebp]
	sar	eax, 6
	and	eax, 3
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+36], al

; 175  :       break;

	jmp	SHORT $LN19@Write
$LN2@Write:

; 176  :     case 0xFF4A:
; 177  :       wy = data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _data$[ebp]
	mov	BYTE PTR [eax+27], cl

; 178  :       break;

	jmp	SHORT $LN19@Write
$LN1@Write:

; 179  :     case 0xFF4B:
; 180  :       wx = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _data$[ebp]
	mov	BYTE PTR [edx+26], al
$LN19@Write:

; 181  :       break;
; 182  :   }
; 183  : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN21@Write:
	DD	$LN16@Write
	DD	$LN14@Write
	DD	$LN13@Write
	DD	$LN12@Write
	DD	$LN11@Write
	DD	$LN10@Write
	DD	$LN9@Write
	DD	$LN5@Write
	DD	$LN4@Write
	DD	$LN3@Write
	DD	$LN2@Write
	DD	$LN1@Write
?Write@LCDDriver@gb@emulation@@QAEXGE@Z ENDP		; emulation::gb::LCDDriver::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
_address$ = 8						; size = 2
?Read@LCDDriver@gb@emulation@@QAEEG@Z PROC		; emulation::gb::LCDDriver::Read
; _this$ = ecx

; 92   : uint8_t LCDDriver::Read(uint16_t address) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 
; 94   :   switch (address) {

	movzx	eax, WORD PTR _address$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 65344				; 0000ff40H
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 11			; 0000000bH
	ja	SHORT $LN12@Read
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN16@Read[edx*4]
$LN11@Read:

; 95   :     case 0xFF40:
; 96   :       return lcdc_.raw;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+20]
	jmp	SHORT $LN14@Read
$LN10@Read:

; 97   :     case 0xFF41:
; 98   :       return stat_.raw;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+21]
	jmp	SHORT $LN14@Read
$LN9@Read:

; 99   :     case 0xFF42:
; 100  :       return scroll_y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+23]
	jmp	SHORT $LN14@Read
$LN8@Read:

; 101  :     case 0xFF43:
; 102  :       return scroll_x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+22]
	jmp	SHORT $LN14@Read
$LN7@Read:

; 103  :     case 0xFF44:
; 104  :       return ly;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+24]
	jmp	SHORT $LN14@Read
$LN6@Read:

; 105  :     case 0xFF45:
; 106  :       return lyc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+25]
	jmp	SHORT $LN14@Read
$LN5@Read:

; 107  :     case 0xFF47:
; 108  :       return bg_pallete_data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+40]
	jmp	SHORT $LN14@Read
$LN4@Read:

; 109  :     case 0xFF48:
; 110  :       return obj_pallete1_data;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+41]
	jmp	SHORT $LN14@Read
$LN3@Read:

; 111  :     case 0xFF49:
; 112  :       return obj_pallete2_data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+42]
	jmp	SHORT $LN14@Read
$LN2@Read:

; 113  :     case 0xFF4A:
; 114  :       return wy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+27]
	jmp	SHORT $LN14@Read
$LN1@Read:

; 115  :     case 0xFF4B:
; 116  :       return wx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+26]
	jmp	SHORT $LN14@Read
$LN12@Read:

; 117  :   }
; 118  : 	return 0;

	xor	al, al
$LN14@Read:

; 119  : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN16@Read:
	DD	$LN11@Read
	DD	$LN10@Read
	DD	$LN9@Read
	DD	$LN8@Read
	DD	$LN7@Read
	DD	$LN6@Read
	DD	$LN12@Read
	DD	$LN5@Read
	DD	$LN4@Read
	DD	$LN3@Read
	DD	$LN2@Read
	DD	$LN1@Read
?Read@LCDDriver@gb@emulation@@QAEEG@Z ENDP		; emulation::gb::LCDDriver::Read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
tv320 = -64						; size = 4
tv292 = -57						; size = 1
tv432 = -56						; size = 4
tv248 = -52						; size = 4
tv247 = -48						; size = 4
tv423 = -44						; size = 4
tv234 = -40						; size = 4
tv221 = -36						; size = 4
tv399 = -32						; size = 4
tv185 = -28						; size = 4
tv364 = -24						; size = 4
tv356 = -20						; size = 4
tv90 = -16						; size = 4
tv74 = -12						; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_dt$ = 8						; size = 8
?Step@LCDDriver@gb@emulation@@QAEXN@Z PROC		; emulation::gb::LCDDriver::Step
; _this$ = ecx

; 31   : void LCDDriver::Step(double dt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 32   :   ++counter2; //line clock

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	add	ecx, 1
	mov	edx, DWORD PTR [eax+60]
	adc	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], ecx
	mov	DWORD PTR [eax+60], edx

; 33   :   ++counter1;//screen clock

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	add	edx, 1
	mov	eax, DWORD PTR [ecx+52]
	adc	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], edx
	mov	DWORD PTR [ecx+52], eax

; 34   : 
; 35   : 
; 36   : 	switch (stat_.mode) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+21]
	and	al, 3
	movzx	ecx, al
	mov	DWORD PTR tv74[ebp], ecx
	cmp	DWORD PTR tv74[ebp], 3
	ja	$LN19@Step
	mov	edx, DWORD PTR tv74[ebp]
	jmp	DWORD PTR $LN27@Step[edx*4]
$LN18@Step:

; 37   : 		case 2:
; 38   :       if (stat_.oam_int)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+21]
	shr	cl, 5
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@Step

; 39   :         emu_->memory()->interrupt_flag() |= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv90[ebp], eax
	mov	ecx, DWORD PTR tv90[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, 2
	mov	eax, DWORD PTR tv90[ebp]
	mov	BYTE PTR [eax], dl
$LN17@Step:

; 40   : 			if (counter2==80)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv356[ebp], ecx
	mov	edx, DWORD PTR tv356[ebp]
	cmp	DWORD PTR [edx+56], 80			; 00000050H
	jne	SHORT $LN16@Step
	mov	eax, DWORD PTR tv356[ebp]
	cmp	DWORD PTR [eax+60], 0
	jne	SHORT $LN16@Step

; 41   : 				stat_.mode = 3;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+21]
	or	dl, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], dl
$LN16@Step:

; 42   : 			break;

	jmp	$LN19@Step
$LN15@Step:

; 43   : 		case 3:
; 44   : 		  if (counter2 == 282) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv364[ebp], ecx
	mov	edx, DWORD PTR tv364[ebp]
	cmp	DWORD PTR [edx+56], 282			; 0000011aH
	jne	SHORT $LN14@Step
	mov	eax, DWORD PTR tv364[ebp]
	cmp	DWORD PTR [eax+60], 0
	jne	SHORT $LN14@Step

; 45   : 	  		RenderLine();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenderLine@LCDDriver@gb@emulation@@QAEXXZ ; emulation::gb::LCDDriver::RenderLine

; 46   : 				stat_.mode = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+21]
	and	dl, 252					; 000000fcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], dl
$LN14@Step:

; 47   : 
; 48   : 			}
; 49   : 			break;

	jmp	$LN19@Step
$LN13@Step:

; 50   : 		case 0:
; 51   :       if (sprite_bug_counter > 0 && lcdc_.lcd_enable == 1) {

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+8]
	test	edx, edx
	jle	SHORT $LN12@Step
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+20]
	shr	cl, 7
	and	cl, 1
	movzx	edx, cl
	cmp	edx, 1
	jne	SHORT $LN12@Step

; 52   :         emu_->memory()->oam()[8+(rand()%152)] = rand()&0xFF; 

	mov	esi, esp
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ebx, eax
	and	ebx, 255				; 000000ffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?oam@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::oam
	mov	esi, eax
	mov	edi, esp
	call	DWORD PTR __imp__rand
	cmp	edi, esp
	call	__RTC_CheckEsp
	cdq
	mov	ecx, 152				; 00000098H
	idiv	ecx
	mov	BYTE PTR [esi+edx+8], bl

; 53   :         --sprite_bug_counter;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+8]
	sub	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+8], al
$LN12@Step:

; 54   :       }
; 55   :       if (stat_.hblank_int)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+21]
	shr	al, 3
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@Step

; 56   :         emu_->memory()->interrupt_flag() |= 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv185[ebp], eax
	mov	eax, DWORD PTR tv185[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR tv185[ebp]
	mov	BYTE PTR [edx], cl
$LN11@Step:

; 57   : 
; 58   : 			if (counter2==456) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv399[ebp], eax
	mov	ecx, DWORD PTR tv399[ebp]
	cmp	DWORD PTR [ecx+56], 456			; 000001c8H
	jne	SHORT $LN10@Step
	mov	edx, DWORD PTR tv399[ebp]
	cmp	DWORD PTR [edx+60], 0
	jne	SHORT $LN10@Step

; 59   : 				stat_.mode = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+21]
	and	cl, 252					; 000000fcH
	or	cl, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+21], cl

; 60   :         if (ly == 143) 

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	cmp	ecx, 143				; 0000008fH
	jne	SHORT $LN10@Step

; 61   : 					stat_.mode = 1;//vblank period

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+21]
	and	al, 252					; 000000fcH
	or	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+21], al
$LN10@Step:

; 62   :       }
; 63   : 			break;

	jmp	SHORT $LN19@Step
$LN8@Step:

; 64   : 		case 1:
; 65   :         if (stat_.vblank_int)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+21]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@Step

; 66   :           emu_->memory()->interrupt_flag() |= 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv221[ebp], eax
	mov	eax, DWORD PTR tv221[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR tv221[ebp]
	mov	BYTE PTR [edx], cl
$LN7@Step:

; 67   : 				emu_->memory()->interrupt_flag() |= 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv234[ebp], eax
	mov	ecx, DWORD PTR tv234[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR tv234[ebp]
	mov	BYTE PTR [eax], dl
$LN19@Step:

; 68   : 			break;
; 69   : 	}
; 70   : 
; 71   : 	
; 72   :   if (counter2 == 456) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv423[ebp], ecx
	mov	edx, DWORD PTR tv423[ebp]
	cmp	DWORD PTR [edx+56], 456			; 000001c8H
	jne	$LN6@Step
	mov	eax, DWORD PTR tv423[ebp]
	cmp	DWORD PTR [eax+60], 0
	jne	$LN6@Step

; 73   : 		if (ly++ == 153 && counter2 == 456) {

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+24]
	mov	DWORD PTR tv247[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+24]
	add	cl, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+24], cl
	cmp	DWORD PTR tv247[ebp], 153		; 00000099H
	jne	SHORT $LN23@Step
	mov	DWORD PTR tv248[ebp], 1
	jmp	SHORT $LN24@Step
$LN23@Step:
	mov	DWORD PTR tv248[ebp], 0
$LN24@Step:
	cmp	DWORD PTR tv248[ebp], 0
	je	$LN5@Step
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv432[ebp], eax
	mov	ecx, DWORD PTR tv432[ebp]
	cmp	DWORD PTR [ecx+56], 456			; 000001c8H
	jne	$LN5@Step
	mov	edx, DWORD PTR tv432[ebp]
	cmp	DWORD PTR [edx+60], 0
	jne	$LN5@Step

; 74   :       for (int i=0;i<256*256;++i)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@Step
$LN3@Step:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@Step:
	cmp	DWORD PTR _i$1[ebp], 65536		; 00010000H
	jge	SHORT $LN2@Step

; 75   :         frame_buffer[i] = pal32[colormap[i]];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$1[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _pal32[ecx*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN3@Step
$LN2@Step:

; 76   :       //if (lcdc_.lcd_enable)
; 77   : 			emu_->on_render();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	??R?$_Func_class@XU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@QBEXXZ ; std::_Func_class<void,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()

; 78   : 			stat_.mode = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+21]
	and	cl, 252					; 000000fcH
	or	cl, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+21], cl

; 79   : 			ly = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 0

; 80   : 			counter1 = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0

; 81   : 			counter2 = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0
	mov	DWORD PTR [edx+60], 0
$LN5@Step:

; 82   : 		} 
; 83   : 		counter2 = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0
	mov	DWORD PTR [eax+60], 0
$LN6@Step:

; 84   : 	}
; 85   : 
; 86   :   stat_.coincidence = lyc == ly;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+25]
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	cmp	edx, ecx
	jne	SHORT $LN25@Step
	mov	BYTE PTR tv292[ebp], 1
	jmp	SHORT $LN26@Step
$LN25@Step:
	mov	BYTE PTR tv292[ebp], 0
$LN26@Step:
	mov	dl, BYTE PTR tv292[ebp]
	and	dl, 1
	shl	dl, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+21]
	and	cl, 251					; 000000fbH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+21], cl

; 87   :   if (stat_.coincidence_inr && stat_.coincidence)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+21]
	shr	cl, 6
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN21@Step
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+21]
	shr	cl, 2
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN21@Step

; 88   :     emu_->memory()->interrupt_flag() |= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv320[ebp], eax
	mov	ecx, DWORD PTR tv320[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, 2
	mov	eax, DWORD PTR tv320[ebp]
	mov	BYTE PTR [eax], dl
$LN21@Step:

; 89   : 
; 90   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN27@Step:
	DD	$LN13@Step
	DD	$LN8@Step
	DD	$LN18@Step
	DD	$LN15@Step
?Step@LCDDriver@gb@emulation@@QAEXN@Z ENDP		; emulation::gb::LCDDriver::Step
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_ioports$ = -8						; size = 4
_this$ = -4						; size = 4
?Deinitialize@LCDDriver@gb@emulation@@UAEXXZ PROC	; emulation::gb::LCDDriver::Deinitialize
; _this$ = ecx

; 25   : void LCDDriver::Deinitialize() {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 26   :   auto ioports = emu_->memory()->ioports();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?ioports@Memory@gb@emulation@@QAEPAEXZ	; emulation::gb::Memory::ioports
	mov	DWORD PTR _ioports$[ebp], eax

; 27   :   delete [] colormap;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 28   :   delete [] frame_buffer;  

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 29   : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Deinitialize@LCDDriver@gb@emulation@@UAEXXZ ENDP	; emulation::gb::LCDDriver::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\lcd_driver.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
_emu$ = 8						; size = 4
?Initialize@LCDDriver@gb@emulation@@UAEXPAVEmu@23@@Z PROC ; emulation::gb::LCDDriver::Initialize
; _this$ = ecx

; 9    : void LCDDriver::Initialize(Emu* emu) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 10   :   Component::Initialize(emu);

	mov	eax, DWORD PTR _emu$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ; emulation::gb::Component::Initialize

; 11   :   frame_buffer = new uint32_t[256*256];

	push	11					; 0000000bH
	push	OFFSET $SG153652
	push	1
	push	262144					; 00040000H
	call	??_U@YAPAXIHPBDH@Z			; operator new[]
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+12], edx

; 12   :   lcdc_.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+20], 0

; 13   :   stat_.raw = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+21], 2

; 14   :   ly = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+24], 0

; 15   :   lyc = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+25], 0

; 16   :   scroll_x = scroll_y = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+23], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+22], 0

; 17   :   wx = wy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+27], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+26], 0

; 18   :   counter1 = counter2 = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0
	mov	DWORD PTR [edx+60], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+52], 0

; 19   :   vsync = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [ecx+64], xmm0

; 20   :   hsync = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [edx+72], xmm0

; 21   :   sprite_bug_counter = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+8], 0

; 22   :   colormap = new uint8_t[256*256];

	push	22					; 00000016H
	push	OFFSET $SG153655
	push	1
	push	65536					; 00010000H
	call	??_U@YAPAXIHPBDH@Z			; operator new[]
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+16], edx

; 23   : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Initialize@LCDDriver@gb@emulation@@UAEXPAVEmu@23@@Z ENDP ; emulation::gb::LCDDriver::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ PROC	; emulation::gb::Memory::interrupt_flag, COMDAT
; _this$ = ecx

; 21   :   uint8_t& interrupt_flag() {  return ioports_[0x0F]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	imul	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+184]
	mov	esp, ebp
	pop	ebp
	ret	0
?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ENDP	; emulation::gb::Memory::interrupt_flag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?ioports@Memory@gb@emulation@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ioports@Memory@gb@emulation@@QAEPAEXZ PROC		; emulation::gb::Memory::ioports, COMDAT
; _this$ = ecx

; 19   :   uint8_t* ioports() { return ioports_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 184				; 000000b8H
	mov	esp, ebp
	pop	ebp
	ret	0
?ioports@Memory@gb@emulation@@QAEPAEXZ ENDP		; emulation::gb::Memory::ioports
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?oam@Memory@gb@emulation@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?oam@Memory@gb@emulation@@QAEPAEXZ PROC			; emulation::gb::Memory::oam, COMDAT
; _this$ = ecx

; 18   :   uint8_t* oam() { return oam_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	esp, ebp
	pop	ebp
	ret	0
?oam@Memory@gb@emulation@@QAEPAEXZ ENDP			; emulation::gb::Memory::oam
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?vram@Memory@gb@emulation@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?vram@Memory@gb@emulation@@QAEPAEXZ PROC		; emulation::gb::Memory::vram, COMDAT
; _this$ = ecx

; 17   : 	uint8_t* vram() { return vram_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?vram@Memory@gb@emulation@@QAEPAEXZ ENDP		; emulation::gb::Memory::vram
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\gb.h
;	COMDAT ?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_emu$ = 8						; size = 4
?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z PROC ; emulation::gb::Component::Initialize, COMDAT
; _this$ = ecx

; 28   :   virtual void Initialize(Emu* emu) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 29   :     emu_ = emu;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _emu$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 30   :   }

	mov	esp, ebp
	pop	ebp
	ret	4
?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ENDP ; emulation::gb::Component::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 137  : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$yc	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 130  : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Ignore@std@@QAE@XZ PROC				; std::_Ignore::_Ignore, COMDAT
; _this$ = ecx

; 120  : 	_Ignore()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Ignore@std@@QAE@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
