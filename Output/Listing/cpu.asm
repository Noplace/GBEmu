; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

	TITLE	D:\Personal\Projects\GBEmu\Solution\Code\emulation\gb\cpu.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?value@?$_Abs@$0GE@@std@@2_JB			; std::_Abs<100>::value
PUBLIC	?value@?$_Abs@$0DLJKMKAA@@std@@2_JB		; std::_Abs<1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?value@?$_GcdX@$0GE@$0A@@std@@2_JB		; std::_GcdX<100,0>::value
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB	; std::_GcdX<1000000000,100>::value
PUBLIC	?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
PUBLIC	?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
PUBLIC	?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<100,1000000000>::value
PUBLIC	?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
PUBLIC	?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
PUBLIC	?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<100,1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$_Abs@$00@std@@2_JB			; std::_Abs<1>::value
PUBLIC	?value@?$_GcdX@$00$0A@@std@@2_JB		; std::_GcdX<1,0>::value
PUBLIC	?value@?$_GcdX@$00$00@std@@2_JB			; std::_GcdX<1,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?value@?$_Gcd@$00$00@std@@2_JB			; std::_Gcd<1,1>::value
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_monotonic@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_monotonic
PUBLIC	?is_steady@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_steady
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?value@?$integral_constant@H$0A@@std@@2HB	; std::integral_constant<int,0>::value
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
PUBLIC	?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
PUBLIC	?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_nonNull
PUBLIC	?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelException
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_notInlined
PUBLIC	?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_structured
PUBLIC	?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_localCancel
PUBLIC	?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_reserved
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
PUBLIC	?value@?$_Abs@$0JIJGIA@@std@@2_JB		; std::_Abs<10000000>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB		; std::_GcdX<10000000,0>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_GcdX<10000000,10000000>::value
PUBLIC	?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Gcd<10000000,10000000>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?num@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::num
PUBLIC	?den@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::den
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?is_monotonic@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_monotonic
PUBLIC	?is_steady@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_steady
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	_ConcRT_ProviderGuid
PUBLIC	_ConcRTEventGuid
PUBLIC	_SchedulerEventGuid
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	_ScheduleGroupEventGuid
PUBLIC	_ContextEventGuid
PUBLIC	_ChoreEventGuid
PUBLIC	_VirtualProcessorEventGuid
PUBLIC	_LockEventGuid
PUBLIC	_ResourceManagerEventGuid
PUBLIC	_PPLParallelInvokeEventGuid
PUBLIC	_PPLParallelForEventGuid
PUBLIC	_PPLParallelForeachEventGuid
PUBLIC	_AgentEventGuid
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB		; std::_GcdX<10000000,1>::value
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB		; std::_GcdX<1,10000000>::value
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB		; std::_Gcd<1,10000000>::value
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?num@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::num
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?den@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::den
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::ratio<1,10000000>::den
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,10000000>::num
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,10000000>::value
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000000>::value
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000000,1>::value
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT _AgentEventGuid
CONST	SEGMENT
_AgentEventGuid DD 0b9b5b78cH
	DW	0713H
	DW	04898H
	DB	0a2H
	DB	01aH
	DB	0c6H
	DB	079H
	DB	049H
	DB	0dcH
	DB	0edH
	DB	07H
CONST	ENDS
;	COMDAT _PPLParallelForeachEventGuid
CONST	SEGMENT
_PPLParallelForeachEventGuid DD 05cb7d785H
	DW	09d66H
	DW	0465dH
	DB	0baH
	DB	0e1H
	DB	046H
	DB	011H
	DB	06H
	DB	01bH
	DB	054H
	DB	034H
CONST	ENDS
;	COMDAT _PPLParallelForEventGuid
CONST	SEGMENT
_PPLParallelForEventGuid DD 031c8da6bH
	DW	06165H
	DW	04042H
	DB	08bH
	DB	092H
	DB	094H
	DB	09eH
	DB	031H
	DB	05fH
	DB	04dH
	DB	084H
CONST	ENDS
;	COMDAT _PPLParallelInvokeEventGuid
CONST	SEGMENT
_PPLParallelInvokeEventGuid DD 0d1b5b133H
	DW	0ec3dH
	DW	049f4H
	DB	098H
	DB	0a3H
	DB	046H
	DB	04dH
	DB	01aH
	DB	09eH
	DB	046H
	DB	082H
CONST	ENDS
;	COMDAT _ResourceManagerEventGuid
CONST	SEGMENT
_ResourceManagerEventGuid DD 02718d25bH
	DW	05bf5H
	DW	04479H
	DB	08eH
	DB	088H
	DB	0baH
	DB	0bcH
	DB	064H
	DB	0bdH
	DB	0bfH
	DB	0caH
CONST	ENDS
;	COMDAT _LockEventGuid
CONST	SEGMENT
_LockEventGuid DD 079a60dc6H
	DW	05fc8H
	DW	04952H
	DB	0a4H
	DB	01cH
	DB	011H
	DB	063H
	DB	0aeH
	DB	0ecH
	DB	05eH
	DB	0b8H
CONST	ENDS
;	COMDAT _VirtualProcessorEventGuid
CONST	SEGMENT
_VirtualProcessorEventGuid DD 02f27805fH
	DW	01676H
	DW	04eccH
	DB	096H
	DB	0faH
	DB	07eH
	DB	0b0H
	DB	09dH
	DB	044H
	DB	030H
	DB	02fH
CONST	ENDS
;	COMDAT _ChoreEventGuid
CONST	SEGMENT
_ChoreEventGuid DD 07e854ec7H
	DW	0cdc4H
	DW	0405aH
	DB	0b5H
	DB	0b2H
	DB	0aaH
	DB	0f7H
	DB	0c9H
	DB	0e7H
	DB	0d4H
	DB	0cH
CONST	ENDS
;	COMDAT _ContextEventGuid
CONST	SEGMENT
_ContextEventGuid DD 05727a00fH
	DW	050beH
	DW	04519H
	DB	082H
	DB	056H
	DB	0f7H
	DB	069H
	DB	098H
	DB	071H
	DB	0feH
	DB	0cbH
CONST	ENDS
;	COMDAT _ScheduleGroupEventGuid
CONST	SEGMENT
_ScheduleGroupEventGuid DD 0e8a3bf1fH
	DW	0a86bH
	DW	04390H
	DB	09cH
	DB	060H
	DB	053H
	DB	090H
	DB	0b9H
	DB	069H
	DB	0d2H
	DB	02cH
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT _SchedulerEventGuid
CONST	SEGMENT
_SchedulerEventGuid DD 0e2091f8aH
	DW	01e0aH
	DW	04731H
	DB	084H
	DB	0a2H
	DB	0dH
	DB	0d5H
	DB	07cH
	DB	08aH
	DB	052H
	DB	061H
CONST	ENDS
;	COMDAT _ConcRTEventGuid
CONST	SEGMENT
_ConcRTEventGuid DD 072b14a7dH
	DW	0704cH
	DW	0423eH
	DB	092H
	DB	0f8H
	DB	07eH
	DB	06dH
	DB	064H
	DB	0bcH
	DB	0b9H
	DB	02aH
CONST	ENDS
;	COMDAT _ConcRT_ProviderGuid
CONST	SEGMENT
_ConcRT_ProviderGuid DD 0f7b697a3H
	DW	04db5H
	DW	04d3bH
	DB	0beH
	DB	071H
	DB	0c4H
	DB	0d2H
	DB	084H
	DB	0e6H
	DB	059H
	DB	02fH
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?is_steady@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@steady_clock@chrono@std@@2_NB DB 01H		; std::chrono::steady_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@steady_clock@chrono@std@@2_NB DB 01H	; std::chrono::steady_clock::is_monotonic
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::num
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0JIJGIA@@std@@2_JB DQ 0000000000989680H	; std::_Abs<10000000>::value
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_reserved
CONST	ENDS
;	COMDAT ?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_localCancel
CONST	ENDS
;	COMDAT ?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_structured
CONST	ENDS
;	COMDAT ?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB DD 0ffffffffH ; Concurrency::details::_TaskCollectionBase::_S_notInlined
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_cancelException
CONST	ENDS
;	COMDAT ?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB DD 08H ; Concurrency::details::_TaskCollectionBase::_S_nonNull
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
CONST	ENDS
;	COMDAT ?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
CONST	ENDS
;	COMDAT ?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB DD 00H ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@H$0A@@std@@2HB
CONST	SEGMENT
?value@?$integral_constant@H$0A@@std@@2HB DD 00H	; std::integral_constant<int,0>::value
CONST	ENDS
CONST	SEGMENT
_reg_index DD	03H
	DD	02H
	DD	05H
	DD	04H
	DD	07H
	DD	06H
	DD	07H
	DD	01H
_dutycycletable DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?is_steady@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@system_clock@chrono@std@@2_NB DB 00H		; std::chrono::system_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@system_clock@chrono@std@@2_NB DB 00H	; std::chrono::system_clock::is_monotonic
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0A@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$00@std@@2_JB DQ 0000000000000001H	; std::_Abs<1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_Gcd<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB DD 03H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
CONST	ENDS
;	COMDAT ?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 02H ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 01H ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
CONST	ENDS
;	COMDAT ?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB DD 00H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<1000000000,100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0A@@std@@2_JB DQ 0000000000000064H	; std::_GcdX<100,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Abs<1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0GE@@std@@2_JB DQ 0000000000000064H	; std::_Abs<100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
PUBLIC	??0_Ignore@std@@QAE@XZ				; std::_Ignore::_Ignore
PUBLIC	?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ; emulation::gb::Component::Initialize
PUBLIC	?Deinitialize@Component@gb@emulation@@UAEXXZ	; emulation::gb::Component::Deinitialize
PUBLIC	?Reset@Component@gb@emulation@@UAEXXZ		; emulation::gb::Component::Reset
PUBLIC	??0Component@gb@emulation@@QAE@XZ		; emulation::gb::Component::Component
PUBLIC	?interrupt_enable@Memory@gb@emulation@@QAEAAEXZ	; emulation::gb::Memory::interrupt_enable
PUBLIC	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ	; emulation::gb::Memory::interrupt_flag
PUBLIC	?lcdc@LCDDriver@gb@emulation@@QAEABTLCDControlRegister@23@XZ ; emulation::gb::LCDDriver::lcdc
PUBLIC	??0Cpu@gb@emulation@@QAE@XZ			; emulation::gb::Cpu::Cpu
PUBLIC	??1Cpu@gb@emulation@@QAE@XZ			; emulation::gb::Cpu::~Cpu
PUBLIC	?Initialize@Cpu@gb@emulation@@UAEXPAVEmu@23@@Z	; emulation::gb::Cpu::Initialize
PUBLIC	?Deinitialize@Cpu@gb@emulation@@UAEXXZ		; emulation::gb::Cpu::Deinitialize
PUBLIC	?Reset@Cpu@gb@emulation@@UAEXXZ			; emulation::gb::Cpu::Reset
PUBLIC	?Tick@Cpu@gb@emulation@@QAEXXZ			; emulation::gb::Cpu::Tick
PUBLIC	?Step@Cpu@gb@emulation@@QAEXN@Z			; emulation::gb::Cpu::Step
PUBLIC	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::simulateSpriteBug
PUBLIC	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z	; emulation::gb::Cpu::updateCpuFlagC
PUBLIC	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z	; emulation::gb::Cpu::updateCpuFlagH
PUBLIC	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z	; emulation::gb::Cpu::updateCpuFlagZ
PUBLIC	?push@Cpu@gb@emulation@@AAEXE@Z			; emulation::gb::Cpu::push
PUBLIC	?pop@Cpu@gb@emulation@@AAEEXZ			; emulation::gb::Cpu::pop
PUBLIC	?pushPC@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::pushPC
PUBLIC	?NOP@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::NOP
PUBLIC	?ILLEGAL@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::ILLEGAL
PUBLIC	?RST@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::RST
PUBLIC	?LDSPHL@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDSPHL
PUBLIC	?LDHLSPr8@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDHLSPr8
PUBLIC	?LDa16SP@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDa16SP
PUBLIC	?ADD_SPr8@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::ADD_SPr8
PUBLIC	?SCF@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::SCF
PUBLIC	?CCF@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::CCF
PUBLIC	?HALT@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::HALT
PUBLIC	?STOP@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::STOP
PUBLIC	?CPL@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::CPL
PUBLIC	?PREFIX_CB@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::PREFIX_CB
PUBLIC	?JR@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::JR
PUBLIC	?JP@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::JP
PUBLIC	?JP_HL@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::JP_HL
PUBLIC	?CALL@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::CALL
PUBLIC	?RET@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::RET
PUBLIC	?RLCA@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::RLCA
PUBLIC	?RRCA@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::RRCA
PUBLIC	?RLA@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::RLA
PUBLIC	?RRA@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::RRA
PUBLIC	?CP@Cpu@gb@emulation@@AAEXEE@Z			; emulation::gb::Cpu::CP
PUBLIC	?CP_d8@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::CP_d8
PUBLIC	?CP_HL@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::CP_HL
PUBLIC	?DI@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::DI
PUBLIC	?EI@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::EI
PUBLIC	?RETI@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::RETI
PUBLIC	?DAA@Cpu@gb@emulation@@AAEXXZ			; emulation::gb::Cpu::DAA
PUBLIC	?cartridge@Emu@gb@emulation@@QAEPAVCartridge@23@XZ ; emulation::gb::Emu::cartridge
PUBLIC	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ	; emulation::gb::Emu::memory
PUBLIC	?lcd_driver@Emu@gb@emulation@@QAEPAVLCDDriver@23@XZ ; emulation::gb::Emu::lcd_driver
PUBLIC	?sc@Emu@gb@emulation@@QAEPAVSoundController@23@XZ ; emulation::gb::Emu::sc
PUBLIC	?timer@Emu@gb@emulation@@QAEPAVTimer@23@XZ	; emulation::gb::Emu::timer
PUBLIC	??$LDrd16@$00@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrd16<1>
PUBLIC	??$LD$rr@$00$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD$rr<1,1>
PUBLIC	??$INC_16bit@$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::INC_16bit<1>
PUBLIC	??$INC_8bit@$02$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::INC_8bit<3,0>
PUBLIC	??$DEC_8bit@$02$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::DEC_8bit<3,0>
PUBLIC	??$LD@$02$0A@$09@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD<3,0,10>
PUBLIC	??$ADD_16bit@$02$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADD_16bit<3,1>
PUBLIC	??$LDr$r@$00$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LDr$r<1,1>
PUBLIC	??$DEC_16bit@$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::DEC_16bit<1>
PUBLIC	??$INC_8bit@$01$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::INC_8bit<2,0>
PUBLIC	??$DEC_8bit@$01$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::DEC_8bit<2,0>
PUBLIC	??$LD@$01$0A@$09@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD<2,0,10>
PUBLIC	??$LDrd16@$01@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrd16<2>
PUBLIC	??$LD$rr@$01$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD$rr<2,1>
PUBLIC	??$INC_16bit@$01@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::INC_16bit<2>
PUBLIC	??$INC_8bit@$04$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::INC_8bit<5,0>
PUBLIC	??$DEC_8bit@$04$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::DEC_8bit<5,0>
PUBLIC	??$LD@$04$0A@$09@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD<5,0,10>
PUBLIC	??$ADD_16bit@$02$01@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADD_16bit<3,2>
PUBLIC	??$LDr$r@$00$01@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LDr$r<1,2>
PUBLIC	??$DEC_16bit@$01@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::DEC_16bit<2>
PUBLIC	??$INC_8bit@$03$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::INC_8bit<4,0>
PUBLIC	??$DEC_8bit@$03$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::DEC_8bit<4,0>
PUBLIC	??$LD@$03$0A@$09@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD<4,0,10>
PUBLIC	??$JR_cc@$06$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::JR_cc<7,1>
PUBLIC	??$LDrd16@$02@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrd16<3>
PUBLIC	??$LDI$regreg@$02$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LDI$regreg<3,1>
PUBLIC	??$INC_16bit@$02@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::INC_16bit<3>
PUBLIC	??$INC_8bit@$06$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::INC_8bit<7,0>
PUBLIC	??$DEC_8bit@$06$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::DEC_8bit<7,0>
PUBLIC	??$LD@$06$0A@$09@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD<7,0,10>
PUBLIC	??$JR_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::JR_cc<7,0>
PUBLIC	??$ADD_16bit@$02$02@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADD_16bit<3,3>
PUBLIC	??$LDIreg$reg@$00$02@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LDIreg$reg<1,3>
PUBLIC	??$DEC_16bit@$02@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::DEC_16bit<3>
PUBLIC	??$INC_8bit@$05$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::INC_8bit<6,0>
PUBLIC	??$DEC_8bit@$05$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::DEC_8bit<6,0>
PUBLIC	??$LD@$05$0A@$09@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD<6,0,10>
PUBLIC	??$JR_cc@$03$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::JR_cc<4,1>
PUBLIC	??$LDrd16@$03@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrd16<4>
PUBLIC	??$LDD$regreg@$02$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LDD$regreg<3,1>
PUBLIC	??$INC_16bit@$03@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::INC_16bit<4>
PUBLIC	??$INC_8bit@$02$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::INC_8bit<3,1>
PUBLIC	??$DEC_8bit@$02$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::DEC_8bit<3,1>
PUBLIC	??$LD@$02$0A@$0L@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD<3,0,11>
PUBLIC	??$JR_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::JR_cc<4,0>
PUBLIC	??$ADD_16bit@$02$03@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADD_16bit<3,4>
PUBLIC	??$LDDreg$reg@$00$02@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LDDreg$reg<1,3>
PUBLIC	??$DEC_16bit@$03@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::DEC_16bit<4>
PUBLIC	??$INC_8bit@$00$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::INC_8bit<1,0>
PUBLIC	??$DEC_8bit@$00$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::DEC_8bit<1,0>
PUBLIC	??$LD@$00$0A@$09@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD<1,0,10>
PUBLIC	??$LDrr@$02$02@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<3,3>
PUBLIC	??$LDrr@$02$01@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<3,2>
PUBLIC	??$LDrr@$02$04@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<3,5>
PUBLIC	??$LDrr@$02$03@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<3,4>
PUBLIC	??$LDrr@$02$06@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<3,7>
PUBLIC	??$LDrr@$02$05@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<3,6>
PUBLIC	??$LDr$r@$02$02@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LDr$r<3,3>
PUBLIC	??$LDrr@$02$00@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<3,1>
PUBLIC	??$LDrr@$01$02@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<2,3>
PUBLIC	??$LDrr@$01$01@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<2,2>
PUBLIC	??$LDrr@$01$04@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<2,5>
PUBLIC	??$LDrr@$01$03@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<2,4>
PUBLIC	??$LDrr@$01$06@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<2,7>
PUBLIC	??$LDrr@$01$05@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<2,6>
PUBLIC	??$LDr$r@$01$02@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LDr$r<2,3>
PUBLIC	??$LDrr@$01$00@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<2,1>
PUBLIC	??$LDrr@$04$02@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<5,3>
PUBLIC	??$LDrr@$04$01@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<5,2>
PUBLIC	??$LDrr@$04$04@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<5,5>
PUBLIC	??$LDrr@$04$03@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<5,4>
PUBLIC	??$LDrr@$04$06@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<5,7>
PUBLIC	??$LDrr@$04$05@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<5,6>
PUBLIC	??$LDr$r@$04$02@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LDr$r<5,3>
PUBLIC	??$LDrr@$04$00@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<5,1>
PUBLIC	??$LDrr@$03$02@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<4,3>
PUBLIC	??$LDrr@$03$01@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<4,2>
PUBLIC	??$LDrr@$03$04@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<4,5>
PUBLIC	??$LDrr@$03$03@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<4,4>
PUBLIC	??$LDrr@$03$06@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<4,7>
PUBLIC	??$LDrr@$03$05@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<4,6>
PUBLIC	??$LDr$r@$03$02@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LDr$r<4,3>
PUBLIC	??$LDrr@$03$00@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<4,1>
PUBLIC	??$LDrr@$06$02@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<7,3>
PUBLIC	??$LDrr@$06$01@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<7,2>
PUBLIC	??$LDrr@$06$04@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<7,5>
PUBLIC	??$LDrr@$06$03@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<7,4>
PUBLIC	??$LDrr@$06$06@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<7,7>
PUBLIC	??$LDrr@$06$05@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<7,6>
PUBLIC	??$LDr$r@$06$02@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LDr$r<7,3>
PUBLIC	??$LDrr@$06$00@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<7,1>
PUBLIC	??$LDrr@$05$02@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<6,3>
PUBLIC	??$LDrr@$05$01@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<6,2>
PUBLIC	??$LDrr@$05$04@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<6,5>
PUBLIC	??$LDrr@$05$03@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<6,4>
PUBLIC	??$LDrr@$05$06@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<6,7>
PUBLIC	??$LDrr@$05$05@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<6,6>
PUBLIC	??$LDr$r@$05$02@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LDr$r<6,3>
PUBLIC	??$LDrr@$05$00@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<6,1>
PUBLIC	??$LD$rr@$02$02@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD$rr<3,3>
PUBLIC	??$LD$rr@$02$01@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD$rr<3,2>
PUBLIC	??$LD$rr@$02$04@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD$rr<3,5>
PUBLIC	??$LD$rr@$02$03@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD$rr<3,4>
PUBLIC	??$LD$rr@$02$06@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD$rr<3,7>
PUBLIC	??$LD$rr@$02$05@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD$rr<3,6>
PUBLIC	??$LD$rr@$02$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD$rr<3,1>
PUBLIC	??$LDrr@$00$02@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<1,3>
PUBLIC	??$LDrr@$00$01@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<1,2>
PUBLIC	??$LDrr@$00$04@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<1,5>
PUBLIC	??$LDrr@$00$03@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<1,4>
PUBLIC	??$LDrr@$00$06@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<1,7>
PUBLIC	??$LDrr@$00$05@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<1,6>
PUBLIC	??$LDr$r@$00$02@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LDr$r<1,3>
PUBLIC	??$LDrr@$00$00@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::LDrr<1,1>
PUBLIC	??$ADD@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADD<1,3,0>
PUBLIC	??$ADD@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADD<1,2,0>
PUBLIC	??$ADD@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADD<1,5,0>
PUBLIC	??$ADD@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADD<1,4,0>
PUBLIC	??$ADD@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADD<1,7,0>
PUBLIC	??$ADD@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADD<1,6,0>
PUBLIC	??$ADD@$00$02$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADD<1,3,1>
PUBLIC	??$ADD@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADD<1,1,0>
PUBLIC	??$ADC@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADC<1,3,0>
PUBLIC	??$ADC@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADC<1,2,0>
PUBLIC	??$ADC@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADC<1,5,0>
PUBLIC	??$ADC@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADC<1,4,0>
PUBLIC	??$ADC@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADC<1,7,0>
PUBLIC	??$ADC@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADC<1,6,0>
PUBLIC	??$ADC@$00$02$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADC<1,3,1>
PUBLIC	??$ADC@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADC<1,1,0>
PUBLIC	??$SUB@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SUB<1,3,0>
PUBLIC	??$SUB@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SUB<1,2,0>
PUBLIC	??$SUB@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SUB<1,5,0>
PUBLIC	??$SUB@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SUB<1,4,0>
PUBLIC	??$SUB@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SUB<1,7,0>
PUBLIC	??$SUB@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SUB<1,6,0>
PUBLIC	??$SUB@$00$02$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SUB<1,3,1>
PUBLIC	??$SUB@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SUB<1,1,0>
PUBLIC	??$SBC@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SBC<1,3,0>
PUBLIC	??$SBC@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SBC<1,2,0>
PUBLIC	??$SBC@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SBC<1,5,0>
PUBLIC	??$SBC@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SBC<1,4,0>
PUBLIC	??$SBC@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SBC<1,7,0>
PUBLIC	??$SBC@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SBC<1,6,0>
PUBLIC	??$SBC@$00$02$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SBC<1,3,1>
PUBLIC	??$SBC@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SBC<1,1,0>
PUBLIC	??$AND@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::AND<1,3,0>
PUBLIC	??$AND@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::AND<1,2,0>
PUBLIC	??$AND@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::AND<1,5,0>
PUBLIC	??$AND@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::AND<1,4,0>
PUBLIC	??$AND@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::AND<1,7,0>
PUBLIC	??$AND@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::AND<1,6,0>
PUBLIC	??$AND@$00$02$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::AND<1,3,1>
PUBLIC	??$AND@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::AND<1,1,0>
PUBLIC	??$XOR@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::XOR<1,3,0>
PUBLIC	??$XOR@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::XOR<1,2,0>
PUBLIC	??$XOR@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::XOR<1,5,0>
PUBLIC	??$XOR@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::XOR<1,4,0>
PUBLIC	??$XOR@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::XOR<1,7,0>
PUBLIC	??$XOR@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::XOR<1,6,0>
PUBLIC	??$XOR@$00$02$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::XOR<1,3,1>
PUBLIC	??$XOR@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::XOR<1,1,0>
PUBLIC	??$OR@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::OR<1,3,0>
PUBLIC	??$OR@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::OR<1,2,0>
PUBLIC	??$OR@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::OR<1,5,0>
PUBLIC	??$OR@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::OR<1,4,0>
PUBLIC	??$OR@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::OR<1,7,0>
PUBLIC	??$OR@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::OR<1,6,0>
PUBLIC	??$OR@$00$02$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::OR<1,3,1>
PUBLIC	??$OR@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::OR<1,1,0>
PUBLIC	??$CP_reg@$02@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::CP_reg<3>
PUBLIC	??$CP_reg@$01@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::CP_reg<2>
PUBLIC	??$CP_reg@$04@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::CP_reg<5>
PUBLIC	??$CP_reg@$03@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::CP_reg<4>
PUBLIC	??$CP_reg@$06@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::CP_reg<7>
PUBLIC	??$CP_reg@$05@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::CP_reg<6>
PUBLIC	??$CP_reg@$00@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::CP_reg<1>
PUBLIC	??$RET_cc@$06$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::RET_cc<7,1>
PUBLIC	??$POP@$00@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::POP<1>
PUBLIC	??$JP_cc@$06$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::JP_cc<7,1>
PUBLIC	??$CALL_cc@$06$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::CALL_cc<7,1>
PUBLIC	??$PUSH@$00@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::PUSH<1>
PUBLIC	??$ADD@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADD<1,0,2>
PUBLIC	??$RET_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::RET_cc<7,0>
PUBLIC	??$JP_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::JP_cc<7,0>
PUBLIC	??$CALL_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::CALL_cc<7,0>
PUBLIC	??$ADC@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::ADC<1,0,2>
PUBLIC	??$RET_cc@$03$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::RET_cc<4,1>
PUBLIC	??$POP@$01@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::POP<2>
PUBLIC	??$JP_cc@$03$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::JP_cc<4,1>
PUBLIC	??$CALL_cc@$03$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::CALL_cc<4,1>
PUBLIC	??$PUSH@$01@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::PUSH<2>
PUBLIC	??$SUB@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SUB<1,0,2>
PUBLIC	??$RET_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::RET_cc<4,0>
PUBLIC	??$JP_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::JP_cc<4,0>
PUBLIC	??$CALL_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::CALL_cc<4,0>
PUBLIC	??$SBC@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::SBC<1,0,2>
PUBLIC	??$LD@$0A@$00$0M@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD<0,1,12>
PUBLIC	??$POP@$02@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::POP<3>
PUBLIC	??$LD$FF00rr@$01$00@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD$FF00rr<2,1>
PUBLIC	??$PUSH@$02@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::PUSH<3>
PUBLIC	??$AND@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::AND<1,0,2>
PUBLIC	??$LD@$0A@$00$0O@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD<0,1,14>
PUBLIC	??$XOR@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::XOR<1,0,2>
PUBLIC	??$LD@$00$0A@$0N@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD<1,0,13>
PUBLIC	??$POP@$0A@@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::POP<0>
PUBLIC	??$LDr$FF00r@$00$01@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LDr$FF00r<1,2>
PUBLIC	??$PUSH@$0A@@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::PUSH<0>
PUBLIC	??$OR@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::OR<1,0,2>
PUBLIC	??$LD@$00$0A@$0P@@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::LD<1,0,15>
PUBLIC	??$arithmeticMode@$00$02$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,0>
PUBLIC	??$arithmeticMode@$00$01$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,2,0>
PUBLIC	??$arithmeticMode@$00$04$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,5,0>
PUBLIC	??$arithmeticMode@$00$03$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,4,0>
PUBLIC	??$arithmeticMode@$00$06$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,7,0>
PUBLIC	??$arithmeticMode@$00$05$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,6,0>
PUBLIC	??$arithmeticMode@$00$02$00@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,1>
PUBLIC	??$arithmeticMode@$00$00$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,1,0>
PUBLIC	??$arithmeticMode@$00$0A@$01@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,0,2>
PUBLIC	??_7Component@gb@emulation@@6B@			; emulation::gb::Component::`vftable'
PUBLIC	??_7Cpu@gb@emulation@@6B@			; emulation::gb::Cpu::`vftable'
PUBLIC	??_R1A@?0A@EA@Component@gb@emulation@@8		; emulation::gb::Component::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVComponent@gb@emulation@@@8		; emulation::gb::Component `RTTI Type Descriptor'
PUBLIC	??_R3Component@gb@emulation@@8			; emulation::gb::Component::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Component@gb@emulation@@8			; emulation::gb::Component::`RTTI Base Class Array'
PUBLIC	??_R4Cpu@gb@emulation@@6B@			; emulation::gb::Cpu::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCpu@gb@emulation@@@8			; emulation::gb::Cpu `RTTI Type Descriptor'
PUBLIC	??_R3Cpu@gb@emulation@@8			; emulation::gb::Cpu::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Cpu@gb@emulation@@8			; emulation::gb::Cpu::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Cpu@gb@emulation@@8		; emulation::gb::Cpu::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Component@gb@emulation@@6B@		; emulation::gb::Component::`RTTI Complete Object Locator'
EXTRN	_memset:PROC
EXTRN	?Read8@Memory@gb@emulation@@QAEEG@Z:PROC	; emulation::gb::Memory::Read8
EXTRN	?Write8@Memory@gb@emulation@@QAEXGE@Z:PROC	; emulation::gb::Memory::Write8
EXTRN	?Tick@Memory@gb@emulation@@QAEXXZ:PROC		; emulation::gb::Memory::Tick
EXTRN	?Step@LCDDriver@gb@emulation@@QAEXN@Z:PROC	; emulation::gb::LCDDriver::Step
EXTRN	?Step@SoundController@gb@emulation@@QAEXN@Z:PROC ; emulation::gb::SoundController::Step
EXTRN	?Tick@Timer@gb@emulation@@QAEXXZ:PROC		; emulation::gb::Timer::Tick
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_ignore	DB	01H DUP (?)
__Tuple_alloc DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R4Component@gb@emulation@@6B@
rdata$r	SEGMENT
??_R4Component@gb@emulation@@6B@ DD 00H			; emulation::gb::Component::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVComponent@gb@emulation@@@8
	DD	FLAT:??_R3Component@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Cpu@gb@emulation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Cpu@gb@emulation@@8 DD FLAT:??_R0?AVCpu@gb@emulation@@@8 ; emulation::gb::Cpu::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Cpu@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R2Cpu@gb@emulation@@8
rdata$r	SEGMENT
??_R2Cpu@gb@emulation@@8 DD FLAT:??_R1A@?0A@EA@Cpu@gb@emulation@@8 ; emulation::gb::Cpu::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Component@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R3Cpu@gb@emulation@@8
rdata$r	SEGMENT
??_R3Cpu@gb@emulation@@8 DD 00H				; emulation::gb::Cpu::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Cpu@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCpu@gb@emulation@@@8
_DATA	SEGMENT
??_R0?AVCpu@gb@emulation@@@8 DD FLAT:??_7type_info@@6B@	; emulation::gb::Cpu `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCpu@gb@emulation@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Cpu@gb@emulation@@6B@
rdata$r	SEGMENT
??_R4Cpu@gb@emulation@@6B@ DD 00H			; emulation::gb::Cpu::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCpu@gb@emulation@@@8
	DD	FLAT:??_R3Cpu@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R2Component@gb@emulation@@8
rdata$r	SEGMENT
??_R2Component@gb@emulation@@8 DD FLAT:??_R1A@?0A@EA@Component@gb@emulation@@8 ; emulation::gb::Component::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Component@gb@emulation@@8
rdata$r	SEGMENT
??_R3Component@gb@emulation@@8 DD 00H			; emulation::gb::Component::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Component@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVComponent@gb@emulation@@@8
_DATA	SEGMENT
??_R0?AVComponent@gb@emulation@@@8 DD FLAT:??_7type_info@@6B@ ; emulation::gb::Component `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVComponent@gb@emulation@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@Component@gb@emulation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Component@gb@emulation@@8 DD FLAT:??_R0?AVComponent@gb@emulation@@@8 ; emulation::gb::Component::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Component@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_7Cpu@gb@emulation@@6B@
CONST	SEGMENT
??_7Cpu@gb@emulation@@6B@ DD FLAT:??_R4Cpu@gb@emulation@@6B@ ; emulation::gb::Cpu::`vftable'
	DD	FLAT:?Initialize@Cpu@gb@emulation@@UAEXPAVEmu@23@@Z
	DD	FLAT:?Deinitialize@Cpu@gb@emulation@@UAEXXZ
	DD	FLAT:?Reset@Cpu@gb@emulation@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7Component@gb@emulation@@6B@
CONST	SEGMENT
??_7Component@gb@emulation@@6B@ DD FLAT:??_R4Component@gb@emulation@@6B@ ; emulation::gb::Component::`vftable'
	DD	FLAT:?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z
	DD	FLAT:?Deinitialize@Component@gb@emulation@@UAEXXZ
	DD	FLAT:?Reset@Component@gb@emulation@@UAEXXZ
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ??$arithmeticMode@$00$0A@$01@Cpu@gb@emulation@@AAEXAAE0@Z
_TEXT	SEGMENT
tv133 = -6						; size = 2
_this$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$arithmeticMode@$00$0A@$01@Cpu@gb@emulation@@AAEXAAE0@Z PROC ; emulation::gb::Cpu::arithmeticMode<1,0,2>, COMDAT
; _this$ = ecx

; 124  :   void arithmeticMode(uint8_t& a, uint8_t& b) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	  if (mode == 0) {

	xor	eax, eax
	je	SHORT $LN5@arithmetic

; 126  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 127  :       b = reg.raw8[src];

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+edx+1064]
	mov	BYTE PTR [eax], dl
	jmp	$LN6@arithmetic
$LN5@arithmetic:

; 128  :     } else if (mode == 1) {

	xor	eax, eax
	je	SHORT $LN3@arithmetic

; 129  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 130  :       b = mem_->Read8(reg.raw16[src]);

	mov	edx, 2
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN6@arithmetic
$LN3@arithmetic:

; 131  :     } else if (mode == 2) {

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN6@arithmetic

; 132  :       a = reg.raw8[dest];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+eax+1064]
	mov	BYTE PTR [ecx], al

; 133  :       b = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv133[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv133[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [edx], al
$LN6@arithmetic:

; 134  :     }
; 135  :   }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$arithmeticMode@$00$0A@$01@Cpu@gb@emulation@@AAEXAAE0@Z ENDP ; emulation::gb::Cpu::arithmeticMode<1,0,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ??$arithmeticMode@$00$00$0A@@Cpu@gb@emulation@@AAEXAAE0@Z
_TEXT	SEGMENT
tv133 = -6						; size = 2
_this$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$arithmeticMode@$00$00$0A@@Cpu@gb@emulation@@AAEXAAE0@Z PROC ; emulation::gb::Cpu::arithmeticMode<1,1,0>, COMDAT
; _this$ = ecx

; 124  :   void arithmeticMode(uint8_t& a, uint8_t& b) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	  if (mode == 0) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@arithmetic

; 126  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 127  :       b = reg.raw8[src];

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+edx+1064]
	mov	BYTE PTR [eax], dl
	jmp	$LN6@arithmetic
$LN5@arithmetic:

; 128  :     } else if (mode == 1) {

	xor	eax, eax
	je	SHORT $LN3@arithmetic

; 129  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 130  :       b = mem_->Read8(reg.raw16[src]);

	mov	edx, 2
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN6@arithmetic
$LN3@arithmetic:

; 131  :     } else if (mode == 2) {

	xor	edx, edx
	je	SHORT $LN6@arithmetic

; 132  :       a = reg.raw8[dest];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+eax+1064]
	mov	BYTE PTR [ecx], al

; 133  :       b = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv133[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv133[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [edx], al
$LN6@arithmetic:

; 134  :     }
; 135  :   }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$arithmeticMode@$00$00$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ENDP ; emulation::gb::Cpu::arithmeticMode<1,1,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ??$arithmeticMode@$00$02$00@Cpu@gb@emulation@@AAEXAAE0@Z
_TEXT	SEGMENT
tv133 = -6						; size = 2
_this$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$arithmeticMode@$00$02$00@Cpu@gb@emulation@@AAEXAAE0@Z PROC ; emulation::gb::Cpu::arithmeticMode<1,3,1>, COMDAT
; _this$ = ecx

; 124  :   void arithmeticMode(uint8_t& a, uint8_t& b) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	  if (mode == 0) {

	xor	eax, eax
	je	SHORT $LN5@arithmetic

; 126  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 127  :       b = reg.raw8[src];

	mov	edx, 1
	imul	edx, 3
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+edx+1064]
	mov	BYTE PTR [eax], dl
	jmp	$LN6@arithmetic
$LN5@arithmetic:

; 128  :     } else if (mode == 1) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@arithmetic

; 129  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 130  :       b = mem_->Read8(reg.raw16[src]);

	mov	edx, 2
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN6@arithmetic
$LN3@arithmetic:

; 131  :     } else if (mode == 2) {

	xor	edx, edx
	je	SHORT $LN6@arithmetic

; 132  :       a = reg.raw8[dest];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+eax+1064]
	mov	BYTE PTR [ecx], al

; 133  :       b = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv133[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv133[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [edx], al
$LN6@arithmetic:

; 134  :     }
; 135  :   }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$arithmeticMode@$00$02$00@Cpu@gb@emulation@@AAEXAAE0@Z ENDP ; emulation::gb::Cpu::arithmeticMode<1,3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ??$arithmeticMode@$00$05$0A@@Cpu@gb@emulation@@AAEXAAE0@Z
_TEXT	SEGMENT
tv133 = -6						; size = 2
_this$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$arithmeticMode@$00$05$0A@@Cpu@gb@emulation@@AAEXAAE0@Z PROC ; emulation::gb::Cpu::arithmeticMode<1,6,0>, COMDAT
; _this$ = ecx

; 124  :   void arithmeticMode(uint8_t& a, uint8_t& b) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	  if (mode == 0) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@arithmetic

; 126  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 127  :       b = reg.raw8[src];

	mov	edx, 1
	imul	edx, 6
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+edx+1064]
	mov	BYTE PTR [eax], dl
	jmp	$LN6@arithmetic
$LN5@arithmetic:

; 128  :     } else if (mode == 1) {

	xor	eax, eax
	je	SHORT $LN3@arithmetic

; 129  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 130  :       b = mem_->Read8(reg.raw16[src]);

	mov	edx, 2
	imul	edx, 6
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN6@arithmetic
$LN3@arithmetic:

; 131  :     } else if (mode == 2) {

	xor	edx, edx
	je	SHORT $LN6@arithmetic

; 132  :       a = reg.raw8[dest];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+eax+1064]
	mov	BYTE PTR [ecx], al

; 133  :       b = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv133[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv133[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [edx], al
$LN6@arithmetic:

; 134  :     }
; 135  :   }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$arithmeticMode@$00$05$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ENDP ; emulation::gb::Cpu::arithmeticMode<1,6,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ??$arithmeticMode@$00$06$0A@@Cpu@gb@emulation@@AAEXAAE0@Z
_TEXT	SEGMENT
tv133 = -6						; size = 2
_this$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$arithmeticMode@$00$06$0A@@Cpu@gb@emulation@@AAEXAAE0@Z PROC ; emulation::gb::Cpu::arithmeticMode<1,7,0>, COMDAT
; _this$ = ecx

; 124  :   void arithmeticMode(uint8_t& a, uint8_t& b) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	  if (mode == 0) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@arithmetic

; 126  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 127  :       b = reg.raw8[src];

	mov	edx, 1
	imul	edx, 7
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+edx+1064]
	mov	BYTE PTR [eax], dl
	jmp	$LN6@arithmetic
$LN5@arithmetic:

; 128  :     } else if (mode == 1) {

	xor	eax, eax
	je	SHORT $LN3@arithmetic

; 129  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 130  :       b = mem_->Read8(reg.raw16[src]);

	mov	edx, 2
	imul	edx, 7
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN6@arithmetic
$LN3@arithmetic:

; 131  :     } else if (mode == 2) {

	xor	edx, edx
	je	SHORT $LN6@arithmetic

; 132  :       a = reg.raw8[dest];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+eax+1064]
	mov	BYTE PTR [ecx], al

; 133  :       b = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv133[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv133[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [edx], al
$LN6@arithmetic:

; 134  :     }
; 135  :   }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$arithmeticMode@$00$06$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ENDP ; emulation::gb::Cpu::arithmeticMode<1,7,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ??$arithmeticMode@$00$03$0A@@Cpu@gb@emulation@@AAEXAAE0@Z
_TEXT	SEGMENT
tv133 = -6						; size = 2
_this$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$arithmeticMode@$00$03$0A@@Cpu@gb@emulation@@AAEXAAE0@Z PROC ; emulation::gb::Cpu::arithmeticMode<1,4,0>, COMDAT
; _this$ = ecx

; 124  :   void arithmeticMode(uint8_t& a, uint8_t& b) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	  if (mode == 0) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@arithmetic

; 126  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 127  :       b = reg.raw8[src];

	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+edx+1064]
	mov	BYTE PTR [eax], dl
	jmp	$LN6@arithmetic
$LN5@arithmetic:

; 128  :     } else if (mode == 1) {

	xor	eax, eax
	je	SHORT $LN3@arithmetic

; 129  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 130  :       b = mem_->Read8(reg.raw16[src]);

	mov	edx, 2
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN6@arithmetic
$LN3@arithmetic:

; 131  :     } else if (mode == 2) {

	xor	edx, edx
	je	SHORT $LN6@arithmetic

; 132  :       a = reg.raw8[dest];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+eax+1064]
	mov	BYTE PTR [ecx], al

; 133  :       b = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv133[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv133[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [edx], al
$LN6@arithmetic:

; 134  :     }
; 135  :   }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$arithmeticMode@$00$03$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ENDP ; emulation::gb::Cpu::arithmeticMode<1,4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ??$arithmeticMode@$00$04$0A@@Cpu@gb@emulation@@AAEXAAE0@Z
_TEXT	SEGMENT
tv133 = -6						; size = 2
_this$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$arithmeticMode@$00$04$0A@@Cpu@gb@emulation@@AAEXAAE0@Z PROC ; emulation::gb::Cpu::arithmeticMode<1,5,0>, COMDAT
; _this$ = ecx

; 124  :   void arithmeticMode(uint8_t& a, uint8_t& b) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	  if (mode == 0) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@arithmetic

; 126  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 127  :       b = reg.raw8[src];

	mov	edx, 1
	imul	edx, 5
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+edx+1064]
	mov	BYTE PTR [eax], dl
	jmp	$LN6@arithmetic
$LN5@arithmetic:

; 128  :     } else if (mode == 1) {

	xor	eax, eax
	je	SHORT $LN3@arithmetic

; 129  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 130  :       b = mem_->Read8(reg.raw16[src]);

	mov	edx, 2
	imul	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN6@arithmetic
$LN3@arithmetic:

; 131  :     } else if (mode == 2) {

	xor	edx, edx
	je	SHORT $LN6@arithmetic

; 132  :       a = reg.raw8[dest];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+eax+1064]
	mov	BYTE PTR [ecx], al

; 133  :       b = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv133[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv133[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [edx], al
$LN6@arithmetic:

; 134  :     }
; 135  :   }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$arithmeticMode@$00$04$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ENDP ; emulation::gb::Cpu::arithmeticMode<1,5,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ??$arithmeticMode@$00$01$0A@@Cpu@gb@emulation@@AAEXAAE0@Z
_TEXT	SEGMENT
tv133 = -6						; size = 2
_this$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$arithmeticMode@$00$01$0A@@Cpu@gb@emulation@@AAEXAAE0@Z PROC ; emulation::gb::Cpu::arithmeticMode<1,2,0>, COMDAT
; _this$ = ecx

; 124  :   void arithmeticMode(uint8_t& a, uint8_t& b) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	  if (mode == 0) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@arithmetic

; 126  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 127  :       b = reg.raw8[src];

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+edx+1064]
	mov	BYTE PTR [eax], dl
	jmp	$LN6@arithmetic
$LN5@arithmetic:

; 128  :     } else if (mode == 1) {

	xor	eax, eax
	je	SHORT $LN3@arithmetic

; 129  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 130  :       b = mem_->Read8(reg.raw16[src]);

	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN6@arithmetic
$LN3@arithmetic:

; 131  :     } else if (mode == 2) {

	xor	edx, edx
	je	SHORT $LN6@arithmetic

; 132  :       a = reg.raw8[dest];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+eax+1064]
	mov	BYTE PTR [ecx], al

; 133  :       b = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv133[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv133[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [edx], al
$LN6@arithmetic:

; 134  :     }
; 135  :   }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$arithmeticMode@$00$01$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ENDP ; emulation::gb::Cpu::arithmeticMode<1,2,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ??$arithmeticMode@$00$02$0A@@Cpu@gb@emulation@@AAEXAAE0@Z
_TEXT	SEGMENT
tv133 = -6						; size = 2
_this$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$arithmeticMode@$00$02$0A@@Cpu@gb@emulation@@AAEXAAE0@Z PROC ; emulation::gb::Cpu::arithmeticMode<1,3,0>, COMDAT
; _this$ = ecx

; 124  :   void arithmeticMode(uint8_t& a, uint8_t& b) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	  if (mode == 0) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@arithmetic

; 126  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 127  :       b = reg.raw8[src];

	mov	edx, 1
	imul	edx, 3
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+edx+1064]
	mov	BYTE PTR [eax], dl
	jmp	$LN6@arithmetic
$LN5@arithmetic:

; 128  :     } else if (mode == 1) {

	xor	eax, eax
	je	SHORT $LN3@arithmetic

; 129  :       a = reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1064]
	mov	BYTE PTR [edx], cl

; 130  :       b = mem_->Read8(reg.raw16[src]);

	mov	edx, 2
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN6@arithmetic
$LN3@arithmetic:

; 131  :     } else if (mode == 2) {

	xor	edx, edx
	je	SHORT $LN6@arithmetic

; 132  :       a = reg.raw8[dest];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+eax+1064]
	mov	BYTE PTR [ecx], al

; 133  :       b = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv133[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv133[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [edx], al
$LN6@arithmetic:

; 134  :     }
; 135  :   }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$arithmeticMode@$00$02$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ENDP ; emulation::gb::Cpu::arithmeticMode<1,3,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r$ = 8							; size = 1
??R<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QBEXE@Z PROC ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::operator()
; _this$ = ecx

; 656  :   auto setr = [=](uint8_t r) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 657  :     if ((code&0x7) != 6) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 7
	cmp	ecx, 6
	je	SHORT $LN2@operator

; 658  :       reg.raw8[reg_index[code&0x7]] = r;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 7
	mov	ecx, DWORD PTR _reg_index[edx*4]
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 659  :     } else {

	jmp	SHORT $LN3@operator
$LN2@operator:

; 660  :       mem_->Write8(reg.HL,r);

	movzx	eax, BYTE PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, WORD PTR [edx+1070]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
$LN3@operator:

; 661  :     }
; 662  :   };

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??R<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QBEXE@Z ENDP ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Code$ = 8						; size = 4
__This$ = 12						; size = 4
??0<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QAE@ABEPAVCpu@gb@emulation@@@Z PROC ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::<lambda_08bfd30db2c73e418a55b8072ee85de7>
; _this$ = ecx

; 662  :   };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Code$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __This$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QAE@ABEPAVCpu@gb@emulation@@@Z ENDP ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::<lambda_08bfd30db2c73e418a55b8072ee85de7>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??R<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QBEEXZ PROC ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::operator()
; _this$ = ecx

; 647  :   auto getr = [=]() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 648  :     if ((code&0x7) != 6) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 7
	cmp	ecx, 6
	je	SHORT $LN2@operator

; 649  :       return reg.raw8[reg_index[code&0x7]];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 7
	mov	ecx, DWORD PTR _reg_index[edx*4]
	mov	al, BYTE PTR [eax+ecx+1064]
	jmp	SHORT $LN3@operator

; 650  :     } else {

	jmp	SHORT $LN3@operator
$LN2@operator:

; 651  : 
; 652  :       return mem_->Read8(reg.HL);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
$LN3@operator:

; 653  :     }
; 654  :   };

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QBEEXZ ENDP ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Code$ = 8						; size = 4
__This$ = 12						; size = 4
??0<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QAE@ABEPAVCpu@gb@emulation@@@Z PROC ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>
; _this$ = ecx

; 654  :   };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Code$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __This$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QAE@ABEPAVCpu@gb@emulation@@@Z ENDP ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD@$00$0A@$0P@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv245 = -32						; size = 2
tv232 = -30						; size = 2
tv206 = -28						; size = 2
tv193 = -26						; size = 2
tv169 = -24						; size = 2
tv145 = -22						; size = 2
tv92 = -20						; size = 2
tv79 = -18						; size = 2
_d16$1 = -16						; size = 2
_d16$2 = -12						; size = 2
_a8$3 = -7						; size = 1
_a8$4 = -6						; size = 1
_d8$5 = -5						; size = 1
_this$ = -4						; size = 4
??$LD@$00$0A@$0P@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD<1,0,15>, COMDAT
; _this$ = ecx

; 446  : void Cpu::LD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 447  :   if (mode == 10) { //dest,d8

	xor	eax, eax
	je	SHORT $LN11@LD

; 448  : 		reg.raw8[dest] = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv79[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN11@LD:

; 449  : 	}else if (mode == 11) { //(dest),d8

	xor	edx, edx
	je	SHORT $LN9@LD

; 450  : 		auto d8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _d8$5[ebp], al

; 451  : 		mem_->Write8(reg.raw16[dest],d8);

	movzx	ecx, BYTE PTR _d8$5[ebp]
	push	ecx
	mov	edx, 2
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN9@LD:

; 452  : 	} else if (mode == 12) { //0xFF00+d8 src

	xor	eax, eax
	je	SHORT $LN7@LD

; 453  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv145[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$4[ebp], al

; 454  : 		mem_->Write8(0xFF00+a8,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, BYTE PTR _a8$4[ebp]
	add	edx, 65280				; 0000ff00H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN7@LD:

; 455  : 	} else if (mode == 13) { //dest,0xFF00+d8 

	xor	ecx, ecx
	je	SHORT $LN5@LD

; 456  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv169[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv169[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$3[ebp], al

; 457  : 		reg.raw8[dest] = mem_->Read8(0xFF00+a8);

	movzx	eax, BYTE PTR _a8$3[ebp]
	add	eax, 65280				; 0000ff00H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN5@LD:

; 458  : 	} else if (mode == 14) { //(d16),src

	xor	edx, edx
	je	$LN3@LD

; 459  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv193[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv193[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _d16$2[ebp], cx

; 460  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv206[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv206[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _d16$2[ebp]
	or	ecx, eax
	mov	WORD PTR _d16$2[ebp], cx

; 461  :     mem_->Write8(d16,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, WORD PTR _d16$2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN3@LD:

; 462  : 	} else if (mode == 15) { //src,(d16)

	mov	ecx, 1
	test	ecx, ecx
	je	$LN12@LD

; 463  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv232[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv232[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	ax, al
	mov	WORD PTR _d16$1[ebp], ax

; 464  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv245[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	movzx	eax, WORD PTR _d16$1[ebp]
	or	eax, edx
	mov	WORD PTR _d16$1[ebp], ax

; 465  :     reg.raw8[dest] = mem_->Read8(d16);

	movzx	ecx, WORD PTR _d16$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al
$LN12@LD:

; 466  : 	}
; 467  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD@$00$0A@$0P@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD<1,0,15>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$OR@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$OR@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::OR<1,0,2>, COMDAT
; _this$ = ecx

; 608  : void Cpu::OR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 609  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 610  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 611  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$0A@$01@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,0,2>

; 612  :   reg.raw8[dest] = a | b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	or	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 613  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 614  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@OR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@OR:
	DD	2
	DD	$LN5@OR
$LN5@OR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@OR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@OR
$LN4@OR:
	DB	98					; 00000062H
	DB	0
$LN3@OR:
	DB	97					; 00000061H
	DB	0
??$OR@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::OR<1,0,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$PUSH@$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$PUSH@$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::PUSH<0>, COMDAT
; _this$ = ecx

; 903  : void Cpu::PUSH() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 904  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 905  :   push(reg.raw16[src]>>8);

	mov	eax, 2
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	sar	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@Cpu@gb@emulation@@AAEXE@Z		; emulation::gb::Cpu::push

; 906  :   push(reg.raw16[src]&0xFF);

	mov	eax, 2
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	and	edx, 255				; 000000ffH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@Cpu@gb@emulation@@AAEXE@Z		; emulation::gb::Cpu::push

; 907  :   Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 908  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$PUSH@$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::PUSH<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDr$FF00r@$00$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDr$FF00r@$00$01@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::LDr$FF00r<1,2>, COMDAT
; _this$ = ecx

; 407  : void Cpu::LDr$FF00r() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 408  : 	reg.raw8[dest] = mem_->Read8(0xFF00+reg.raw8[src]);

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	add	edx, 65280				; 0000ff00H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 409  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDr$FF00r@$00$01@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::LDr$FF00r<1,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$POP@$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$POP@$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::POP<0>, COMDAT
; _this$ = ecx

; 911  : void Cpu::POP() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 912  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 913  :   reg.raw16[dest] = pop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@Cpu@gb@emulation@@AAEEXZ		; emulation::gb::Cpu::pop
	movzx	ax, al
	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx+1064], ax

; 914  :   reg.raw16[dest] |= pop() << 8;

	mov	esi, 2
	imul	esi, 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@Cpu@gb@emulation@@AAEEXZ		; emulation::gb::Cpu::pop
	movzx	eax, al
	shl	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+esi+1064]
	or	edx, eax
	mov	eax, 2
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax+1064], dx

; 915  :   if (dest == RegAF)

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN2@POP

; 916  :     reg.F._unused = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 240					; 000000f0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
$LN2@POP:

; 917  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$POP@$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::POP<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD@$00$0A@$0N@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv245 = -32						; size = 2
tv232 = -30						; size = 2
tv206 = -28						; size = 2
tv193 = -26						; size = 2
tv169 = -24						; size = 2
tv145 = -22						; size = 2
tv92 = -20						; size = 2
tv79 = -18						; size = 2
_d16$1 = -16						; size = 2
_d16$2 = -12						; size = 2
_a8$3 = -7						; size = 1
_a8$4 = -6						; size = 1
_d8$5 = -5						; size = 1
_this$ = -4						; size = 4
??$LD@$00$0A@$0N@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD<1,0,13>, COMDAT
; _this$ = ecx

; 446  : void Cpu::LD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 447  :   if (mode == 10) { //dest,d8

	xor	eax, eax
	je	SHORT $LN11@LD

; 448  : 		reg.raw8[dest] = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv79[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN11@LD:

; 449  : 	}else if (mode == 11) { //(dest),d8

	xor	edx, edx
	je	SHORT $LN9@LD

; 450  : 		auto d8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _d8$5[ebp], al

; 451  : 		mem_->Write8(reg.raw16[dest],d8);

	movzx	ecx, BYTE PTR _d8$5[ebp]
	push	ecx
	mov	edx, 2
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN9@LD:

; 452  : 	} else if (mode == 12) { //0xFF00+d8 src

	xor	eax, eax
	je	SHORT $LN7@LD

; 453  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv145[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$4[ebp], al

; 454  : 		mem_->Write8(0xFF00+a8,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, BYTE PTR _a8$4[ebp]
	add	edx, 65280				; 0000ff00H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN7@LD:

; 455  : 	} else if (mode == 13) { //dest,0xFF00+d8 

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN5@LD

; 456  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv169[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv169[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$3[ebp], al

; 457  : 		reg.raw8[dest] = mem_->Read8(0xFF00+a8);

	movzx	eax, BYTE PTR _a8$3[ebp]
	add	eax, 65280				; 0000ff00H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN5@LD:

; 458  : 	} else if (mode == 14) { //(d16),src

	xor	edx, edx
	je	$LN3@LD

; 459  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv193[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv193[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _d16$2[ebp], cx

; 460  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv206[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv206[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _d16$2[ebp]
	or	ecx, eax
	mov	WORD PTR _d16$2[ebp], cx

; 461  :     mem_->Write8(d16,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, WORD PTR _d16$2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN3@LD:

; 462  : 	} else if (mode == 15) { //src,(d16)

	xor	ecx, ecx
	je	$LN12@LD

; 463  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv232[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv232[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	ax, al
	mov	WORD PTR _d16$1[ebp], ax

; 464  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv245[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	movzx	eax, WORD PTR _d16$1[ebp]
	or	eax, edx
	mov	WORD PTR _d16$1[ebp], ax

; 465  :     reg.raw8[dest] = mem_->Read8(d16);

	movzx	ecx, WORD PTR _d16$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al
$LN12@LD:

; 466  : 	}
; 467  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD@$00$0A@$0N@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD<1,0,13>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$XOR@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$XOR@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::XOR<1,0,2>, COMDAT
; _this$ = ecx

; 599  : void Cpu::XOR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 600  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 601  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 602  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$0A@$01@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,0,2>

; 603  :   reg.raw8[dest] = a ^ b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	xor	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 604  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 605  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@XOR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@XOR:
	DD	2
	DD	$LN5@XOR
$LN5@XOR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@XOR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@XOR
$LN4@XOR:
	DB	98					; 00000062H
	DB	0
$LN3@XOR:
	DB	97					; 00000061H
	DB	0
??$XOR@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::XOR<1,0,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD@$0A@$00$0O@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv245 = -32						; size = 2
tv232 = -30						; size = 2
tv206 = -28						; size = 2
tv193 = -26						; size = 2
tv169 = -24						; size = 2
tv145 = -22						; size = 2
tv92 = -20						; size = 2
tv79 = -18						; size = 2
_d16$1 = -16						; size = 2
_d16$2 = -12						; size = 2
_a8$3 = -7						; size = 1
_a8$4 = -6						; size = 1
_d8$5 = -5						; size = 1
_this$ = -4						; size = 4
??$LD@$0A@$00$0O@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD<0,1,14>, COMDAT
; _this$ = ecx

; 446  : void Cpu::LD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 447  :   if (mode == 10) { //dest,d8

	xor	eax, eax
	je	SHORT $LN11@LD

; 448  : 		reg.raw8[dest] = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv79[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	imul	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN11@LD:

; 449  : 	}else if (mode == 11) { //(dest),d8

	xor	edx, edx
	je	SHORT $LN9@LD

; 450  : 		auto d8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _d8$5[ebp], al

; 451  : 		mem_->Write8(reg.raw16[dest],d8);

	movzx	ecx, BYTE PTR _d8$5[ebp]
	push	ecx
	mov	edx, 2
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN9@LD:

; 452  : 	} else if (mode == 12) { //0xFF00+d8 src

	xor	eax, eax
	je	SHORT $LN7@LD

; 453  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv145[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$4[ebp], al

; 454  : 		mem_->Write8(0xFF00+a8,reg.raw8[src]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, BYTE PTR _a8$4[ebp]
	add	edx, 65280				; 0000ff00H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN7@LD:

; 455  : 	} else if (mode == 13) { //dest,0xFF00+d8 

	xor	ecx, ecx
	je	SHORT $LN5@LD

; 456  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv169[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv169[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$3[ebp], al

; 457  : 		reg.raw8[dest] = mem_->Read8(0xFF00+a8);

	movzx	eax, BYTE PTR _a8$3[ebp]
	add	eax, 65280				; 0000ff00H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	imul	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN5@LD:

; 458  : 	} else if (mode == 14) { //(d16),src

	mov	edx, 1
	test	edx, edx
	je	$LN3@LD

; 459  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv193[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv193[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _d16$2[ebp], cx

; 460  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv206[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv206[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _d16$2[ebp]
	or	ecx, eax
	mov	WORD PTR _d16$2[ebp], cx

; 461  :     mem_->Write8(d16,reg.raw8[src]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, WORD PTR _d16$2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN3@LD:

; 462  : 	} else if (mode == 15) { //src,(d16)

	xor	ecx, ecx
	je	$LN12@LD

; 463  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv232[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv232[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	ax, al
	mov	WORD PTR _d16$1[ebp], ax

; 464  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv245[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	movzx	eax, WORD PTR _d16$1[ebp]
	or	eax, edx
	mov	WORD PTR _d16$1[ebp], ax

; 465  :     reg.raw8[dest] = mem_->Read8(d16);

	movzx	ecx, WORD PTR _d16$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al
$LN12@LD:

; 466  : 	}
; 467  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD@$0A@$00$0O@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD<0,1,14>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$AND@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$AND@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::AND<1,0,2>, COMDAT
; _this$ = ecx

; 588  : void Cpu::AND() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 589  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 590  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 591  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$0A@$01@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,0,2>

; 592  :   reg.raw8[dest] = a & b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	and	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 593  :   reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 594  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 595  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@AND
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@AND:
	DD	2
	DD	$LN5@AND
$LN5@AND:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@AND
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@AND
$LN4@AND:
	DB	98					; 00000062H
	DB	0
$LN3@AND:
	DB	97					; 00000061H
	DB	0
??$AND@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::AND<1,0,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$PUSH@$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$PUSH@$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::PUSH<3>, COMDAT
; _this$ = ecx

; 903  : void Cpu::PUSH() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 904  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 905  :   push(reg.raw16[src]>>8);

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	sar	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@Cpu@gb@emulation@@AAEXE@Z		; emulation::gb::Cpu::push

; 906  :   push(reg.raw16[src]&0xFF);

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	and	edx, 255				; 000000ffH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@Cpu@gb@emulation@@AAEXE@Z		; emulation::gb::Cpu::push

; 907  :   Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 908  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$PUSH@$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::PUSH<3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD$FF00rr@$01$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LD$FF00rr@$01$00@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::LD$FF00rr<2,1>, COMDAT
; _this$ = ecx

; 402  : void Cpu::LD$FF00rr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 	mem_->Write8(0xFF00+reg.raw8[dest],reg.raw8[src]);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	add	edx, 65280				; 0000ff00H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 404  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD$FF00rr@$01$00@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::LD$FF00rr<2,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$POP@$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$POP@$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::POP<3>, COMDAT
; _this$ = ecx

; 911  : void Cpu::POP() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 912  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 913  :   reg.raw16[dest] = pop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@Cpu@gb@emulation@@AAEEXZ		; emulation::gb::Cpu::pop
	movzx	ax, al
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx+1064], ax

; 914  :   reg.raw16[dest] |= pop() << 8;

	mov	esi, 2
	imul	esi, 3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@Cpu@gb@emulation@@AAEEXZ		; emulation::gb::Cpu::pop
	movzx	eax, al
	shl	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+esi+1064]
	or	edx, eax
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax+1064], dx

; 915  :   if (dest == RegAF)

	xor	edx, edx
	je	SHORT $LN2@POP

; 916  :     reg.F._unused = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 240					; 000000f0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
$LN2@POP:

; 917  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$POP@$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::POP<3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD@$0A@$00$0M@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv245 = -32						; size = 2
tv232 = -30						; size = 2
tv206 = -28						; size = 2
tv193 = -26						; size = 2
tv169 = -24						; size = 2
tv145 = -22						; size = 2
tv92 = -20						; size = 2
tv79 = -18						; size = 2
_d16$1 = -16						; size = 2
_d16$2 = -12						; size = 2
_a8$3 = -7						; size = 1
_a8$4 = -6						; size = 1
_d8$5 = -5						; size = 1
_this$ = -4						; size = 4
??$LD@$0A@$00$0M@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD<0,1,12>, COMDAT
; _this$ = ecx

; 446  : void Cpu::LD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 447  :   if (mode == 10) { //dest,d8

	xor	eax, eax
	je	SHORT $LN11@LD

; 448  : 		reg.raw8[dest] = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv79[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	imul	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN11@LD:

; 449  : 	}else if (mode == 11) { //(dest),d8

	xor	edx, edx
	je	SHORT $LN9@LD

; 450  : 		auto d8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _d8$5[ebp], al

; 451  : 		mem_->Write8(reg.raw16[dest],d8);

	movzx	ecx, BYTE PTR _d8$5[ebp]
	push	ecx
	mov	edx, 2
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN9@LD:

; 452  : 	} else if (mode == 12) { //0xFF00+d8 src

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN7@LD

; 453  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv145[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$4[ebp], al

; 454  : 		mem_->Write8(0xFF00+a8,reg.raw8[src]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, BYTE PTR _a8$4[ebp]
	add	edx, 65280				; 0000ff00H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN7@LD:

; 455  : 	} else if (mode == 13) { //dest,0xFF00+d8 

	xor	ecx, ecx
	je	SHORT $LN5@LD

; 456  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv169[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv169[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$3[ebp], al

; 457  : 		reg.raw8[dest] = mem_->Read8(0xFF00+a8);

	movzx	eax, BYTE PTR _a8$3[ebp]
	add	eax, 65280				; 0000ff00H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	imul	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN5@LD:

; 458  : 	} else if (mode == 14) { //(d16),src

	xor	edx, edx
	je	$LN3@LD

; 459  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv193[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv193[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _d16$2[ebp], cx

; 460  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv206[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv206[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _d16$2[ebp]
	or	ecx, eax
	mov	WORD PTR _d16$2[ebp], cx

; 461  :     mem_->Write8(d16,reg.raw8[src]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, WORD PTR _d16$2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN3@LD:

; 462  : 	} else if (mode == 15) { //src,(d16)

	xor	ecx, ecx
	je	$LN12@LD

; 463  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv232[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv232[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	ax, al
	mov	WORD PTR _d16$1[ebp], ax

; 464  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv245[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	movzx	eax, WORD PTR _d16$1[ebp]
	or	eax, edx
	mov	WORD PTR _d16$1[ebp], ax

; 465  :     reg.raw8[dest] = mem_->Read8(d16);

	movzx	ecx, WORD PTR _d16$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al
$LN12@LD:

; 466  : 	}
; 467  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD@$0A@$00$0M@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD<0,1,12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SBC@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SBC@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SBC<1,0,2>, COMDAT
; _this$ = ecx

; 572  : void Cpu::SBC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 573  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 574  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 575  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$0A@$01@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,0,2>

; 576  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 577  :   reg.raw8[dest] = a - b - carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	sub	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 578  :   updateCpuFlagC(a,carry,1);

	push	1
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 579  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@SBC

; 580  :     updateCpuFlagC(a-carry,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	sub	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN2@SBC:

; 581  :   updateCpuFlagH(a,carry,1);

	push	1
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 582  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@SBC

; 583  :     updateCpuFlagH(a-carry,b,1);

	push	1
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN1@SBC:

; 584  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 585  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@SBC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SBC:
	DD	2
	DD	$LN7@SBC
$LN7@SBC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN5@SBC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN6@SBC
$LN6@SBC:
	DB	98					; 00000062H
	DB	0
$LN5@SBC:
	DB	97					; 00000061H
	DB	0
??$SBC@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SBC<1,0,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$CALL_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv137 = -28						; size = 2
tv92 = -26						; size = 2
_nn$1 = -24						; size = 2
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$CALL_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::CALL_cc<4,0>, COMDAT
; _this$ = ecx

; 869  : void Cpu::CALL_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 870  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 16					; 00000010H
	sar	ecx, 4
	mov	DWORD PTR _table$[ebp], ecx

; 871  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 16					; 00000010H
	sar	eax, 4
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 872  : 
; 873  :   if (table[inv]&1) {

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN2@CALL_cc

; 874  :     CALL();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CALL@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::CALL

; 875  :   } else {

	jmp	$LN3@CALL_cc
$LN2@CALL_cc:

; 876  :     uint16_t nn;
; 877  :     nn = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _nn$1[ebp], cx

; 878  :     nn |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv137[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv137[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _nn$1[ebp]
	or	ecx, eax
	mov	WORD PTR _nn$1[ebp], cx
$LN3@CALL_cc:

; 879  :   }
; 880  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@CALL_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@CALL_cc:
	DD	1
	DD	$LN6@CALL_cc
$LN6@CALL_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@CALL_cc
$LN5@CALL_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$CALL_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::CALL_cc<4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$JP_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv137 = -28						; size = 2
tv92 = -26						; size = 2
_nn$1 = -24						; size = 2
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$JP_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::JP_cc<4,0>, COMDAT
; _this$ = ecx

; 840  : void Cpu::JP_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 841  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 16					; 00000010H
	sar	ecx, 4
	mov	DWORD PTR _table$[ebp], ecx

; 842  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 16					; 00000010H
	sar	eax, 4
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 843  : 
; 844  :   if (table[inv]&1) {

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN2@JP_cc

; 845  :     JP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JP@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::JP

; 846  :   } else {

	jmp	$LN3@JP_cc
$LN2@JP_cc:

; 847  :     uint16_t nn;
; 848  :     nn = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _nn$1[ebp], cx

; 849  :     nn |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv137[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv137[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _nn$1[ebp]
	or	ecx, eax
	mov	WORD PTR _nn$1[ebp], cx
$LN3@JP_cc:

; 850  :   }
; 851  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@JP_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@JP_cc:
	DD	1
	DD	$LN6@JP_cc
$LN6@JP_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@JP_cc
$LN5@JP_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$JP_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::JP_cc<4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$RET_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$RET_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::RET_cc<4,0>, COMDAT
; _this$ = ecx

; 889  : void Cpu::RET_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 890  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 16					; 00000010H
	sar	ecx, 4
	mov	DWORD PTR _table$[ebp], ecx

; 891  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 16					; 00000010H
	sar	eax, 4
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 892  : 
; 893  :   if (table[inv]&1) {

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN1@RET_cc

; 894  :     RET();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RET@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::RET
$LN1@RET_cc:

; 895  :   } else {
; 896  :    
; 897  :   }
; 898  :    Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 899  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@RET_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN7@RET_cc:
	DD	1
	DD	$LN6@RET_cc
$LN6@RET_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@RET_cc
$LN5@RET_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$RET_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::RET_cc<4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SUB@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SUB@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SUB<1,0,2>, COMDAT
; _this$ = ecx

; 561  : void Cpu::SUB() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 562  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 563  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 564  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$0A@$01@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,0,2>

; 565  :   reg.raw8[dest] = a - b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	sub	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 566  :   updateCpuFlagC(a,b,1);

	push	1
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 567  :   updateCpuFlagH(a,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 568  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 569  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SUB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@SUB:
	DD	2
	DD	$LN5@SUB
$LN5@SUB:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@SUB
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@SUB
$LN4@SUB:
	DB	98					; 00000062H
	DB	0
$LN3@SUB:
	DB	97					; 00000061H
	DB	0
??$SUB@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SUB<1,0,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$PUSH@$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$PUSH@$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::PUSH<2>, COMDAT
; _this$ = ecx

; 903  : void Cpu::PUSH() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 904  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 905  :   push(reg.raw16[src]>>8);

	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	sar	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@Cpu@gb@emulation@@AAEXE@Z		; emulation::gb::Cpu::push

; 906  :   push(reg.raw16[src]&0xFF);

	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	and	edx, 255				; 000000ffH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@Cpu@gb@emulation@@AAEXE@Z		; emulation::gb::Cpu::push

; 907  :   Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 908  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$PUSH@$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::PUSH<2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$CALL_cc@$03$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv137 = -28						; size = 2
tv92 = -26						; size = 2
_nn$1 = -24						; size = 2
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$CALL_cc@$03$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::CALL_cc<4,1>, COMDAT
; _this$ = ecx

; 869  : void Cpu::CALL_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 870  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 16					; 00000010H
	sar	ecx, 4
	mov	DWORD PTR _table$[ebp], ecx

; 871  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 16					; 00000010H
	sar	eax, 4
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 872  : 
; 873  :   if (table[inv]&1) {

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN2@CALL_cc

; 874  :     CALL();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CALL@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::CALL

; 875  :   } else {

	jmp	$LN3@CALL_cc
$LN2@CALL_cc:

; 876  :     uint16_t nn;
; 877  :     nn = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _nn$1[ebp], cx

; 878  :     nn |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv137[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv137[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _nn$1[ebp]
	or	ecx, eax
	mov	WORD PTR _nn$1[ebp], cx
$LN3@CALL_cc:

; 879  :   }
; 880  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@CALL_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@CALL_cc:
	DD	1
	DD	$LN6@CALL_cc
$LN6@CALL_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@CALL_cc
$LN5@CALL_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$CALL_cc@$03$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::CALL_cc<4,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$JP_cc@$03$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv137 = -28						; size = 2
tv92 = -26						; size = 2
_nn$1 = -24						; size = 2
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$JP_cc@$03$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::JP_cc<4,1>, COMDAT
; _this$ = ecx

; 840  : void Cpu::JP_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 841  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 16					; 00000010H
	sar	ecx, 4
	mov	DWORD PTR _table$[ebp], ecx

; 842  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 16					; 00000010H
	sar	eax, 4
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 843  : 
; 844  :   if (table[inv]&1) {

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN2@JP_cc

; 845  :     JP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JP@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::JP

; 846  :   } else {

	jmp	$LN3@JP_cc
$LN2@JP_cc:

; 847  :     uint16_t nn;
; 848  :     nn = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _nn$1[ebp], cx

; 849  :     nn |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv137[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv137[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _nn$1[ebp]
	or	ecx, eax
	mov	WORD PTR _nn$1[ebp], cx
$LN3@JP_cc:

; 850  :   }
; 851  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@JP_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@JP_cc:
	DD	1
	DD	$LN6@JP_cc
$LN6@JP_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@JP_cc
$LN5@JP_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$JP_cc@$03$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::JP_cc<4,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$POP@$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$POP@$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::POP<2>, COMDAT
; _this$ = ecx

; 911  : void Cpu::POP() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 912  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 913  :   reg.raw16[dest] = pop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@Cpu@gb@emulation@@AAEEXZ		; emulation::gb::Cpu::pop
	movzx	ax, al
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx+1064], ax

; 914  :   reg.raw16[dest] |= pop() << 8;

	mov	esi, 2
	shl	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@Cpu@gb@emulation@@AAEEXZ		; emulation::gb::Cpu::pop
	movzx	eax, al
	shl	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+esi+1064]
	or	edx, eax
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax+1064], dx

; 915  :   if (dest == RegAF)

	xor	edx, edx
	je	SHORT $LN2@POP

; 916  :     reg.F._unused = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 240					; 000000f0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
$LN2@POP:

; 917  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$POP@$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::POP<2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$RET_cc@$03$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$RET_cc@$03$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::RET_cc<4,1>, COMDAT
; _this$ = ecx

; 889  : void Cpu::RET_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 890  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 16					; 00000010H
	sar	ecx, 4
	mov	DWORD PTR _table$[ebp], ecx

; 891  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 16					; 00000010H
	sar	eax, 4
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 892  : 
; 893  :   if (table[inv]&1) {

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN1@RET_cc

; 894  :     RET();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RET@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::RET
$LN1@RET_cc:

; 895  :   } else {
; 896  :    
; 897  :   }
; 898  :    Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 899  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@RET_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN7@RET_cc:
	DD	1
	DD	$LN6@RET_cc
$LN6@RET_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@RET_cc
$LN5@RET_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$RET_cc@$03$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::RET_cc<4,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADC@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADC@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADC<1,0,2>, COMDAT
; _this$ = ecx

; 536  : void Cpu::ADC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 537  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 538  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 539  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$0A@$01@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,0,2>

; 540  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 541  :   reg.raw8[dest] = a + b + carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	add	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	add	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 542  : 
; 543  :   updateCpuFlagC(a,carry,0);

	push	0
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 544  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN3@ADC

; 545  :     updateCpuFlagC(a+carry,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	add	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN3@ADC:

; 546  :   updateCpuFlagH(a,carry,0);

	push	0
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 547  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@ADC

; 548  :     updateCpuFlagH(a+carry,b,0);

	push	0
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN2@ADC:

; 549  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 550  : 
; 551  :   if (opcode == 0x8E){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1081]
	cmp	eax, 142				; 0000008eH
	jne	SHORT $LN4@ADC

; 552  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 553  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
$LN4@ADC:

; 554  :   }
; 555  :   
; 556  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@ADC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@ADC:
	DD	2
	DD	$LN8@ADC
$LN8@ADC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN6@ADC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN7@ADC
$LN7@ADC:
	DB	98					; 00000062H
	DB	0
$LN6@ADC:
	DB	97					; 00000061H
	DB	0
??$ADC@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADC<1,0,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$CALL_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv137 = -28						; size = 2
tv92 = -26						; size = 2
_nn$1 = -24						; size = 2
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$CALL_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::CALL_cc<7,0>, COMDAT
; _this$ = ecx

; 869  : void Cpu::CALL_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 870  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 128				; 00000080H
	sar	ecx, 7
	mov	DWORD PTR _table$[ebp], ecx

; 871  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 128				; 00000080H
	sar	eax, 7
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 872  : 
; 873  :   if (table[inv]&1) {

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN2@CALL_cc

; 874  :     CALL();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CALL@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::CALL

; 875  :   } else {

	jmp	$LN3@CALL_cc
$LN2@CALL_cc:

; 876  :     uint16_t nn;
; 877  :     nn = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _nn$1[ebp], cx

; 878  :     nn |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv137[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv137[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _nn$1[ebp]
	or	ecx, eax
	mov	WORD PTR _nn$1[ebp], cx
$LN3@CALL_cc:

; 879  :   }
; 880  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@CALL_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@CALL_cc:
	DD	1
	DD	$LN6@CALL_cc
$LN6@CALL_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@CALL_cc
$LN5@CALL_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$CALL_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::CALL_cc<7,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$JP_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv137 = -28						; size = 2
tv92 = -26						; size = 2
_nn$1 = -24						; size = 2
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$JP_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::JP_cc<7,0>, COMDAT
; _this$ = ecx

; 840  : void Cpu::JP_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 841  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 128				; 00000080H
	sar	ecx, 7
	mov	DWORD PTR _table$[ebp], ecx

; 842  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 128				; 00000080H
	sar	eax, 7
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 843  : 
; 844  :   if (table[inv]&1) {

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN2@JP_cc

; 845  :     JP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JP@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::JP

; 846  :   } else {

	jmp	$LN3@JP_cc
$LN2@JP_cc:

; 847  :     uint16_t nn;
; 848  :     nn = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _nn$1[ebp], cx

; 849  :     nn |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv137[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv137[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _nn$1[ebp]
	or	ecx, eax
	mov	WORD PTR _nn$1[ebp], cx
$LN3@JP_cc:

; 850  :   }
; 851  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@JP_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@JP_cc:
	DD	1
	DD	$LN6@JP_cc
$LN6@JP_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@JP_cc
$LN5@JP_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$JP_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::JP_cc<7,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$RET_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$RET_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::RET_cc<7,0>, COMDAT
; _this$ = ecx

; 889  : void Cpu::RET_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 890  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 128				; 00000080H
	sar	ecx, 7
	mov	DWORD PTR _table$[ebp], ecx

; 891  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 128				; 00000080H
	sar	eax, 7
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 892  : 
; 893  :   if (table[inv]&1) {

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN1@RET_cc

; 894  :     RET();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RET@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::RET
$LN1@RET_cc:

; 895  :   } else {
; 896  :    
; 897  :   }
; 898  :    Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 899  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@RET_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@RET_cc:
	DD	1
	DD	$LN6@RET_cc
$LN6@RET_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@RET_cc
$LN5@RET_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$RET_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::RET_cc<7,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADD@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADD@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADD<1,0,2>, COMDAT
; _this$ = ecx

; 499  : void Cpu::ADD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 500  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 501  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 502  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$0A@$01@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,0,2>

; 503  :   reg.raw8[dest] = a + b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	add	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 504  :   updateCpuFlagC(a,b,0);

	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 505  :   updateCpuFlagH(a,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 506  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 507  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@ADD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@ADD:
	DD	2
	DD	$LN5@ADD
$LN5@ADD:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@ADD
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@ADD
$LN4@ADD:
	DB	98					; 00000062H
	DB	0
$LN3@ADD:
	DB	97					; 00000061H
	DB	0
??$ADD@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADD<1,0,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$PUSH@$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$PUSH@$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::PUSH<1>, COMDAT
; _this$ = ecx

; 903  : void Cpu::PUSH() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 904  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 905  :   push(reg.raw16[src]>>8);

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	sar	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@Cpu@gb@emulation@@AAEXE@Z		; emulation::gb::Cpu::push

; 906  :   push(reg.raw16[src]&0xFF);

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	and	edx, 255				; 000000ffH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@Cpu@gb@emulation@@AAEXE@Z		; emulation::gb::Cpu::push

; 907  :   Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 908  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$PUSH@$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::PUSH<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$CALL_cc@$06$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv137 = -28						; size = 2
tv92 = -26						; size = 2
_nn$1 = -24						; size = 2
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$CALL_cc@$06$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::CALL_cc<7,1>, COMDAT
; _this$ = ecx

; 869  : void Cpu::CALL_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 870  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 128				; 00000080H
	sar	ecx, 7
	mov	DWORD PTR _table$[ebp], ecx

; 871  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 128				; 00000080H
	sar	eax, 7
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 872  : 
; 873  :   if (table[inv]&1) {

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN2@CALL_cc

; 874  :     CALL();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CALL@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::CALL

; 875  :   } else {

	jmp	$LN3@CALL_cc
$LN2@CALL_cc:

; 876  :     uint16_t nn;
; 877  :     nn = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _nn$1[ebp], cx

; 878  :     nn |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv137[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv137[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _nn$1[ebp]
	or	ecx, eax
	mov	WORD PTR _nn$1[ebp], cx
$LN3@CALL_cc:

; 879  :   }
; 880  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@CALL_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@CALL_cc:
	DD	1
	DD	$LN6@CALL_cc
$LN6@CALL_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@CALL_cc
$LN5@CALL_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$CALL_cc@$06$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::CALL_cc<7,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$JP_cc@$06$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv137 = -28						; size = 2
tv92 = -26						; size = 2
_nn$1 = -24						; size = 2
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$JP_cc@$06$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::JP_cc<7,1>, COMDAT
; _this$ = ecx

; 840  : void Cpu::JP_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 841  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 128				; 00000080H
	sar	ecx, 7
	mov	DWORD PTR _table$[ebp], ecx

; 842  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 128				; 00000080H
	sar	eax, 7
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 843  : 
; 844  :   if (table[inv]&1) {

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN2@JP_cc

; 845  :     JP();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JP@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::JP

; 846  :   } else {

	jmp	$LN3@JP_cc
$LN2@JP_cc:

; 847  :     uint16_t nn;
; 848  :     nn = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _nn$1[ebp], cx

; 849  :     nn |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv137[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv137[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _nn$1[ebp]
	or	ecx, eax
	mov	WORD PTR _nn$1[ebp], cx
$LN3@JP_cc:

; 850  :   }
; 851  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@JP_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@JP_cc:
	DD	1
	DD	$LN6@JP_cc
$LN6@JP_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@JP_cc
$LN5@JP_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$JP_cc@$06$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::JP_cc<7,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$POP@$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$POP@$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::POP<1>, COMDAT
; _this$ = ecx

; 911  : void Cpu::POP() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 912  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 913  :   reg.raw16[dest] = pop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@Cpu@gb@emulation@@AAEEXZ		; emulation::gb::Cpu::pop
	movzx	ax, al
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx+1064], ax

; 914  :   reg.raw16[dest] |= pop() << 8;

	mov	esi, 2
	shl	esi, 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@Cpu@gb@emulation@@AAEEXZ		; emulation::gb::Cpu::pop
	movzx	eax, al
	shl	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+esi+1064]
	or	edx, eax
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax+1064], dx

; 915  :   if (dest == RegAF)

	xor	edx, edx
	je	SHORT $LN2@POP

; 916  :     reg.F._unused = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 240					; 000000f0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
$LN2@POP:

; 917  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$POP@$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::POP<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$RET_cc@$06$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$RET_cc@$06$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::RET_cc<7,1>, COMDAT
; _this$ = ecx

; 889  : void Cpu::RET_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 890  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 128				; 00000080H
	sar	ecx, 7
	mov	DWORD PTR _table$[ebp], ecx

; 891  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 128				; 00000080H
	sar	eax, 7
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 892  : 
; 893  :   if (table[inv]&1) {

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN1@RET_cc

; 894  :     RET();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RET@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::RET
$LN1@RET_cc:

; 895  :   } else {
; 896  :    
; 897  :   }
; 898  :    Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 899  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@RET_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@RET_cc:
	DD	1
	DD	$LN6@RET_cc
$LN6@RET_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@RET_cc
$LN5@RET_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$RET_cc@$06$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::RET_cc<7,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$CP_reg@$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$CP_reg@$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::CP_reg<1>, COMDAT
; _this$ = ecx

; 969  : void Cpu::CP_reg() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 970  :   CP(reg.A,reg.raw8[r]);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1065]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CP@Cpu@gb@emulation@@AAEXEE@Z		; emulation::gb::Cpu::CP

; 971  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$CP_reg@$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::CP_reg<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$CP_reg@$05@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$CP_reg@$05@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::CP_reg<6>, COMDAT
; _this$ = ecx

; 969  : void Cpu::CP_reg() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 970  :   CP(reg.A,reg.raw8[r]);

	mov	eax, 1
	imul	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1065]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CP@Cpu@gb@emulation@@AAEXEE@Z		; emulation::gb::Cpu::CP

; 971  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$CP_reg@$05@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::CP_reg<6>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$CP_reg@$06@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$CP_reg@$06@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::CP_reg<7>, COMDAT
; _this$ = ecx

; 969  : void Cpu::CP_reg() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 970  :   CP(reg.A,reg.raw8[r]);

	mov	eax, 1
	imul	eax, 7
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1065]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CP@Cpu@gb@emulation@@AAEXEE@Z		; emulation::gb::Cpu::CP

; 971  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$CP_reg@$06@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::CP_reg<7>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$CP_reg@$03@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$CP_reg@$03@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::CP_reg<4>, COMDAT
; _this$ = ecx

; 969  : void Cpu::CP_reg() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 970  :   CP(reg.A,reg.raw8[r]);

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1065]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CP@Cpu@gb@emulation@@AAEXEE@Z		; emulation::gb::Cpu::CP

; 971  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$CP_reg@$03@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::CP_reg<4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$CP_reg@$04@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$CP_reg@$04@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::CP_reg<5>, COMDAT
; _this$ = ecx

; 969  : void Cpu::CP_reg() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 970  :   CP(reg.A,reg.raw8[r]);

	mov	eax, 1
	imul	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1065]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CP@Cpu@gb@emulation@@AAEXEE@Z		; emulation::gb::Cpu::CP

; 971  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$CP_reg@$04@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::CP_reg<5>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$CP_reg@$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$CP_reg@$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::CP_reg<2>, COMDAT
; _this$ = ecx

; 969  : void Cpu::CP_reg() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 970  :   CP(reg.A,reg.raw8[r]);

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1065]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CP@Cpu@gb@emulation@@AAEXEE@Z		; emulation::gb::Cpu::CP

; 971  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$CP_reg@$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::CP_reg<2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$CP_reg@$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$CP_reg@$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::CP_reg<3>, COMDAT
; _this$ = ecx

; 969  : void Cpu::CP_reg() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 970  :   CP(reg.A,reg.raw8[r]);

	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1065]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CP@Cpu@gb@emulation@@AAEXEE@Z		; emulation::gb::Cpu::CP

; 971  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$CP_reg@$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::CP_reg<3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$OR@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$OR@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::OR<1,1,0>, COMDAT
; _this$ = ecx

; 608  : void Cpu::OR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 609  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 610  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 611  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$00$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,1,0>

; 612  :   reg.raw8[dest] = a | b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	or	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 613  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 614  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@OR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@OR:
	DD	2
	DD	$LN5@OR
$LN5@OR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@OR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@OR
$LN4@OR:
	DB	98					; 00000062H
	DB	0
$LN3@OR:
	DB	97					; 00000061H
	DB	0
??$OR@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::OR<1,1,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$OR@$00$02$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$OR@$00$02$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::OR<1,3,1>, COMDAT
; _this$ = ecx

; 608  : void Cpu::OR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 609  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 610  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 611  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$02$00@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,1>

; 612  :   reg.raw8[dest] = a | b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	or	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 613  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 614  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@OR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@OR:
	DD	2
	DD	$LN5@OR
$LN5@OR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@OR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@OR
$LN4@OR:
	DB	98					; 00000062H
	DB	0
$LN3@OR:
	DB	97					; 00000061H
	DB	0
??$OR@$00$02$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::OR<1,3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$OR@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$OR@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::OR<1,6,0>, COMDAT
; _this$ = ecx

; 608  : void Cpu::OR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 609  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 610  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 611  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$05$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,6,0>

; 612  :   reg.raw8[dest] = a | b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	or	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 613  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 614  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@OR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@OR:
	DD	2
	DD	$LN5@OR
$LN5@OR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@OR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@OR
$LN4@OR:
	DB	98					; 00000062H
	DB	0
$LN3@OR:
	DB	97					; 00000061H
	DB	0
??$OR@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::OR<1,6,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$OR@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$OR@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::OR<1,7,0>, COMDAT
; _this$ = ecx

; 608  : void Cpu::OR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 609  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 610  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 611  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$06$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,7,0>

; 612  :   reg.raw8[dest] = a | b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	or	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 613  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 614  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@OR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@OR:
	DD	2
	DD	$LN5@OR
$LN5@OR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@OR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@OR
$LN4@OR:
	DB	98					; 00000062H
	DB	0
$LN3@OR:
	DB	97					; 00000061H
	DB	0
??$OR@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::OR<1,7,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$OR@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$OR@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::OR<1,4,0>, COMDAT
; _this$ = ecx

; 608  : void Cpu::OR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 609  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 610  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 611  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$03$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,4,0>

; 612  :   reg.raw8[dest] = a | b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	or	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 613  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 614  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@OR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@OR:
	DD	2
	DD	$LN5@OR
$LN5@OR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@OR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@OR
$LN4@OR:
	DB	98					; 00000062H
	DB	0
$LN3@OR:
	DB	97					; 00000061H
	DB	0
??$OR@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::OR<1,4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$OR@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$OR@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::OR<1,5,0>, COMDAT
; _this$ = ecx

; 608  : void Cpu::OR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 609  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 610  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 611  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$04$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,5,0>

; 612  :   reg.raw8[dest] = a | b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	or	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 613  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 614  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@OR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@OR:
	DD	2
	DD	$LN5@OR
$LN5@OR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@OR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@OR
$LN4@OR:
	DB	98					; 00000062H
	DB	0
$LN3@OR:
	DB	97					; 00000061H
	DB	0
??$OR@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::OR<1,5,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$OR@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$OR@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::OR<1,2,0>, COMDAT
; _this$ = ecx

; 608  : void Cpu::OR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 609  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 610  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 611  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$01$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,2,0>

; 612  :   reg.raw8[dest] = a | b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	or	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 613  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 614  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@OR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@OR:
	DD	2
	DD	$LN5@OR
$LN5@OR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@OR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@OR
$LN4@OR:
	DB	98					; 00000062H
	DB	0
$LN3@OR:
	DB	97					; 00000061H
	DB	0
??$OR@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::OR<1,2,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$OR@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$OR@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::OR<1,3,0>, COMDAT
; _this$ = ecx

; 608  : void Cpu::OR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 609  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 610  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 611  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$02$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,0>

; 612  :   reg.raw8[dest] = a | b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	or	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 613  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 614  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@OR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@OR:
	DD	2
	DD	$LN5@OR
$LN5@OR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@OR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@OR
$LN4@OR:
	DB	98					; 00000062H
	DB	0
$LN3@OR:
	DB	97					; 00000061H
	DB	0
??$OR@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::OR<1,3,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$XOR@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$XOR@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::XOR<1,1,0>, COMDAT
; _this$ = ecx

; 599  : void Cpu::XOR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 600  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 601  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 602  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$00$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,1,0>

; 603  :   reg.raw8[dest] = a ^ b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	xor	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 604  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 605  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@XOR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@XOR:
	DD	2
	DD	$LN5@XOR
$LN5@XOR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@XOR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@XOR
$LN4@XOR:
	DB	98					; 00000062H
	DB	0
$LN3@XOR:
	DB	97					; 00000061H
	DB	0
??$XOR@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::XOR<1,1,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$XOR@$00$02$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$XOR@$00$02$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::XOR<1,3,1>, COMDAT
; _this$ = ecx

; 599  : void Cpu::XOR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 600  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 601  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 602  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$02$00@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,1>

; 603  :   reg.raw8[dest] = a ^ b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	xor	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 604  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 605  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@XOR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@XOR:
	DD	2
	DD	$LN5@XOR
$LN5@XOR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@XOR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@XOR
$LN4@XOR:
	DB	98					; 00000062H
	DB	0
$LN3@XOR:
	DB	97					; 00000061H
	DB	0
??$XOR@$00$02$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::XOR<1,3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$XOR@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$XOR@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::XOR<1,6,0>, COMDAT
; _this$ = ecx

; 599  : void Cpu::XOR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 600  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 601  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 602  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$05$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,6,0>

; 603  :   reg.raw8[dest] = a ^ b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	xor	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 604  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 605  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@XOR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@XOR:
	DD	2
	DD	$LN5@XOR
$LN5@XOR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@XOR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@XOR
$LN4@XOR:
	DB	98					; 00000062H
	DB	0
$LN3@XOR:
	DB	97					; 00000061H
	DB	0
??$XOR@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::XOR<1,6,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$XOR@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$XOR@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::XOR<1,7,0>, COMDAT
; _this$ = ecx

; 599  : void Cpu::XOR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 600  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 601  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 602  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$06$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,7,0>

; 603  :   reg.raw8[dest] = a ^ b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	xor	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 604  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 605  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@XOR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@XOR:
	DD	2
	DD	$LN5@XOR
$LN5@XOR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@XOR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@XOR
$LN4@XOR:
	DB	98					; 00000062H
	DB	0
$LN3@XOR:
	DB	97					; 00000061H
	DB	0
??$XOR@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::XOR<1,7,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$XOR@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$XOR@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::XOR<1,4,0>, COMDAT
; _this$ = ecx

; 599  : void Cpu::XOR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 600  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 601  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 602  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$03$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,4,0>

; 603  :   reg.raw8[dest] = a ^ b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	xor	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 604  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 605  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@XOR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@XOR:
	DD	2
	DD	$LN5@XOR
$LN5@XOR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@XOR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@XOR
$LN4@XOR:
	DB	98					; 00000062H
	DB	0
$LN3@XOR:
	DB	97					; 00000061H
	DB	0
??$XOR@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::XOR<1,4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$XOR@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$XOR@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::XOR<1,5,0>, COMDAT
; _this$ = ecx

; 599  : void Cpu::XOR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 600  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 601  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 602  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$04$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,5,0>

; 603  :   reg.raw8[dest] = a ^ b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	xor	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 604  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 605  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@XOR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@XOR:
	DD	2
	DD	$LN5@XOR
$LN5@XOR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@XOR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@XOR
$LN4@XOR:
	DB	98					; 00000062H
	DB	0
$LN3@XOR:
	DB	97					; 00000061H
	DB	0
??$XOR@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::XOR<1,5,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$XOR@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$XOR@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::XOR<1,2,0>, COMDAT
; _this$ = ecx

; 599  : void Cpu::XOR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 600  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 601  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 602  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$01$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,2,0>

; 603  :   reg.raw8[dest] = a ^ b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	xor	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 604  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 605  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@XOR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@XOR:
	DD	2
	DD	$LN5@XOR
$LN5@XOR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@XOR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@XOR
$LN4@XOR:
	DB	98					; 00000062H
	DB	0
$LN3@XOR:
	DB	97					; 00000061H
	DB	0
??$XOR@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::XOR<1,2,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$XOR@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$XOR@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::XOR<1,3,0>, COMDAT
; _this$ = ecx

; 599  : void Cpu::XOR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 600  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 601  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 602  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$02$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,0>

; 603  :   reg.raw8[dest] = a ^ b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	xor	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 604  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 605  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@XOR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@XOR:
	DD	2
	DD	$LN5@XOR
$LN5@XOR:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@XOR
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@XOR
$LN4@XOR:
	DB	98					; 00000062H
	DB	0
$LN3@XOR:
	DB	97					; 00000061H
	DB	0
??$XOR@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::XOR<1,3,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$AND@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$AND@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::AND<1,1,0>, COMDAT
; _this$ = ecx

; 588  : void Cpu::AND() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 589  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 590  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 591  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$00$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,1,0>

; 592  :   reg.raw8[dest] = a & b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	and	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 593  :   reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 594  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 595  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@AND
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@AND:
	DD	2
	DD	$LN5@AND
$LN5@AND:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@AND
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@AND
$LN4@AND:
	DB	98					; 00000062H
	DB	0
$LN3@AND:
	DB	97					; 00000061H
	DB	0
??$AND@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::AND<1,1,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$AND@$00$02$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$AND@$00$02$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::AND<1,3,1>, COMDAT
; _this$ = ecx

; 588  : void Cpu::AND() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 589  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 590  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 591  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$02$00@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,1>

; 592  :   reg.raw8[dest] = a & b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	and	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 593  :   reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 594  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 595  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@AND
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@AND:
	DD	2
	DD	$LN5@AND
$LN5@AND:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@AND
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@AND
$LN4@AND:
	DB	98					; 00000062H
	DB	0
$LN3@AND:
	DB	97					; 00000061H
	DB	0
??$AND@$00$02$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::AND<1,3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$AND@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$AND@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::AND<1,6,0>, COMDAT
; _this$ = ecx

; 588  : void Cpu::AND() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 589  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 590  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 591  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$05$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,6,0>

; 592  :   reg.raw8[dest] = a & b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	and	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 593  :   reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 594  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 595  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@AND
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@AND:
	DD	2
	DD	$LN5@AND
$LN5@AND:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@AND
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@AND
$LN4@AND:
	DB	98					; 00000062H
	DB	0
$LN3@AND:
	DB	97					; 00000061H
	DB	0
??$AND@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::AND<1,6,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$AND@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$AND@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::AND<1,7,0>, COMDAT
; _this$ = ecx

; 588  : void Cpu::AND() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 589  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 590  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 591  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$06$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,7,0>

; 592  :   reg.raw8[dest] = a & b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	and	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 593  :   reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 594  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 595  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@AND
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@AND:
	DD	2
	DD	$LN5@AND
$LN5@AND:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@AND
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@AND
$LN4@AND:
	DB	98					; 00000062H
	DB	0
$LN3@AND:
	DB	97					; 00000061H
	DB	0
??$AND@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::AND<1,7,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$AND@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$AND@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::AND<1,4,0>, COMDAT
; _this$ = ecx

; 588  : void Cpu::AND() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 589  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 590  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 591  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$03$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,4,0>

; 592  :   reg.raw8[dest] = a & b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	and	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 593  :   reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 594  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 595  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@AND
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@AND:
	DD	2
	DD	$LN5@AND
$LN5@AND:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@AND
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@AND
$LN4@AND:
	DB	98					; 00000062H
	DB	0
$LN3@AND:
	DB	97					; 00000061H
	DB	0
??$AND@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::AND<1,4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$AND@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$AND@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::AND<1,5,0>, COMDAT
; _this$ = ecx

; 588  : void Cpu::AND() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 589  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 590  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 591  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$04$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,5,0>

; 592  :   reg.raw8[dest] = a & b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	and	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 593  :   reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 594  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 595  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@AND
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@AND:
	DD	2
	DD	$LN5@AND
$LN5@AND:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@AND
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@AND
$LN4@AND:
	DB	98					; 00000062H
	DB	0
$LN3@AND:
	DB	97					; 00000061H
	DB	0
??$AND@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::AND<1,5,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$AND@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$AND@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::AND<1,2,0>, COMDAT
; _this$ = ecx

; 588  : void Cpu::AND() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 589  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 590  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 591  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$01$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,2,0>

; 592  :   reg.raw8[dest] = a & b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	and	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 593  :   reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 594  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 595  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@AND
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@AND:
	DD	2
	DD	$LN5@AND
$LN5@AND:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@AND
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@AND
$LN4@AND:
	DB	98					; 00000062H
	DB	0
$LN3@AND:
	DB	97					; 00000061H
	DB	0
??$AND@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::AND<1,2,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$AND@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$AND@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::AND<1,3,0>, COMDAT
; _this$ = ecx

; 588  : void Cpu::AND() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 589  :   reg.F.raw = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], 0

; 590  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 591  :   arithmeticMode<dest,src,mode>(a,b);

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$02$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,0>

; 592  :   reg.raw8[dest] = a & b;

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	and	eax, ecx
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al

; 593  :   reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 594  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 595  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@AND
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@AND:
	DD	2
	DD	$LN5@AND
$LN5@AND:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@AND
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@AND
$LN4@AND:
	DB	98					; 00000062H
	DB	0
$LN3@AND:
	DB	97					; 00000061H
	DB	0
??$AND@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::AND<1,3,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SBC@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SBC@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SBC<1,1,0>, COMDAT
; _this$ = ecx

; 572  : void Cpu::SBC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 573  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 574  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 575  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$00$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,1,0>

; 576  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 577  :   reg.raw8[dest] = a - b - carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	sub	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 578  :   updateCpuFlagC(a,carry,1);

	push	1
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 579  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@SBC

; 580  :     updateCpuFlagC(a-carry,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	sub	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN2@SBC:

; 581  :   updateCpuFlagH(a,carry,1);

	push	1
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 582  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@SBC

; 583  :     updateCpuFlagH(a-carry,b,1);

	push	1
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN1@SBC:

; 584  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 585  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@SBC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SBC:
	DD	2
	DD	$LN7@SBC
$LN7@SBC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN5@SBC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN6@SBC
$LN6@SBC:
	DB	98					; 00000062H
	DB	0
$LN5@SBC:
	DB	97					; 00000061H
	DB	0
??$SBC@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SBC<1,1,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SBC@$00$02$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SBC@$00$02$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SBC<1,3,1>, COMDAT
; _this$ = ecx

; 572  : void Cpu::SBC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 573  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 574  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 575  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$02$00@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,1>

; 576  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 577  :   reg.raw8[dest] = a - b - carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	sub	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 578  :   updateCpuFlagC(a,carry,1);

	push	1
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 579  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@SBC

; 580  :     updateCpuFlagC(a-carry,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	sub	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN2@SBC:

; 581  :   updateCpuFlagH(a,carry,1);

	push	1
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 582  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@SBC

; 583  :     updateCpuFlagH(a-carry,b,1);

	push	1
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN1@SBC:

; 584  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 585  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@SBC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SBC:
	DD	2
	DD	$LN7@SBC
$LN7@SBC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN5@SBC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN6@SBC
$LN6@SBC:
	DB	98					; 00000062H
	DB	0
$LN5@SBC:
	DB	97					; 00000061H
	DB	0
??$SBC@$00$02$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SBC<1,3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SBC@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SBC@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SBC<1,6,0>, COMDAT
; _this$ = ecx

; 572  : void Cpu::SBC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 573  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 574  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 575  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$05$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,6,0>

; 576  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 577  :   reg.raw8[dest] = a - b - carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	sub	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 578  :   updateCpuFlagC(a,carry,1);

	push	1
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 579  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@SBC

; 580  :     updateCpuFlagC(a-carry,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	sub	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN2@SBC:

; 581  :   updateCpuFlagH(a,carry,1);

	push	1
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 582  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@SBC

; 583  :     updateCpuFlagH(a-carry,b,1);

	push	1
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN1@SBC:

; 584  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 585  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@SBC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SBC:
	DD	2
	DD	$LN7@SBC
$LN7@SBC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN5@SBC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN6@SBC
$LN6@SBC:
	DB	98					; 00000062H
	DB	0
$LN5@SBC:
	DB	97					; 00000061H
	DB	0
??$SBC@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SBC<1,6,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SBC@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SBC@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SBC<1,7,0>, COMDAT
; _this$ = ecx

; 572  : void Cpu::SBC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 573  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 574  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 575  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$06$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,7,0>

; 576  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 577  :   reg.raw8[dest] = a - b - carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	sub	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 578  :   updateCpuFlagC(a,carry,1);

	push	1
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 579  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@SBC

; 580  :     updateCpuFlagC(a-carry,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	sub	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN2@SBC:

; 581  :   updateCpuFlagH(a,carry,1);

	push	1
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 582  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@SBC

; 583  :     updateCpuFlagH(a-carry,b,1);

	push	1
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN1@SBC:

; 584  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 585  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@SBC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SBC:
	DD	2
	DD	$LN7@SBC
$LN7@SBC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN5@SBC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN6@SBC
$LN6@SBC:
	DB	98					; 00000062H
	DB	0
$LN5@SBC:
	DB	97					; 00000061H
	DB	0
??$SBC@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SBC<1,7,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SBC@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SBC@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SBC<1,4,0>, COMDAT
; _this$ = ecx

; 572  : void Cpu::SBC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 573  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 574  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 575  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$03$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,4,0>

; 576  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 577  :   reg.raw8[dest] = a - b - carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	sub	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 578  :   updateCpuFlagC(a,carry,1);

	push	1
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 579  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@SBC

; 580  :     updateCpuFlagC(a-carry,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	sub	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN2@SBC:

; 581  :   updateCpuFlagH(a,carry,1);

	push	1
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 582  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@SBC

; 583  :     updateCpuFlagH(a-carry,b,1);

	push	1
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN1@SBC:

; 584  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 585  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@SBC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SBC:
	DD	2
	DD	$LN7@SBC
$LN7@SBC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN5@SBC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN6@SBC
$LN6@SBC:
	DB	98					; 00000062H
	DB	0
$LN5@SBC:
	DB	97					; 00000061H
	DB	0
??$SBC@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SBC<1,4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SBC@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SBC@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SBC<1,5,0>, COMDAT
; _this$ = ecx

; 572  : void Cpu::SBC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 573  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 574  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 575  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$04$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,5,0>

; 576  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 577  :   reg.raw8[dest] = a - b - carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	sub	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 578  :   updateCpuFlagC(a,carry,1);

	push	1
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 579  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@SBC

; 580  :     updateCpuFlagC(a-carry,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	sub	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN2@SBC:

; 581  :   updateCpuFlagH(a,carry,1);

	push	1
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 582  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@SBC

; 583  :     updateCpuFlagH(a-carry,b,1);

	push	1
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN1@SBC:

; 584  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 585  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@SBC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SBC:
	DD	2
	DD	$LN7@SBC
$LN7@SBC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN5@SBC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN6@SBC
$LN6@SBC:
	DB	98					; 00000062H
	DB	0
$LN5@SBC:
	DB	97					; 00000061H
	DB	0
??$SBC@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SBC<1,5,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SBC@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SBC@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SBC<1,2,0>, COMDAT
; _this$ = ecx

; 572  : void Cpu::SBC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 573  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 574  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 575  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$01$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,2,0>

; 576  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 577  :   reg.raw8[dest] = a - b - carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	sub	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 578  :   updateCpuFlagC(a,carry,1);

	push	1
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 579  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@SBC

; 580  :     updateCpuFlagC(a-carry,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	sub	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN2@SBC:

; 581  :   updateCpuFlagH(a,carry,1);

	push	1
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 582  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@SBC

; 583  :     updateCpuFlagH(a-carry,b,1);

	push	1
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN1@SBC:

; 584  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 585  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@SBC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SBC:
	DD	2
	DD	$LN7@SBC
$LN7@SBC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN5@SBC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN6@SBC
$LN6@SBC:
	DB	98					; 00000062H
	DB	0
$LN5@SBC:
	DB	97					; 00000061H
	DB	0
??$SBC@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SBC<1,2,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SBC@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SBC@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SBC<1,3,0>, COMDAT
; _this$ = ecx

; 572  : void Cpu::SBC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 573  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 574  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 575  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$02$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,0>

; 576  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 577  :   reg.raw8[dest] = a - b - carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	sub	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 578  :   updateCpuFlagC(a,carry,1);

	push	1
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 579  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@SBC

; 580  :     updateCpuFlagC(a-carry,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	sub	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN2@SBC:

; 581  :   updateCpuFlagH(a,carry,1);

	push	1
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 582  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@SBC

; 583  :     updateCpuFlagH(a-carry,b,1);

	push	1
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN1@SBC:

; 584  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 585  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@SBC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SBC:
	DD	2
	DD	$LN7@SBC
$LN7@SBC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN5@SBC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN6@SBC
$LN6@SBC:
	DB	98					; 00000062H
	DB	0
$LN5@SBC:
	DB	97					; 00000061H
	DB	0
??$SBC@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SBC<1,3,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SUB@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SUB@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SUB<1,1,0>, COMDAT
; _this$ = ecx

; 561  : void Cpu::SUB() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 562  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 563  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 564  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$00$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,1,0>

; 565  :   reg.raw8[dest] = a - b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	sub	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 566  :   updateCpuFlagC(a,b,1);

	push	1
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 567  :   updateCpuFlagH(a,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 568  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 569  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SUB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@SUB:
	DD	2
	DD	$LN5@SUB
$LN5@SUB:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@SUB
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@SUB
$LN4@SUB:
	DB	98					; 00000062H
	DB	0
$LN3@SUB:
	DB	97					; 00000061H
	DB	0
??$SUB@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SUB<1,1,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SUB@$00$02$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SUB@$00$02$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SUB<1,3,1>, COMDAT
; _this$ = ecx

; 561  : void Cpu::SUB() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 562  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 563  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 564  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$02$00@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,1>

; 565  :   reg.raw8[dest] = a - b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	sub	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 566  :   updateCpuFlagC(a,b,1);

	push	1
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 567  :   updateCpuFlagH(a,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 568  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 569  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SUB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@SUB:
	DD	2
	DD	$LN5@SUB
$LN5@SUB:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@SUB
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@SUB
$LN4@SUB:
	DB	98					; 00000062H
	DB	0
$LN3@SUB:
	DB	97					; 00000061H
	DB	0
??$SUB@$00$02$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SUB<1,3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SUB@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SUB@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SUB<1,6,0>, COMDAT
; _this$ = ecx

; 561  : void Cpu::SUB() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 562  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 563  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 564  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$05$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,6,0>

; 565  :   reg.raw8[dest] = a - b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	sub	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 566  :   updateCpuFlagC(a,b,1);

	push	1
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 567  :   updateCpuFlagH(a,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 568  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 569  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SUB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@SUB:
	DD	2
	DD	$LN5@SUB
$LN5@SUB:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@SUB
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@SUB
$LN4@SUB:
	DB	98					; 00000062H
	DB	0
$LN3@SUB:
	DB	97					; 00000061H
	DB	0
??$SUB@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SUB<1,6,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SUB@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SUB@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SUB<1,7,0>, COMDAT
; _this$ = ecx

; 561  : void Cpu::SUB() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 562  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 563  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 564  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$06$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,7,0>

; 565  :   reg.raw8[dest] = a - b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	sub	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 566  :   updateCpuFlagC(a,b,1);

	push	1
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 567  :   updateCpuFlagH(a,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 568  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 569  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SUB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@SUB:
	DD	2
	DD	$LN5@SUB
$LN5@SUB:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@SUB
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@SUB
$LN4@SUB:
	DB	98					; 00000062H
	DB	0
$LN3@SUB:
	DB	97					; 00000061H
	DB	0
??$SUB@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SUB<1,7,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SUB@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SUB@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SUB<1,4,0>, COMDAT
; _this$ = ecx

; 561  : void Cpu::SUB() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 562  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 563  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 564  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$03$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,4,0>

; 565  :   reg.raw8[dest] = a - b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	sub	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 566  :   updateCpuFlagC(a,b,1);

	push	1
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 567  :   updateCpuFlagH(a,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 568  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 569  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SUB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@SUB:
	DD	2
	DD	$LN5@SUB
$LN5@SUB:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@SUB
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@SUB
$LN4@SUB:
	DB	98					; 00000062H
	DB	0
$LN3@SUB:
	DB	97					; 00000061H
	DB	0
??$SUB@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SUB<1,4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SUB@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SUB@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SUB<1,5,0>, COMDAT
; _this$ = ecx

; 561  : void Cpu::SUB() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 562  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 563  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 564  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$04$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,5,0>

; 565  :   reg.raw8[dest] = a - b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	sub	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 566  :   updateCpuFlagC(a,b,1);

	push	1
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 567  :   updateCpuFlagH(a,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 568  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 569  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SUB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@SUB:
	DD	2
	DD	$LN5@SUB
$LN5@SUB:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@SUB
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@SUB
$LN4@SUB:
	DB	98					; 00000062H
	DB	0
$LN3@SUB:
	DB	97					; 00000061H
	DB	0
??$SUB@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SUB<1,5,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SUB@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SUB@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SUB<1,2,0>, COMDAT
; _this$ = ecx

; 561  : void Cpu::SUB() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 562  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 563  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 564  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$01$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,2,0>

; 565  :   reg.raw8[dest] = a - b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	sub	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 566  :   updateCpuFlagC(a,b,1);

	push	1
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 567  :   updateCpuFlagH(a,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 568  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 569  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SUB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@SUB:
	DD	2
	DD	$LN5@SUB
$LN5@SUB:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@SUB
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@SUB
$LN4@SUB:
	DB	98					; 00000062H
	DB	0
$LN3@SUB:
	DB	97					; 00000061H
	DB	0
??$SUB@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SUB<1,2,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$SUB@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$SUB@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::SUB<1,3,0>, COMDAT
; _this$ = ecx

; 561  : void Cpu::SUB() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 562  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 563  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 564  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$02$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,0>

; 565  :   reg.raw8[dest] = a - b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	sub	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 566  :   updateCpuFlagC(a,b,1);

	push	1
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 567  :   updateCpuFlagH(a,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 568  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 569  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SUB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@SUB:
	DD	2
	DD	$LN5@SUB
$LN5@SUB:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@SUB
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@SUB
$LN4@SUB:
	DB	98					; 00000062H
	DB	0
$LN3@SUB:
	DB	97					; 00000061H
	DB	0
??$SUB@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::SUB<1,3,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADC@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADC@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADC<1,1,0>, COMDAT
; _this$ = ecx

; 536  : void Cpu::ADC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 537  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 538  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 539  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$00$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,1,0>

; 540  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 541  :   reg.raw8[dest] = a + b + carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	add	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	add	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 542  : 
; 543  :   updateCpuFlagC(a,carry,0);

	push	0
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 544  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN3@ADC

; 545  :     updateCpuFlagC(a+carry,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	add	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN3@ADC:

; 546  :   updateCpuFlagH(a,carry,0);

	push	0
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 547  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@ADC

; 548  :     updateCpuFlagH(a+carry,b,0);

	push	0
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN2@ADC:

; 549  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 550  : 
; 551  :   if (opcode == 0x8E){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1081]
	cmp	eax, 142				; 0000008eH
	jne	SHORT $LN4@ADC

; 552  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 553  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
$LN4@ADC:

; 554  :   }
; 555  :   
; 556  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@ADC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@ADC:
	DD	2
	DD	$LN8@ADC
$LN8@ADC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN6@ADC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN7@ADC
$LN7@ADC:
	DB	98					; 00000062H
	DB	0
$LN6@ADC:
	DB	97					; 00000061H
	DB	0
??$ADC@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADC<1,1,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADC@$00$02$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADC@$00$02$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADC<1,3,1>, COMDAT
; _this$ = ecx

; 536  : void Cpu::ADC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 537  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 538  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 539  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$02$00@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,1>

; 540  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 541  :   reg.raw8[dest] = a + b + carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	add	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	add	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 542  : 
; 543  :   updateCpuFlagC(a,carry,0);

	push	0
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 544  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN3@ADC

; 545  :     updateCpuFlagC(a+carry,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	add	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN3@ADC:

; 546  :   updateCpuFlagH(a,carry,0);

	push	0
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 547  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@ADC

; 548  :     updateCpuFlagH(a+carry,b,0);

	push	0
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN2@ADC:

; 549  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 550  : 
; 551  :   if (opcode == 0x8E){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1081]
	cmp	eax, 142				; 0000008eH
	jne	SHORT $LN4@ADC

; 552  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 553  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
$LN4@ADC:

; 554  :   }
; 555  :   
; 556  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@ADC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@ADC:
	DD	2
	DD	$LN8@ADC
$LN8@ADC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN6@ADC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN7@ADC
$LN7@ADC:
	DB	98					; 00000062H
	DB	0
$LN6@ADC:
	DB	97					; 00000061H
	DB	0
??$ADC@$00$02$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADC<1,3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADC@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADC@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADC<1,6,0>, COMDAT
; _this$ = ecx

; 536  : void Cpu::ADC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 537  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 538  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 539  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$05$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,6,0>

; 540  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 541  :   reg.raw8[dest] = a + b + carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	add	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	add	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 542  : 
; 543  :   updateCpuFlagC(a,carry,0);

	push	0
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 544  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN3@ADC

; 545  :     updateCpuFlagC(a+carry,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	add	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN3@ADC:

; 546  :   updateCpuFlagH(a,carry,0);

	push	0
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 547  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@ADC

; 548  :     updateCpuFlagH(a+carry,b,0);

	push	0
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN2@ADC:

; 549  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 550  : 
; 551  :   if (opcode == 0x8E){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1081]
	cmp	eax, 142				; 0000008eH
	jne	SHORT $LN4@ADC

; 552  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 553  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
$LN4@ADC:

; 554  :   }
; 555  :   
; 556  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@ADC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@ADC:
	DD	2
	DD	$LN8@ADC
$LN8@ADC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN6@ADC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN7@ADC
$LN7@ADC:
	DB	98					; 00000062H
	DB	0
$LN6@ADC:
	DB	97					; 00000061H
	DB	0
??$ADC@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADC<1,6,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADC@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADC@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADC<1,7,0>, COMDAT
; _this$ = ecx

; 536  : void Cpu::ADC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 537  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 538  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 539  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$06$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,7,0>

; 540  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 541  :   reg.raw8[dest] = a + b + carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	add	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	add	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 542  : 
; 543  :   updateCpuFlagC(a,carry,0);

	push	0
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 544  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN3@ADC

; 545  :     updateCpuFlagC(a+carry,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	add	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN3@ADC:

; 546  :   updateCpuFlagH(a,carry,0);

	push	0
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 547  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@ADC

; 548  :     updateCpuFlagH(a+carry,b,0);

	push	0
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN2@ADC:

; 549  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 550  : 
; 551  :   if (opcode == 0x8E){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1081]
	cmp	eax, 142				; 0000008eH
	jne	SHORT $LN4@ADC

; 552  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 553  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
$LN4@ADC:

; 554  :   }
; 555  :   
; 556  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@ADC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@ADC:
	DD	2
	DD	$LN8@ADC
$LN8@ADC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN6@ADC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN7@ADC
$LN7@ADC:
	DB	98					; 00000062H
	DB	0
$LN6@ADC:
	DB	97					; 00000061H
	DB	0
??$ADC@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADC<1,7,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADC@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADC@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADC<1,4,0>, COMDAT
; _this$ = ecx

; 536  : void Cpu::ADC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 537  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 538  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 539  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$03$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,4,0>

; 540  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 541  :   reg.raw8[dest] = a + b + carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	add	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	add	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 542  : 
; 543  :   updateCpuFlagC(a,carry,0);

	push	0
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 544  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN3@ADC

; 545  :     updateCpuFlagC(a+carry,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	add	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN3@ADC:

; 546  :   updateCpuFlagH(a,carry,0);

	push	0
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 547  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@ADC

; 548  :     updateCpuFlagH(a+carry,b,0);

	push	0
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN2@ADC:

; 549  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 550  : 
; 551  :   if (opcode == 0x8E){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1081]
	cmp	eax, 142				; 0000008eH
	jne	SHORT $LN4@ADC

; 552  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 553  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
$LN4@ADC:

; 554  :   }
; 555  :   
; 556  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@ADC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@ADC:
	DD	2
	DD	$LN8@ADC
$LN8@ADC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN6@ADC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN7@ADC
$LN7@ADC:
	DB	98					; 00000062H
	DB	0
$LN6@ADC:
	DB	97					; 00000061H
	DB	0
??$ADC@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADC<1,4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADC@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADC@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADC<1,5,0>, COMDAT
; _this$ = ecx

; 536  : void Cpu::ADC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 537  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 538  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 539  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$04$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,5,0>

; 540  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 541  :   reg.raw8[dest] = a + b + carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	add	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	add	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 542  : 
; 543  :   updateCpuFlagC(a,carry,0);

	push	0
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 544  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN3@ADC

; 545  :     updateCpuFlagC(a+carry,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	add	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN3@ADC:

; 546  :   updateCpuFlagH(a,carry,0);

	push	0
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 547  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@ADC

; 548  :     updateCpuFlagH(a+carry,b,0);

	push	0
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN2@ADC:

; 549  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 550  : 
; 551  :   if (opcode == 0x8E){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1081]
	cmp	eax, 142				; 0000008eH
	jne	SHORT $LN4@ADC

; 552  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 553  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
$LN4@ADC:

; 554  :   }
; 555  :   
; 556  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@ADC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@ADC:
	DD	2
	DD	$LN8@ADC
$LN8@ADC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN6@ADC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN7@ADC
$LN7@ADC:
	DB	98					; 00000062H
	DB	0
$LN6@ADC:
	DB	97					; 00000061H
	DB	0
??$ADC@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADC<1,5,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADC@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADC@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADC<1,2,0>, COMDAT
; _this$ = ecx

; 536  : void Cpu::ADC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 537  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 538  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 539  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$01$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,2,0>

; 540  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 541  :   reg.raw8[dest] = a + b + carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	add	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	add	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 542  : 
; 543  :   updateCpuFlagC(a,carry,0);

	push	0
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 544  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN3@ADC

; 545  :     updateCpuFlagC(a+carry,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	add	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN3@ADC:

; 546  :   updateCpuFlagH(a,carry,0);

	push	0
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 547  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@ADC

; 548  :     updateCpuFlagH(a+carry,b,0);

	push	0
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN2@ADC:

; 549  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 550  : 
; 551  :   if (opcode == 0x8E){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1081]
	cmp	eax, 142				; 0000008eH
	jne	SHORT $LN4@ADC

; 552  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 553  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
$LN4@ADC:

; 554  :   }
; 555  :   
; 556  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@ADC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@ADC:
	DD	2
	DD	$LN8@ADC
$LN8@ADC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN6@ADC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN7@ADC
$LN7@ADC:
	DB	98					; 00000062H
	DB	0
$LN6@ADC:
	DB	97					; 00000061H
	DB	0
??$ADC@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADC<1,2,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADC@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_carry$ = -29						; size = 1
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADC@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADC<1,3,0>, COMDAT
; _this$ = ecx

; 536  : void Cpu::ADC() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 537  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 538  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 539  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$02$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,0>

; 540  :   uint8_t carry = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _carry$[ebp], al

; 541  :   reg.raw8[dest] = a + b + carry;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	add	ecx, edx
	movzx	eax, BYTE PTR _carry$[ebp]
	add	ecx, eax
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+1064], cl

; 542  : 
; 543  :   updateCpuFlagC(a,carry,0);

	push	0
	movzx	ecx, BYTE PTR _carry$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 544  :   if (reg.F.C==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN3@ADC

; 545  :     updateCpuFlagC(a+carry,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _carry$[ebp]
	add	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC
$LN3@ADC:

; 546  :   updateCpuFlagH(a,carry,0);

	push	0
	movzx	eax, BYTE PTR _carry$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 547  :   if (reg.F.H==0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@ADC

; 548  :     updateCpuFlagH(a+carry,b,0);

	push	0
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _carry$[ebp]
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH
$LN2@ADC:

; 549  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 550  : 
; 551  :   if (opcode == 0x8E){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1081]
	cmp	eax, 142				; 0000008eH
	jne	SHORT $LN4@ADC

; 552  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 553  :           Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
$LN4@ADC:

; 554  :   }
; 555  :   
; 556  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@ADC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@ADC:
	DD	2
	DD	$LN8@ADC
$LN8@ADC:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN6@ADC
	DD	-21					; ffffffebH
	DD	1
	DD	$LN7@ADC
$LN7@ADC:
	DB	98					; 00000062H
	DB	0
$LN6@ADC:
	DB	97					; 00000061H
	DB	0
??$ADC@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADC<1,3,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADD@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADD@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADD<1,1,0>, COMDAT
; _this$ = ecx

; 499  : void Cpu::ADD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 500  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 501  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 502  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$00$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,1,0>

; 503  :   reg.raw8[dest] = a + b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	add	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 504  :   updateCpuFlagC(a,b,0);

	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 505  :   updateCpuFlagH(a,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 506  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 507  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@ADD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@ADD:
	DD	2
	DD	$LN5@ADD
$LN5@ADD:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@ADD
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@ADD
$LN4@ADD:
	DB	98					; 00000062H
	DB	0
$LN3@ADD:
	DB	97					; 00000061H
	DB	0
??$ADD@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADD<1,1,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADD@$00$02$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADD@$00$02$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADD<1,3,1>, COMDAT
; _this$ = ecx

; 499  : void Cpu::ADD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 500  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 501  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 502  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$02$00@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,1>

; 503  :   reg.raw8[dest] = a + b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	add	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 504  :   updateCpuFlagC(a,b,0);

	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 505  :   updateCpuFlagH(a,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 506  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 507  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@ADD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@ADD:
	DD	2
	DD	$LN5@ADD
$LN5@ADD:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@ADD
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@ADD
$LN4@ADD:
	DB	98					; 00000062H
	DB	0
$LN3@ADD:
	DB	97					; 00000061H
	DB	0
??$ADD@$00$02$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADD<1,3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADD@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADD@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADD<1,6,0>, COMDAT
; _this$ = ecx

; 499  : void Cpu::ADD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 500  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 501  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 502  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$05$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,6,0>

; 503  :   reg.raw8[dest] = a + b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	add	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 504  :   updateCpuFlagC(a,b,0);

	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 505  :   updateCpuFlagH(a,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 506  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 507  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@ADD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@ADD:
	DD	2
	DD	$LN5@ADD
$LN5@ADD:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@ADD
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@ADD
$LN4@ADD:
	DB	98					; 00000062H
	DB	0
$LN3@ADD:
	DB	97					; 00000061H
	DB	0
??$ADD@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADD<1,6,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADD@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADD@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADD<1,7,0>, COMDAT
; _this$ = ecx

; 499  : void Cpu::ADD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 500  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 501  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 502  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$06$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,7,0>

; 503  :   reg.raw8[dest] = a + b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	add	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 504  :   updateCpuFlagC(a,b,0);

	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 505  :   updateCpuFlagH(a,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 506  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 507  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@ADD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@ADD:
	DD	2
	DD	$LN5@ADD
$LN5@ADD:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@ADD
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@ADD
$LN4@ADD:
	DB	98					; 00000062H
	DB	0
$LN3@ADD:
	DB	97					; 00000061H
	DB	0
??$ADD@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADD<1,7,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADD@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADD@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADD<1,4,0>, COMDAT
; _this$ = ecx

; 499  : void Cpu::ADD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 500  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 501  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 502  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$03$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,4,0>

; 503  :   reg.raw8[dest] = a + b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	add	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 504  :   updateCpuFlagC(a,b,0);

	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 505  :   updateCpuFlagH(a,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 506  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 507  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@ADD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@ADD:
	DD	2
	DD	$LN5@ADD
$LN5@ADD:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@ADD
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@ADD
$LN4@ADD:
	DB	98					; 00000062H
	DB	0
$LN3@ADD:
	DB	97					; 00000061H
	DB	0
??$ADD@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADD<1,4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADD@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADD@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADD<1,5,0>, COMDAT
; _this$ = ecx

; 499  : void Cpu::ADD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 500  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 501  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 502  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$04$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,5,0>

; 503  :   reg.raw8[dest] = a + b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	add	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 504  :   updateCpuFlagC(a,b,0);

	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 505  :   updateCpuFlagH(a,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 506  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 507  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@ADD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@ADD:
	DD	2
	DD	$LN5@ADD
$LN5@ADD:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@ADD
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@ADD
$LN4@ADD:
	DB	98					; 00000062H
	DB	0
$LN3@ADD:
	DB	97					; 00000061H
	DB	0
??$ADD@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADD<1,5,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADD@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADD@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADD<1,2,0>, COMDAT
; _this$ = ecx

; 499  : void Cpu::ADD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 500  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 501  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 502  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$01$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,2,0>

; 503  :   reg.raw8[dest] = a + b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	add	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 504  :   updateCpuFlagC(a,b,0);

	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 505  :   updateCpuFlagH(a,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 506  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 507  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@ADD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@ADD:
	DD	2
	DD	$LN5@ADD
$LN5@ADD:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@ADD
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@ADD
$LN4@ADD:
	DB	98					; 00000062H
	DB	0
$LN3@ADD:
	DB	97					; 00000061H
	DB	0
??$ADD@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADD<1,2,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADD@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_b$ = -21						; size = 1
_a$ = -9						; size = 1
_this$ = -4						; size = 4
??$ADD@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::ADD<1,3,0>, COMDAT
; _this$ = ecx

; 499  : void Cpu::ADD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 500  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 501  :   uint8_t a=0,b=0;

	mov	BYTE PTR _a$[ebp], 0
	mov	BYTE PTR _b$[ebp], 0

; 502  :   arithmeticMode<dest,src,mode>(a,b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$arithmeticMode@$00$02$0A@@Cpu@gb@emulation@@AAEXAAE0@Z ; emulation::gb::Cpu::arithmeticMode<1,3,0>

; 503  :   reg.raw8[dest] = a + b;

	movzx	edx, BYTE PTR _a$[ebp]
	movzx	eax, BYTE PTR _b$[ebp]
	add	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+1064], dl

; 504  :   updateCpuFlagC(a,b,0);

	push	0
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 505  :   updateCpuFlagH(a,b,0);

	push	0
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 506  :   updateCpuFlagZ(reg.raw8[dest]);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 507  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@ADD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@ADD:
	DD	2
	DD	$LN5@ADD
$LN5@ADD:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@ADD
	DD	-21					; ffffffebH
	DD	1
	DD	$LN4@ADD
$LN4@ADD:
	DB	98					; 00000062H
	DB	0
$LN3@ADD:
	DB	97					; 00000061H
	DB	0
??$ADD@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::ADD<1,3,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$00$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$00$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<1,1>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$00$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<1,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDr$r@$00$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDr$r@$00$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDr$r<1,3>, COMDAT
; _this$ = ecx

; 397  : void Cpu::LDr$r() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 398  : 	reg.raw8[dest] = mem_->Read8(reg.raw16[src]);

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 399  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDr$r@$00$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDr$r<1,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$00$05@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$00$05@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<1,6>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 6
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$00$05@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<1,6>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$00$06@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$00$06@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<1,7>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 7
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$00$06@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<1,7>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$00$03@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$00$03@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<1,4>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 2
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$00$03@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<1,4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$00$04@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$00$04@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<1,5>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 5
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$00$04@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<1,5>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$00$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$00$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<1,2>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$00$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<1,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$00$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$00$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<1,3>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 3
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$00$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<1,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD$rr@$02$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LD$rr@$02$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD$rr<3,1>, COMDAT
; _this$ = ecx

; 392  : void Cpu::LD$rr() { //(dest), src

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 393  : 	mem_->Write8(reg.raw16[dest],reg.raw8[src]);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 394  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD$rr@$02$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD$rr<3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD$rr@$02$05@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LD$rr@$02$05@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD$rr<3,6>, COMDAT
; _this$ = ecx

; 392  : void Cpu::LD$rr() { //(dest), src

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 393  : 	mem_->Write8(reg.raw16[dest],reg.raw8[src]);

	mov	eax, 1
	imul	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 394  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD$rr@$02$05@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD$rr<3,6>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD$rr@$02$06@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LD$rr@$02$06@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD$rr<3,7>, COMDAT
; _this$ = ecx

; 392  : void Cpu::LD$rr() { //(dest), src

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 393  : 	mem_->Write8(reg.raw16[dest],reg.raw8[src]);

	mov	eax, 1
	imul	eax, 7
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 394  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD$rr@$02$06@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD$rr<3,7>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD$rr@$02$03@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LD$rr@$02$03@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD$rr<3,4>, COMDAT
; _this$ = ecx

; 392  : void Cpu::LD$rr() { //(dest), src

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 393  : 	mem_->Write8(reg.raw16[dest],reg.raw8[src]);

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 394  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD$rr@$02$03@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD$rr<3,4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD$rr@$02$04@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LD$rr@$02$04@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD$rr<3,5>, COMDAT
; _this$ = ecx

; 392  : void Cpu::LD$rr() { //(dest), src

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 393  : 	mem_->Write8(reg.raw16[dest],reg.raw8[src]);

	mov	eax, 1
	imul	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 394  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD$rr@$02$04@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD$rr<3,5>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD$rr@$02$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LD$rr@$02$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD$rr<3,2>, COMDAT
; _this$ = ecx

; 392  : void Cpu::LD$rr() { //(dest), src

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 393  : 	mem_->Write8(reg.raw16[dest],reg.raw8[src]);

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 394  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD$rr@$02$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD$rr<3,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD$rr@$02$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LD$rr@$02$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD$rr<3,3>, COMDAT
; _this$ = ecx

; 392  : void Cpu::LD$rr() { //(dest), src

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 393  : 	mem_->Write8(reg.raw16[dest],reg.raw8[src]);

	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 394  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD$rr@$02$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD$rr<3,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$05$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$05$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<6,1>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$05$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<6,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDr$r@$05$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDr$r@$05$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDr$r<6,3>, COMDAT
; _this$ = ecx

; 397  : void Cpu::LDr$r() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 398  : 	reg.raw8[dest] = mem_->Read8(reg.raw16[src]);

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 399  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDr$r@$05$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDr$r<6,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$05$05@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$05$05@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<6,6>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 6
	mov	ecx, 1
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$05$05@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<6,6>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$05$06@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$05$06@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<6,7>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 7
	mov	ecx, 1
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$05$06@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<6,7>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$05$03@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$05$03@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<6,4>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 2
	mov	ecx, 1
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$05$03@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<6,4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$05$04@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$05$04@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<6,5>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 5
	mov	ecx, 1
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$05$04@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<6,5>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$05$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$05$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<6,2>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$05$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<6,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$05$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$05$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<6,3>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 3
	mov	ecx, 1
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$05$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<6,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$06$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$06$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<7,1>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$06$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<7,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDr$r@$06$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDr$r@$06$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDr$r<7,3>, COMDAT
; _this$ = ecx

; 397  : void Cpu::LDr$r() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 398  : 	reg.raw8[dest] = mem_->Read8(reg.raw16[src]);

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 399  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDr$r@$06$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDr$r<7,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$06$05@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$06$05@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<7,6>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 6
	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$06$05@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<7,6>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$06$06@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$06$06@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<7,7>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 7
	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$06$06@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<7,7>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$06$03@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$06$03@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<7,4>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 2
	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$06$03@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<7,4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$06$04@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$06$04@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<7,5>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 5
	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$06$04@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<7,5>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$06$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$06$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<7,2>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$06$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<7,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$06$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$06$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<7,3>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 3
	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$06$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<7,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$03$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$03$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<4,1>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$03$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<4,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDr$r@$03$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDr$r@$03$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDr$r<4,3>, COMDAT
; _this$ = ecx

; 397  : void Cpu::LDr$r() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 398  : 	reg.raw8[dest] = mem_->Read8(reg.raw16[src]);

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 399  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDr$r@$03$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDr$r<4,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$03$05@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$03$05@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<4,6>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 6
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$03$05@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<4,6>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$03$06@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$03$06@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<4,7>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 7
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$03$06@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<4,7>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$03$03@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$03$03@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<4,4>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 2
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$03$03@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<4,4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$03$04@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$03$04@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<4,5>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 5
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$03$04@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<4,5>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$03$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$03$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<4,2>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$03$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<4,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$03$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$03$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<4,3>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 3
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$03$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<4,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$04$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$04$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<5,1>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$04$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<5,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDr$r@$04$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDr$r@$04$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDr$r<5,3>, COMDAT
; _this$ = ecx

; 397  : void Cpu::LDr$r() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 398  : 	reg.raw8[dest] = mem_->Read8(reg.raw16[src]);

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 399  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDr$r@$04$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDr$r<5,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$04$05@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$04$05@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<5,6>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 6
	mov	ecx, 1
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$04$05@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<5,6>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$04$06@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$04$06@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<5,7>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 7
	mov	ecx, 1
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$04$06@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<5,7>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$04$03@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$04$03@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<5,4>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 2
	mov	ecx, 1
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$04$03@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<5,4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$04$04@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$04$04@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<5,5>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 5
	mov	ecx, 1
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$04$04@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<5,5>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$04$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$04$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<5,2>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$04$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<5,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$04$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$04$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<5,3>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 3
	mov	ecx, 1
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$04$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<5,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$01$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$01$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<2,1>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$01$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<2,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDr$r@$01$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDr$r@$01$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDr$r<2,3>, COMDAT
; _this$ = ecx

; 397  : void Cpu::LDr$r() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 398  : 	reg.raw8[dest] = mem_->Read8(reg.raw16[src]);

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 399  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDr$r@$01$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDr$r<2,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$01$05@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$01$05@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<2,6>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 6
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$01$05@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<2,6>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$01$06@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$01$06@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<2,7>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 7
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$01$06@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<2,7>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$01$03@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$01$03@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<2,4>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 2
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$01$03@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<2,4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$01$04@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$01$04@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<2,5>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 5
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$01$04@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<2,5>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$01$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$01$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<2,2>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$01$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<2,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$01$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$01$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<2,3>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 3
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$01$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<2,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$02$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$02$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<3,1>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$02$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDr$r@$02$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDr$r@$02$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDr$r<3,3>, COMDAT
; _this$ = ecx

; 397  : void Cpu::LDr$r() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 398  : 	reg.raw8[dest] = mem_->Read8(reg.raw16[src]);

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 399  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDr$r@$02$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDr$r<3,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$02$05@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$02$05@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<3,6>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 6
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$02$05@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<3,6>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$02$06@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$02$06@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<3,7>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 7
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$02$06@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<3,7>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$02$03@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$02$03@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<3,4>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 2
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$02$03@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<3,4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$02$04@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$02$04@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<3,5>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 5
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$02$04@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<3,5>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$02$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$02$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<3,2>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$02$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<3,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrr@$02$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDrr@$02$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrr<3,3>, COMDAT
; _this$ = ecx

; 387  : void Cpu::LDrr() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	reg.raw8[dest] = reg.raw8[src];

	mov	eax, 1
	imul	eax, 3
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [esi+eax+1064]
	mov	BYTE PTR [edx+ecx+1064], al

; 389  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrr@$02$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrr<3,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD@$00$0A@$09@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv245 = -32						; size = 2
tv232 = -30						; size = 2
tv206 = -28						; size = 2
tv193 = -26						; size = 2
tv169 = -24						; size = 2
tv145 = -22						; size = 2
tv92 = -20						; size = 2
tv79 = -18						; size = 2
_d16$1 = -16						; size = 2
_d16$2 = -12						; size = 2
_a8$3 = -7						; size = 1
_a8$4 = -6						; size = 1
_d8$5 = -5						; size = 1
_this$ = -4						; size = 4
??$LD@$00$0A@$09@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD<1,0,10>, COMDAT
; _this$ = ecx

; 446  : void Cpu::LD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 447  :   if (mode == 10) { //dest,d8

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN11@LD

; 448  : 		reg.raw8[dest] = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv79[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN11@LD:

; 449  : 	}else if (mode == 11) { //(dest),d8

	xor	edx, edx
	je	SHORT $LN9@LD

; 450  : 		auto d8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _d8$5[ebp], al

; 451  : 		mem_->Write8(reg.raw16[dest],d8);

	movzx	ecx, BYTE PTR _d8$5[ebp]
	push	ecx
	mov	edx, 2
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN9@LD:

; 452  : 	} else if (mode == 12) { //0xFF00+d8 src

	xor	eax, eax
	je	SHORT $LN7@LD

; 453  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv145[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$4[ebp], al

; 454  : 		mem_->Write8(0xFF00+a8,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, BYTE PTR _a8$4[ebp]
	add	edx, 65280				; 0000ff00H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN7@LD:

; 455  : 	} else if (mode == 13) { //dest,0xFF00+d8 

	xor	ecx, ecx
	je	SHORT $LN5@LD

; 456  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv169[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv169[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$3[ebp], al

; 457  : 		reg.raw8[dest] = mem_->Read8(0xFF00+a8);

	movzx	eax, BYTE PTR _a8$3[ebp]
	add	eax, 65280				; 0000ff00H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN5@LD:

; 458  : 	} else if (mode == 14) { //(d16),src

	xor	edx, edx
	je	$LN3@LD

; 459  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv193[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv193[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _d16$2[ebp], cx

; 460  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv206[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv206[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _d16$2[ebp]
	or	ecx, eax
	mov	WORD PTR _d16$2[ebp], cx

; 461  :     mem_->Write8(d16,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, WORD PTR _d16$2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN3@LD:

; 462  : 	} else if (mode == 15) { //src,(d16)

	xor	ecx, ecx
	je	$LN12@LD

; 463  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv232[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv232[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	ax, al
	mov	WORD PTR _d16$1[ebp], ax

; 464  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv245[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	movzx	eax, WORD PTR _d16$1[ebp]
	or	eax, edx
	mov	WORD PTR _d16$1[ebp], ax

; 465  :     reg.raw8[dest] = mem_->Read8(d16);

	movzx	ecx, WORD PTR _d16$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al
$LN12@LD:

; 466  : 	}
; 467  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD@$00$0A@$09@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD<1,0,10>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$DEC_8bit@$00$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$DEC_8bit@$00$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::DEC_8bit<1,0>, COMDAT
; _this$ = ecx

; 796  : void Cpu::DEC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 797  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 798  : 
; 799  :   if (mode==0) {

	mov	eax, 1
	test	eax, eax
	je	$LN6@DEC_8bit

; 800  :     //updateCpuFlagH(reg.raw8[dest],1,1);
; 801  :     --reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	sub	al, 1
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 802  :     if ((reg.raw8[dest]&0xF)==0xF)

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	and	edx, 15					; 0000000fH
	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN5@DEC_8bit

; 803  :       reg.F.H = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 804  :     else 

	jmp	SHORT $LN4@DEC_8bit
$LN5@DEC_8bit:

; 805  :       reg.F.H = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
$LN4@DEC_8bit:

; 806  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 807  :   } else {

	jmp	$LN7@DEC_8bit
$LN6@DEC_8bit:

; 808  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 809  : 
; 810  :     //updateCpuFlagH(data,1,1);
; 811  :     --data;

	mov	al, BYTE PTR _data$1[ebp]
	sub	al, 1
	mov	BYTE PTR _data$1[ebp], al

; 812  :     if ((data&0xF)==0xF)

	movzx	ecx, BYTE PTR _data$1[ebp]
	and	ecx, 15					; 0000000fH
	cmp	ecx, 15					; 0000000fH
	jne	SHORT $LN2@DEC_8bit

; 813  :       reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 814  :     else

	jmp	SHORT $LN1@DEC_8bit
$LN2@DEC_8bit:

; 815  :       reg.F.H = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 223					; 000000dfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al
$LN1@DEC_8bit:

; 816  :     updateCpuFlagZ(data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 817  :     mem_->Write8(reg.HL,data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+1070]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
$LN7@DEC_8bit:

; 818  : 
; 819  :   }
; 820  :   
; 821  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$DEC_8bit@$00$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::DEC_8bit<1,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$INC_8bit@$00$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$INC_8bit@$00$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::INC_8bit<1,0>, COMDAT
; _this$ = ecx

; 770  : void Cpu::INC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 771  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 772  : 
; 773  :   if (mode==0) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@INC_8bit

; 774  :     updateCpuFlagH(reg.raw8[dest],1,0);

	push	0
	push	1
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+1064]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 775  :     ++reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	add	al, 1
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 776  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 777  :   } else {

	jmp	SHORT $LN3@INC_8bit
$LN2@INC_8bit:

; 778  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 779  : 		updateCpuFlagH(data,1,0);

	push	0
	push	1
	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 780  :     ++data;

	mov	cl, BYTE PTR _data$1[ebp]
	add	cl, 1
	mov	BYTE PTR _data$1[ebp], cl

; 781  :     mem_->Write8(reg.HL,data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 782  :      updateCpuFlagZ(data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
$LN3@INC_8bit:

; 783  :   }
; 784  :     
; 785  :  
; 786  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$INC_8bit@$00$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::INC_8bit<1,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$DEC_16bit@$03@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$DEC_16bit@$03@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::DEC_16bit<4>, COMDAT
; _this$ = ecx

; 824  : void Cpu::DEC_16bit() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 825  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 826  :   --reg.raw16[dest];

	mov	eax, 2
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+eax+1064]
	sub	dx, 1
	mov	eax, 2
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax+1064], dx

; 827  :   Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 828  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$DEC_16bit@$03@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::DEC_16bit<4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDDreg$reg@$00$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDDreg$reg@$00$02@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::LDDreg$reg<1,3>, COMDAT
; _this$ = ecx

; 439  : void Cpu::LDDreg$reg() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 440  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 441  :   reg.raw8[dest] = mem_->Read8(reg.raw16[src]);

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 442  :   --reg.raw16[src];

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+eax+1064]
	sub	dx, 1
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax+1064], dx

; 443  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDDreg$reg@$00$02@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::LDDreg$reg<1,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADD_16bit@$02$03@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv148 = -28						; size = 4
tv130 = -24						; size = 4
_r2$ = -20						; size = 4
_r1$ = -16						; size = 2
_b$ = -12						; size = 2
_a$ = -8						; size = 2
_this$ = -4						; size = 4
??$ADD_16bit@$02$03@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::ADD_16bit<3,4>, COMDAT
; _this$ = ecx

; 510  : void Cpu::ADD_16bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 511  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 512  :   uint16_t a=0,b=0;

	xor	eax, eax
	mov	WORD PTR _a$[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _b$[ebp], cx

; 513  :   a = reg.raw16[dest];

	mov	edx, 2
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+edx+1064]
	mov	WORD PTR _a$[ebp], cx

; 514  :   b = reg.raw16[src];

	mov	edx, 2
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+edx+1064]
	mov	WORD PTR _b$[ebp], cx

; 515  :   reg.raw16[dest] = a + b;

	movzx	edx, WORD PTR _a$[ebp]
	movzx	eax, WORD PTR _b$[ebp]
	add	edx, eax
	mov	ecx, 2
	imul	ecx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+1064], dx

; 516  :   uint16_t r1 = (a&0xFFF) + (b&0xFFF);

	movzx	ecx, WORD PTR _a$[ebp]
	and	ecx, 4095				; 00000fffH
	movzx	edx, WORD PTR _b$[ebp]
	and	edx, 4095				; 00000fffH
	add	ecx, edx
	mov	WORD PTR _r1$[ebp], cx

; 517  :   reg.F.H = r1>0xFFF?1:0;

	movzx	eax, WORD PTR _r1$[ebp]
	cmp	eax, 4095				; 00000fffH
	jle	SHORT $LN3@ADD_16bit
	mov	DWORD PTR tv130[ebp], 1
	jmp	SHORT $LN4@ADD_16bit
$LN3@ADD_16bit:
	mov	DWORD PTR tv130[ebp], 0
$LN4@ADD_16bit:
	mov	cl, BYTE PTR tv130[ebp]
	and	cl, 1
	shl	cl, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 223					; 000000dfH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 518  :   uint32_t r2 = (a&0xFFFF) + (b&0xFFFF);

	movzx	edx, WORD PTR _a$[ebp]
	and	edx, 65535				; 0000ffffH
	movzx	eax, WORD PTR _b$[ebp]
	and	eax, 65535				; 0000ffffH
	add	edx, eax
	mov	DWORD PTR _r2$[ebp], edx

; 519  :   reg.F.C = r2>0xFFFF?1:0;

	cmp	DWORD PTR _r2$[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN5@ADD_16bit
	mov	DWORD PTR tv148[ebp], 1
	jmp	SHORT $LN6@ADD_16bit
$LN5@ADD_16bit:
	mov	DWORD PTR tv148[ebp], 0
$LN6@ADD_16bit:
	mov	cl, BYTE PTR tv148[ebp]
	and	cl, 1
	shl	cl, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 239					; 000000efH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 520  : 	Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 521  : }

	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$ADD_16bit@$02$03@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::ADD_16bit<3,4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$JR_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv92 = -24						; size = 2
_disp8$1 = -21						; size = 1
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$JR_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::JR_cc<4,0>, COMDAT
; _this$ = ecx

; 757  : void Cpu::JR_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 758  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 16					; 00000010H
	sar	ecx, 4
	mov	DWORD PTR _table$[ebp], ecx

; 759  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 16					; 00000010H
	sar	eax, 4
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 760  : 
; 761  :   if (table[inv]&1) {

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN2@JR_cc

; 762  : 		JR();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JR@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::JR

; 763  :   } else {

	jmp	SHORT $LN3@JR_cc
$LN2@JR_cc:

; 764  :     int8_t disp8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _disp8$1[ebp], al
$LN3@JR_cc:

; 765  :   }
; 766  : 
; 767  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@JR_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@JR_cc:
	DD	1
	DD	$LN6@JR_cc
$LN6@JR_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@JR_cc
$LN5@JR_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$JR_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::JR_cc<4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD@$02$0A@$0L@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv245 = -32						; size = 2
tv232 = -30						; size = 2
tv206 = -28						; size = 2
tv193 = -26						; size = 2
tv169 = -24						; size = 2
tv145 = -22						; size = 2
tv92 = -20						; size = 2
tv79 = -18						; size = 2
_d16$1 = -16						; size = 2
_d16$2 = -12						; size = 2
_a8$3 = -7						; size = 1
_a8$4 = -6						; size = 1
_d8$5 = -5						; size = 1
_this$ = -4						; size = 4
??$LD@$02$0A@$0L@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD<3,0,11>, COMDAT
; _this$ = ecx

; 446  : void Cpu::LD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 447  :   if (mode == 10) { //dest,d8

	xor	eax, eax
	je	SHORT $LN11@LD

; 448  : 		reg.raw8[dest] = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv79[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	imul	edx, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN11@LD:

; 449  : 	}else if (mode == 11) { //(dest),d8

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN9@LD

; 450  : 		auto d8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _d8$5[ebp], al

; 451  : 		mem_->Write8(reg.raw16[dest],d8);

	movzx	ecx, BYTE PTR _d8$5[ebp]
	push	ecx
	mov	edx, 2
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN9@LD:

; 452  : 	} else if (mode == 12) { //0xFF00+d8 src

	xor	eax, eax
	je	SHORT $LN7@LD

; 453  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv145[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$4[ebp], al

; 454  : 		mem_->Write8(0xFF00+a8,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, BYTE PTR _a8$4[ebp]
	add	edx, 65280				; 0000ff00H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN7@LD:

; 455  : 	} else if (mode == 13) { //dest,0xFF00+d8 

	xor	ecx, ecx
	je	SHORT $LN5@LD

; 456  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv169[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv169[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$3[ebp], al

; 457  : 		reg.raw8[dest] = mem_->Read8(0xFF00+a8);

	movzx	eax, BYTE PTR _a8$3[ebp]
	add	eax, 65280				; 0000ff00H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	imul	edx, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN5@LD:

; 458  : 	} else if (mode == 14) { //(d16),src

	xor	edx, edx
	je	$LN3@LD

; 459  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv193[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv193[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _d16$2[ebp], cx

; 460  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv206[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv206[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _d16$2[ebp]
	or	ecx, eax
	mov	WORD PTR _d16$2[ebp], cx

; 461  :     mem_->Write8(d16,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, WORD PTR _d16$2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN3@LD:

; 462  : 	} else if (mode == 15) { //src,(d16)

	xor	ecx, ecx
	je	$LN12@LD

; 463  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv232[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv232[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	ax, al
	mov	WORD PTR _d16$1[ebp], ax

; 464  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv245[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	movzx	eax, WORD PTR _d16$1[ebp]
	or	eax, edx
	mov	WORD PTR _d16$1[ebp], ax

; 465  :     reg.raw8[dest] = mem_->Read8(d16);

	movzx	ecx, WORD PTR _d16$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al
$LN12@LD:

; 466  : 	}
; 467  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD@$02$0A@$0L@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD<3,0,11>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$DEC_8bit@$02$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$DEC_8bit@$02$00@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::DEC_8bit<3,1>, COMDAT
; _this$ = ecx

; 796  : void Cpu::DEC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 797  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 798  : 
; 799  :   if (mode==0) {

	xor	eax, eax
	je	$LN6@DEC_8bit

; 800  :     //updateCpuFlagH(reg.raw8[dest],1,1);
; 801  :     --reg.raw8[dest];

	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	sub	al, 1
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 802  :     if ((reg.raw8[dest]&0xF)==0xF)

	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	and	edx, 15					; 0000000fH
	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN5@DEC_8bit

; 803  :       reg.F.H = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 804  :     else 

	jmp	SHORT $LN4@DEC_8bit
$LN5@DEC_8bit:

; 805  :       reg.F.H = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
$LN4@DEC_8bit:

; 806  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 807  :   } else {

	jmp	$LN7@DEC_8bit
$LN6@DEC_8bit:

; 808  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 809  : 
; 810  :     //updateCpuFlagH(data,1,1);
; 811  :     --data;

	mov	al, BYTE PTR _data$1[ebp]
	sub	al, 1
	mov	BYTE PTR _data$1[ebp], al

; 812  :     if ((data&0xF)==0xF)

	movzx	ecx, BYTE PTR _data$1[ebp]
	and	ecx, 15					; 0000000fH
	cmp	ecx, 15					; 0000000fH
	jne	SHORT $LN2@DEC_8bit

; 813  :       reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 814  :     else

	jmp	SHORT $LN1@DEC_8bit
$LN2@DEC_8bit:

; 815  :       reg.F.H = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 223					; 000000dfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al
$LN1@DEC_8bit:

; 816  :     updateCpuFlagZ(data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 817  :     mem_->Write8(reg.HL,data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+1070]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
$LN7@DEC_8bit:

; 818  : 
; 819  :   }
; 820  :   
; 821  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$DEC_8bit@$02$00@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::DEC_8bit<3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$INC_8bit@$02$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$INC_8bit@$02$00@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::INC_8bit<3,1>, COMDAT
; _this$ = ecx

; 770  : void Cpu::INC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 771  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 772  : 
; 773  :   if (mode==0) {

	xor	eax, eax
	je	SHORT $LN2@INC_8bit

; 774  :     updateCpuFlagH(reg.raw8[dest],1,0);

	push	0
	push	1
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+1064]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 775  :     ++reg.raw8[dest];

	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	add	al, 1
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 776  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 777  :   } else {

	jmp	SHORT $LN3@INC_8bit
$LN2@INC_8bit:

; 778  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 779  : 		updateCpuFlagH(data,1,0);

	push	0
	push	1
	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 780  :     ++data;

	mov	cl, BYTE PTR _data$1[ebp]
	add	cl, 1
	mov	BYTE PTR _data$1[ebp], cl

; 781  :     mem_->Write8(reg.HL,data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 782  :      updateCpuFlagZ(data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
$LN3@INC_8bit:

; 783  :   }
; 784  :     
; 785  :  
; 786  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$INC_8bit@$02$00@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::INC_8bit<3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$INC_16bit@$03@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$INC_16bit@$03@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::INC_16bit<4>, COMDAT
; _this$ = ecx

; 789  : void Cpu::INC_16bit() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 790  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 791  :   ++reg.raw16[dest];

	mov	eax, 2
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+eax+1064]
	add	dx, 1
	mov	eax, 2
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax+1064], dx

; 792  :   Tick();Tick();Tick();Tick(); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 793  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$INC_16bit@$03@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::INC_16bit<4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDD$regreg@$02$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDD$regreg@$02$00@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::LDD$regreg<3,1>, COMDAT
; _this$ = ecx

; 426  : void Cpu::LDD$regreg() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	mem_->Write8(reg.raw16[dest],reg.raw8[src]);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 428  : 	--reg.raw16[dest];

	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+ecx+1064]
	sub	ax, 1
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx+1064], ax

; 429  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDD$regreg@$02$00@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::LDD$regreg<3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrd16@$03@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv95 = -8						; size = 2
tv78 = -6						; size = 2
_this$ = -4						; size = 4
??$LDrd16@$03@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrd16<4>, COMDAT
; _this$ = ecx

; 412  : void Cpu::LDrd16() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 413  : 	reg.raw16[dest] = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv78[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv78[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	edx, 2
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+edx+1064], cx

; 414  : 	reg.raw16[dest] |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv95[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv95[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	mov	eax, 2
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [ecx+eax+1064]
	or	eax, edx
	mov	ecx, 2
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx+1064], ax

; 415  :   if (dest != RegAF && (reg.raw16[dest]>=0xFE00&&reg.raw16[dest]<=0xFEFF) && emu_->lcd_driver()->lcdc().lcd_enable == 1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@LDrd16
	mov	ecx, 2
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+ecx+1064]
	cmp	eax, 65024				; 0000fe00H
	jl	SHORT $LN2@LDrd16
	mov	ecx, 2
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+ecx+1064]
	cmp	eax, 65279				; 0000feffH
	jg	SHORT $LN2@LDrd16
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?lcd_driver@Emu@gb@emulation@@QAEPAVLCDDriver@23@XZ ; emulation::gb::Emu::lcd_driver
	mov	ecx, eax
	call	?lcdc@LCDDriver@gb@emulation@@QAEABTLCDControlRegister@23@XZ ; emulation::gb::LCDDriver::lcdc
	mov	dl, BYTE PTR [eax]
	shr	dl, 7
	and	dl, 1
	movzx	eax, dl
	cmp	eax, 1
	jne	SHORT $LN2@LDrd16

; 416  :     sprite_bug = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+8], 2
$LN2@LDrd16:

; 417  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrd16@$03@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrd16<4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$JR_cc@$03$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv92 = -24						; size = 2
_disp8$1 = -21						; size = 1
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$JR_cc@$03$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::JR_cc<4,1>, COMDAT
; _this$ = ecx

; 757  : void Cpu::JR_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 758  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 16					; 00000010H
	sar	ecx, 4
	mov	DWORD PTR _table$[ebp], ecx

; 759  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 16					; 00000010H
	sar	eax, 4
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 760  : 
; 761  :   if (table[inv]&1) {

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN2@JR_cc

; 762  : 		JR();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JR@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::JR

; 763  :   } else {

	jmp	SHORT $LN3@JR_cc
$LN2@JR_cc:

; 764  :     int8_t disp8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _disp8$1[ebp], al
$LN3@JR_cc:

; 765  :   }
; 766  : 
; 767  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@JR_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@JR_cc:
	DD	1
	DD	$LN6@JR_cc
$LN6@JR_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@JR_cc
$LN5@JR_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$JR_cc@$03$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::JR_cc<4,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD@$05$0A@$09@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv245 = -32						; size = 2
tv232 = -30						; size = 2
tv206 = -28						; size = 2
tv193 = -26						; size = 2
tv169 = -24						; size = 2
tv145 = -22						; size = 2
tv92 = -20						; size = 2
tv79 = -18						; size = 2
_d16$1 = -16						; size = 2
_d16$2 = -12						; size = 2
_a8$3 = -7						; size = 1
_a8$4 = -6						; size = 1
_d8$5 = -5						; size = 1
_this$ = -4						; size = 4
??$LD@$05$0A@$09@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD<6,0,10>, COMDAT
; _this$ = ecx

; 446  : void Cpu::LD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 447  :   if (mode == 10) { //dest,d8

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN11@LD

; 448  : 		reg.raw8[dest] = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv79[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	imul	edx, 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN11@LD:

; 449  : 	}else if (mode == 11) { //(dest),d8

	xor	edx, edx
	je	SHORT $LN9@LD

; 450  : 		auto d8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _d8$5[ebp], al

; 451  : 		mem_->Write8(reg.raw16[dest],d8);

	movzx	ecx, BYTE PTR _d8$5[ebp]
	push	ecx
	mov	edx, 2
	imul	edx, 6
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN9@LD:

; 452  : 	} else if (mode == 12) { //0xFF00+d8 src

	xor	eax, eax
	je	SHORT $LN7@LD

; 453  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv145[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$4[ebp], al

; 454  : 		mem_->Write8(0xFF00+a8,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, BYTE PTR _a8$4[ebp]
	add	edx, 65280				; 0000ff00H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN7@LD:

; 455  : 	} else if (mode == 13) { //dest,0xFF00+d8 

	xor	ecx, ecx
	je	SHORT $LN5@LD

; 456  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv169[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv169[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$3[ebp], al

; 457  : 		reg.raw8[dest] = mem_->Read8(0xFF00+a8);

	movzx	eax, BYTE PTR _a8$3[ebp]
	add	eax, 65280				; 0000ff00H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	imul	edx, 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN5@LD:

; 458  : 	} else if (mode == 14) { //(d16),src

	xor	edx, edx
	je	$LN3@LD

; 459  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv193[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv193[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _d16$2[ebp], cx

; 460  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv206[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv206[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _d16$2[ebp]
	or	ecx, eax
	mov	WORD PTR _d16$2[ebp], cx

; 461  :     mem_->Write8(d16,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, WORD PTR _d16$2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN3@LD:

; 462  : 	} else if (mode == 15) { //src,(d16)

	xor	ecx, ecx
	je	$LN12@LD

; 463  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv232[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv232[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	ax, al
	mov	WORD PTR _d16$1[ebp], ax

; 464  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv245[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	movzx	eax, WORD PTR _d16$1[ebp]
	or	eax, edx
	mov	WORD PTR _d16$1[ebp], ax

; 465  :     reg.raw8[dest] = mem_->Read8(d16);

	movzx	ecx, WORD PTR _d16$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al
$LN12@LD:

; 466  : 	}
; 467  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD@$05$0A@$09@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD<6,0,10>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$DEC_8bit@$05$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$DEC_8bit@$05$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::DEC_8bit<6,0>, COMDAT
; _this$ = ecx

; 796  : void Cpu::DEC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 797  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 798  : 
; 799  :   if (mode==0) {

	mov	eax, 1
	test	eax, eax
	je	$LN6@DEC_8bit

; 800  :     //updateCpuFlagH(reg.raw8[dest],1,1);
; 801  :     --reg.raw8[dest];

	mov	ecx, 1
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	sub	al, 1
	mov	ecx, 1
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 802  :     if ((reg.raw8[dest]&0xF)==0xF)

	mov	eax, 1
	imul	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	and	edx, 15					; 0000000fH
	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN5@DEC_8bit

; 803  :       reg.F.H = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 804  :     else 

	jmp	SHORT $LN4@DEC_8bit
$LN5@DEC_8bit:

; 805  :       reg.F.H = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
$LN4@DEC_8bit:

; 806  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	imul	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 807  :   } else {

	jmp	$LN7@DEC_8bit
$LN6@DEC_8bit:

; 808  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 809  : 
; 810  :     //updateCpuFlagH(data,1,1);
; 811  :     --data;

	mov	al, BYTE PTR _data$1[ebp]
	sub	al, 1
	mov	BYTE PTR _data$1[ebp], al

; 812  :     if ((data&0xF)==0xF)

	movzx	ecx, BYTE PTR _data$1[ebp]
	and	ecx, 15					; 0000000fH
	cmp	ecx, 15					; 0000000fH
	jne	SHORT $LN2@DEC_8bit

; 813  :       reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 814  :     else

	jmp	SHORT $LN1@DEC_8bit
$LN2@DEC_8bit:

; 815  :       reg.F.H = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 223					; 000000dfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al
$LN1@DEC_8bit:

; 816  :     updateCpuFlagZ(data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 817  :     mem_->Write8(reg.HL,data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+1070]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
$LN7@DEC_8bit:

; 818  : 
; 819  :   }
; 820  :   
; 821  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$DEC_8bit@$05$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::DEC_8bit<6,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$INC_8bit@$05$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$INC_8bit@$05$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::INC_8bit<6,0>, COMDAT
; _this$ = ecx

; 770  : void Cpu::INC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 771  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 772  : 
; 773  :   if (mode==0) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@INC_8bit

; 774  :     updateCpuFlagH(reg.raw8[dest],1,0);

	push	0
	push	1
	mov	ecx, 1
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+1064]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 775  :     ++reg.raw8[dest];

	mov	ecx, 1
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	add	al, 1
	mov	ecx, 1
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 776  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	imul	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 777  :   } else {

	jmp	SHORT $LN3@INC_8bit
$LN2@INC_8bit:

; 778  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 779  : 		updateCpuFlagH(data,1,0);

	push	0
	push	1
	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 780  :     ++data;

	mov	cl, BYTE PTR _data$1[ebp]
	add	cl, 1
	mov	BYTE PTR _data$1[ebp], cl

; 781  :     mem_->Write8(reg.HL,data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 782  :      updateCpuFlagZ(data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
$LN3@INC_8bit:

; 783  :   }
; 784  :     
; 785  :  
; 786  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$INC_8bit@$05$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::INC_8bit<6,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$DEC_16bit@$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$DEC_16bit@$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::DEC_16bit<3>, COMDAT
; _this$ = ecx

; 824  : void Cpu::DEC_16bit() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 825  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 826  :   --reg.raw16[dest];

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+eax+1064]
	sub	dx, 1
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax+1064], dx

; 827  :   Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 828  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$DEC_16bit@$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::DEC_16bit<3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDIreg$reg@$00$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDIreg$reg@$00$02@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::LDIreg$reg<1,3>, COMDAT
; _this$ = ecx

; 432  : void Cpu::LDIreg$reg() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 433  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 434  :   reg.raw8[dest] = mem_->Read8(reg.raw16[src]);

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 435  :   ++reg.raw16[src];

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+eax+1064]
	add	dx, 1
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax+1064], dx

; 436  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDIreg$reg@$00$02@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::LDIreg$reg<1,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADD_16bit@$02$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv148 = -28						; size = 4
tv130 = -24						; size = 4
_r2$ = -20						; size = 4
_r1$ = -16						; size = 2
_b$ = -12						; size = 2
_a$ = -8						; size = 2
_this$ = -4						; size = 4
??$ADD_16bit@$02$02@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::ADD_16bit<3,3>, COMDAT
; _this$ = ecx

; 510  : void Cpu::ADD_16bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 511  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 512  :   uint16_t a=0,b=0;

	xor	eax, eax
	mov	WORD PTR _a$[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _b$[ebp], cx

; 513  :   a = reg.raw16[dest];

	mov	edx, 2
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+edx+1064]
	mov	WORD PTR _a$[ebp], cx

; 514  :   b = reg.raw16[src];

	mov	edx, 2
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+edx+1064]
	mov	WORD PTR _b$[ebp], cx

; 515  :   reg.raw16[dest] = a + b;

	movzx	edx, WORD PTR _a$[ebp]
	movzx	eax, WORD PTR _b$[ebp]
	add	edx, eax
	mov	ecx, 2
	imul	ecx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+1064], dx

; 516  :   uint16_t r1 = (a&0xFFF) + (b&0xFFF);

	movzx	ecx, WORD PTR _a$[ebp]
	and	ecx, 4095				; 00000fffH
	movzx	edx, WORD PTR _b$[ebp]
	and	edx, 4095				; 00000fffH
	add	ecx, edx
	mov	WORD PTR _r1$[ebp], cx

; 517  :   reg.F.H = r1>0xFFF?1:0;

	movzx	eax, WORD PTR _r1$[ebp]
	cmp	eax, 4095				; 00000fffH
	jle	SHORT $LN3@ADD_16bit
	mov	DWORD PTR tv130[ebp], 1
	jmp	SHORT $LN4@ADD_16bit
$LN3@ADD_16bit:
	mov	DWORD PTR tv130[ebp], 0
$LN4@ADD_16bit:
	mov	cl, BYTE PTR tv130[ebp]
	and	cl, 1
	shl	cl, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 223					; 000000dfH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 518  :   uint32_t r2 = (a&0xFFFF) + (b&0xFFFF);

	movzx	edx, WORD PTR _a$[ebp]
	and	edx, 65535				; 0000ffffH
	movzx	eax, WORD PTR _b$[ebp]
	and	eax, 65535				; 0000ffffH
	add	edx, eax
	mov	DWORD PTR _r2$[ebp], edx

; 519  :   reg.F.C = r2>0xFFFF?1:0;

	cmp	DWORD PTR _r2$[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN5@ADD_16bit
	mov	DWORD PTR tv148[ebp], 1
	jmp	SHORT $LN6@ADD_16bit
$LN5@ADD_16bit:
	mov	DWORD PTR tv148[ebp], 0
$LN6@ADD_16bit:
	mov	cl, BYTE PTR tv148[ebp]
	and	cl, 1
	shl	cl, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 239					; 000000efH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 520  : 	Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 521  : }

	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$ADD_16bit@$02$02@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::ADD_16bit<3,3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$JR_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv92 = -24						; size = 2
_disp8$1 = -21						; size = 1
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$JR_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::JR_cc<7,0>, COMDAT
; _this$ = ecx

; 757  : void Cpu::JR_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 758  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 128				; 00000080H
	sar	ecx, 7
	mov	DWORD PTR _table$[ebp], ecx

; 759  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 128				; 00000080H
	sar	eax, 7
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 760  : 
; 761  :   if (table[inv]&1) {

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN2@JR_cc

; 762  : 		JR();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JR@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::JR

; 763  :   } else {

	jmp	SHORT $LN3@JR_cc
$LN2@JR_cc:

; 764  :     int8_t disp8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _disp8$1[ebp], al
$LN3@JR_cc:

; 765  :   }
; 766  : 
; 767  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@JR_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@JR_cc:
	DD	1
	DD	$LN6@JR_cc
$LN6@JR_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@JR_cc
$LN5@JR_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$JR_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::JR_cc<7,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD@$06$0A@$09@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv245 = -32						; size = 2
tv232 = -30						; size = 2
tv206 = -28						; size = 2
tv193 = -26						; size = 2
tv169 = -24						; size = 2
tv145 = -22						; size = 2
tv92 = -20						; size = 2
tv79 = -18						; size = 2
_d16$1 = -16						; size = 2
_d16$2 = -12						; size = 2
_a8$3 = -7						; size = 1
_a8$4 = -6						; size = 1
_d8$5 = -5						; size = 1
_this$ = -4						; size = 4
??$LD@$06$0A@$09@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD<7,0,10>, COMDAT
; _this$ = ecx

; 446  : void Cpu::LD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 447  :   if (mode == 10) { //dest,d8

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN11@LD

; 448  : 		reg.raw8[dest] = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv79[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	imul	edx, 7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN11@LD:

; 449  : 	}else if (mode == 11) { //(dest),d8

	xor	edx, edx
	je	SHORT $LN9@LD

; 450  : 		auto d8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _d8$5[ebp], al

; 451  : 		mem_->Write8(reg.raw16[dest],d8);

	movzx	ecx, BYTE PTR _d8$5[ebp]
	push	ecx
	mov	edx, 2
	imul	edx, 7
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN9@LD:

; 452  : 	} else if (mode == 12) { //0xFF00+d8 src

	xor	eax, eax
	je	SHORT $LN7@LD

; 453  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv145[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$4[ebp], al

; 454  : 		mem_->Write8(0xFF00+a8,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, BYTE PTR _a8$4[ebp]
	add	edx, 65280				; 0000ff00H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN7@LD:

; 455  : 	} else if (mode == 13) { //dest,0xFF00+d8 

	xor	ecx, ecx
	je	SHORT $LN5@LD

; 456  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv169[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv169[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$3[ebp], al

; 457  : 		reg.raw8[dest] = mem_->Read8(0xFF00+a8);

	movzx	eax, BYTE PTR _a8$3[ebp]
	add	eax, 65280				; 0000ff00H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	imul	edx, 7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN5@LD:

; 458  : 	} else if (mode == 14) { //(d16),src

	xor	edx, edx
	je	$LN3@LD

; 459  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv193[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv193[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _d16$2[ebp], cx

; 460  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv206[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv206[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _d16$2[ebp]
	or	ecx, eax
	mov	WORD PTR _d16$2[ebp], cx

; 461  :     mem_->Write8(d16,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, WORD PTR _d16$2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN3@LD:

; 462  : 	} else if (mode == 15) { //src,(d16)

	xor	ecx, ecx
	je	$LN12@LD

; 463  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv232[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv232[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	ax, al
	mov	WORD PTR _d16$1[ebp], ax

; 464  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv245[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	movzx	eax, WORD PTR _d16$1[ebp]
	or	eax, edx
	mov	WORD PTR _d16$1[ebp], ax

; 465  :     reg.raw8[dest] = mem_->Read8(d16);

	movzx	ecx, WORD PTR _d16$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al
$LN12@LD:

; 466  : 	}
; 467  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD@$06$0A@$09@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD<7,0,10>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$DEC_8bit@$06$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$DEC_8bit@$06$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::DEC_8bit<7,0>, COMDAT
; _this$ = ecx

; 796  : void Cpu::DEC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 797  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 798  : 
; 799  :   if (mode==0) {

	mov	eax, 1
	test	eax, eax
	je	$LN6@DEC_8bit

; 800  :     //updateCpuFlagH(reg.raw8[dest],1,1);
; 801  :     --reg.raw8[dest];

	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	sub	al, 1
	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 802  :     if ((reg.raw8[dest]&0xF)==0xF)

	mov	eax, 1
	imul	eax, 7
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	and	edx, 15					; 0000000fH
	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN5@DEC_8bit

; 803  :       reg.F.H = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 804  :     else 

	jmp	SHORT $LN4@DEC_8bit
$LN5@DEC_8bit:

; 805  :       reg.F.H = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
$LN4@DEC_8bit:

; 806  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	imul	eax, 7
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 807  :   } else {

	jmp	$LN7@DEC_8bit
$LN6@DEC_8bit:

; 808  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 809  : 
; 810  :     //updateCpuFlagH(data,1,1);
; 811  :     --data;

	mov	al, BYTE PTR _data$1[ebp]
	sub	al, 1
	mov	BYTE PTR _data$1[ebp], al

; 812  :     if ((data&0xF)==0xF)

	movzx	ecx, BYTE PTR _data$1[ebp]
	and	ecx, 15					; 0000000fH
	cmp	ecx, 15					; 0000000fH
	jne	SHORT $LN2@DEC_8bit

; 813  :       reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 814  :     else

	jmp	SHORT $LN1@DEC_8bit
$LN2@DEC_8bit:

; 815  :       reg.F.H = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 223					; 000000dfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al
$LN1@DEC_8bit:

; 816  :     updateCpuFlagZ(data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 817  :     mem_->Write8(reg.HL,data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+1070]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
$LN7@DEC_8bit:

; 818  : 
; 819  :   }
; 820  :   
; 821  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$DEC_8bit@$06$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::DEC_8bit<7,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$INC_8bit@$06$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$INC_8bit@$06$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::INC_8bit<7,0>, COMDAT
; _this$ = ecx

; 770  : void Cpu::INC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 771  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 772  : 
; 773  :   if (mode==0) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@INC_8bit

; 774  :     updateCpuFlagH(reg.raw8[dest],1,0);

	push	0
	push	1
	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+1064]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 775  :     ++reg.raw8[dest];

	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	add	al, 1
	mov	ecx, 1
	imul	ecx, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 776  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	imul	eax, 7
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 777  :   } else {

	jmp	SHORT $LN3@INC_8bit
$LN2@INC_8bit:

; 778  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 779  : 		updateCpuFlagH(data,1,0);

	push	0
	push	1
	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 780  :     ++data;

	mov	cl, BYTE PTR _data$1[ebp]
	add	cl, 1
	mov	BYTE PTR _data$1[ebp], cl

; 781  :     mem_->Write8(reg.HL,data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 782  :      updateCpuFlagZ(data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
$LN3@INC_8bit:

; 783  :   }
; 784  :     
; 785  :  
; 786  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$INC_8bit@$06$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::INC_8bit<7,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$INC_16bit@$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$INC_16bit@$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::INC_16bit<3>, COMDAT
; _this$ = ecx

; 789  : void Cpu::INC_16bit() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 790  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 791  :   ++reg.raw16[dest];

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+eax+1064]
	add	dx, 1
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax+1064], dx

; 792  :   Tick();Tick();Tick();Tick(); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 793  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$INC_16bit@$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::INC_16bit<3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDI$regreg@$02$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDI$regreg@$02$00@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::LDI$regreg<3,1>, COMDAT
; _this$ = ecx

; 420  : void Cpu::LDI$regreg() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 421  : 	mem_->Write8(reg.raw16[dest],reg.raw8[src]);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 422  : 	++reg.raw16[dest];

	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+ecx+1064]
	add	ax, 1
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx+1064], ax

; 423  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDI$regreg@$02$00@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::LDI$regreg<3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrd16@$02@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv95 = -8						; size = 2
tv78 = -6						; size = 2
_this$ = -4						; size = 4
??$LDrd16@$02@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrd16<3>, COMDAT
; _this$ = ecx

; 412  : void Cpu::LDrd16() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 413  : 	reg.raw16[dest] = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv78[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv78[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	edx, 2
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+edx+1064], cx

; 414  : 	reg.raw16[dest] |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv95[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv95[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [ecx+eax+1064]
	or	eax, edx
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx+1064], ax

; 415  :   if (dest != RegAF && (reg.raw16[dest]>=0xFE00&&reg.raw16[dest]<=0xFEFF) && emu_->lcd_driver()->lcdc().lcd_enable == 1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@LDrd16
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+ecx+1064]
	cmp	eax, 65024				; 0000fe00H
	jl	SHORT $LN2@LDrd16
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+ecx+1064]
	cmp	eax, 65279				; 0000feffH
	jg	SHORT $LN2@LDrd16
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?lcd_driver@Emu@gb@emulation@@QAEPAVLCDDriver@23@XZ ; emulation::gb::Emu::lcd_driver
	mov	ecx, eax
	call	?lcdc@LCDDriver@gb@emulation@@QAEABTLCDControlRegister@23@XZ ; emulation::gb::LCDDriver::lcdc
	mov	dl, BYTE PTR [eax]
	shr	dl, 7
	and	dl, 1
	movzx	eax, dl
	cmp	eax, 1
	jne	SHORT $LN2@LDrd16

; 416  :     sprite_bug = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+8], 2
$LN2@LDrd16:

; 417  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrd16@$02@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrd16<3>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$JR_cc@$06$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv92 = -24						; size = 2
_disp8$1 = -21						; size = 1
_table$ = -16						; size = 8
_this$ = -4						; size = 4
??$JR_cc@$06$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::JR_cc<7,1>, COMDAT
; _this$ = ecx

; 757  : void Cpu::JR_cc() {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 758  :   int table[2] = {((reg.F.raw & (1<<condbit))>>condbit),

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1064]
	and	ecx, 128				; 00000080H
	sar	ecx, 7
	mov	DWORD PTR _table$[ebp], ecx

; 759  :     ~((reg.F.raw & (1<<condbit))>>condbit)};

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1064]
	and	eax, 128				; 00000080H
	sar	eax, 7
	not	eax
	mov	DWORD PTR _table$[ebp+4], eax

; 760  : 
; 761  :   if (table[inv]&1) {

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _table$[ebp+ecx]
	and	edx, 1
	je	SHORT $LN2@JR_cc

; 762  : 		JR();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?JR@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::JR

; 763  :   } else {

	jmp	SHORT $LN3@JR_cc
$LN2@JR_cc:

; 764  :     int8_t disp8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _disp8$1[ebp], al
$LN3@JR_cc:

; 765  :   }
; 766  : 
; 767  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@JR_cc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@JR_cc:
	DD	1
	DD	$LN6@JR_cc
$LN6@JR_cc:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@JR_cc
$LN5@JR_cc:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
??$JR_cc@$06$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::JR_cc<7,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD@$03$0A@$09@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv245 = -32						; size = 2
tv232 = -30						; size = 2
tv206 = -28						; size = 2
tv193 = -26						; size = 2
tv169 = -24						; size = 2
tv145 = -22						; size = 2
tv92 = -20						; size = 2
tv79 = -18						; size = 2
_d16$1 = -16						; size = 2
_d16$2 = -12						; size = 2
_a8$3 = -7						; size = 1
_a8$4 = -6						; size = 1
_d8$5 = -5						; size = 1
_this$ = -4						; size = 4
??$LD@$03$0A@$09@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD<4,0,10>, COMDAT
; _this$ = ecx

; 446  : void Cpu::LD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 447  :   if (mode == 10) { //dest,d8

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN11@LD

; 448  : 		reg.raw8[dest] = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv79[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	shl	edx, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN11@LD:

; 449  : 	}else if (mode == 11) { //(dest),d8

	xor	edx, edx
	je	SHORT $LN9@LD

; 450  : 		auto d8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _d8$5[ebp], al

; 451  : 		mem_->Write8(reg.raw16[dest],d8);

	movzx	ecx, BYTE PTR _d8$5[ebp]
	push	ecx
	mov	edx, 2
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN9@LD:

; 452  : 	} else if (mode == 12) { //0xFF00+d8 src

	xor	eax, eax
	je	SHORT $LN7@LD

; 453  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv145[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$4[ebp], al

; 454  : 		mem_->Write8(0xFF00+a8,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, BYTE PTR _a8$4[ebp]
	add	edx, 65280				; 0000ff00H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN7@LD:

; 455  : 	} else if (mode == 13) { //dest,0xFF00+d8 

	xor	ecx, ecx
	je	SHORT $LN5@LD

; 456  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv169[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv169[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$3[ebp], al

; 457  : 		reg.raw8[dest] = mem_->Read8(0xFF00+a8);

	movzx	eax, BYTE PTR _a8$3[ebp]
	add	eax, 65280				; 0000ff00H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	shl	edx, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN5@LD:

; 458  : 	} else if (mode == 14) { //(d16),src

	xor	edx, edx
	je	$LN3@LD

; 459  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv193[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv193[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _d16$2[ebp], cx

; 460  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv206[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv206[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _d16$2[ebp]
	or	ecx, eax
	mov	WORD PTR _d16$2[ebp], cx

; 461  :     mem_->Write8(d16,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, WORD PTR _d16$2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN3@LD:

; 462  : 	} else if (mode == 15) { //src,(d16)

	xor	ecx, ecx
	je	$LN12@LD

; 463  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv232[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv232[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	ax, al
	mov	WORD PTR _d16$1[ebp], ax

; 464  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv245[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	movzx	eax, WORD PTR _d16$1[ebp]
	or	eax, edx
	mov	WORD PTR _d16$1[ebp], ax

; 465  :     reg.raw8[dest] = mem_->Read8(d16);

	movzx	ecx, WORD PTR _d16$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al
$LN12@LD:

; 466  : 	}
; 467  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD@$03$0A@$09@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD<4,0,10>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$DEC_8bit@$03$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$DEC_8bit@$03$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::DEC_8bit<4,0>, COMDAT
; _this$ = ecx

; 796  : void Cpu::DEC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 797  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 798  : 
; 799  :   if (mode==0) {

	mov	eax, 1
	test	eax, eax
	je	$LN6@DEC_8bit

; 800  :     //updateCpuFlagH(reg.raw8[dest],1,1);
; 801  :     --reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	sub	al, 1
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 802  :     if ((reg.raw8[dest]&0xF)==0xF)

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	and	edx, 15					; 0000000fH
	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN5@DEC_8bit

; 803  :       reg.F.H = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 804  :     else 

	jmp	SHORT $LN4@DEC_8bit
$LN5@DEC_8bit:

; 805  :       reg.F.H = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
$LN4@DEC_8bit:

; 806  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 807  :   } else {

	jmp	$LN7@DEC_8bit
$LN6@DEC_8bit:

; 808  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 809  : 
; 810  :     //updateCpuFlagH(data,1,1);
; 811  :     --data;

	mov	al, BYTE PTR _data$1[ebp]
	sub	al, 1
	mov	BYTE PTR _data$1[ebp], al

; 812  :     if ((data&0xF)==0xF)

	movzx	ecx, BYTE PTR _data$1[ebp]
	and	ecx, 15					; 0000000fH
	cmp	ecx, 15					; 0000000fH
	jne	SHORT $LN2@DEC_8bit

; 813  :       reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 814  :     else

	jmp	SHORT $LN1@DEC_8bit
$LN2@DEC_8bit:

; 815  :       reg.F.H = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 223					; 000000dfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al
$LN1@DEC_8bit:

; 816  :     updateCpuFlagZ(data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 817  :     mem_->Write8(reg.HL,data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+1070]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
$LN7@DEC_8bit:

; 818  : 
; 819  :   }
; 820  :   
; 821  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$DEC_8bit@$03$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::DEC_8bit<4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$INC_8bit@$03$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$INC_8bit@$03$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::INC_8bit<4,0>, COMDAT
; _this$ = ecx

; 770  : void Cpu::INC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 771  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 772  : 
; 773  :   if (mode==0) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@INC_8bit

; 774  :     updateCpuFlagH(reg.raw8[dest],1,0);

	push	0
	push	1
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+1064]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 775  :     ++reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	add	al, 1
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 776  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 777  :   } else {

	jmp	SHORT $LN3@INC_8bit
$LN2@INC_8bit:

; 778  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 779  : 		updateCpuFlagH(data,1,0);

	push	0
	push	1
	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 780  :     ++data;

	mov	cl, BYTE PTR _data$1[ebp]
	add	cl, 1
	mov	BYTE PTR _data$1[ebp], cl

; 781  :     mem_->Write8(reg.HL,data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 782  :      updateCpuFlagZ(data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
$LN3@INC_8bit:

; 783  :   }
; 784  :     
; 785  :  
; 786  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$INC_8bit@$03$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::INC_8bit<4,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$DEC_16bit@$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$DEC_16bit@$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::DEC_16bit<2>, COMDAT
; _this$ = ecx

; 824  : void Cpu::DEC_16bit() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 825  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 826  :   --reg.raw16[dest];

	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+eax+1064]
	sub	dx, 1
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax+1064], dx

; 827  :   Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 828  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$DEC_16bit@$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::DEC_16bit<2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDr$r@$00$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDr$r@$00$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDr$r<1,2>, COMDAT
; _this$ = ecx

; 397  : void Cpu::LDr$r() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 398  : 	reg.raw8[dest] = mem_->Read8(reg.raw16[src]);

	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 399  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDr$r@$00$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDr$r<1,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADD_16bit@$02$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv148 = -28						; size = 4
tv130 = -24						; size = 4
_r2$ = -20						; size = 4
_r1$ = -16						; size = 2
_b$ = -12						; size = 2
_a$ = -8						; size = 2
_this$ = -4						; size = 4
??$ADD_16bit@$02$01@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::ADD_16bit<3,2>, COMDAT
; _this$ = ecx

; 510  : void Cpu::ADD_16bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 511  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 512  :   uint16_t a=0,b=0;

	xor	eax, eax
	mov	WORD PTR _a$[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _b$[ebp], cx

; 513  :   a = reg.raw16[dest];

	mov	edx, 2
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+edx+1064]
	mov	WORD PTR _a$[ebp], cx

; 514  :   b = reg.raw16[src];

	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+edx+1064]
	mov	WORD PTR _b$[ebp], cx

; 515  :   reg.raw16[dest] = a + b;

	movzx	edx, WORD PTR _a$[ebp]
	movzx	eax, WORD PTR _b$[ebp]
	add	edx, eax
	mov	ecx, 2
	imul	ecx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+1064], dx

; 516  :   uint16_t r1 = (a&0xFFF) + (b&0xFFF);

	movzx	ecx, WORD PTR _a$[ebp]
	and	ecx, 4095				; 00000fffH
	movzx	edx, WORD PTR _b$[ebp]
	and	edx, 4095				; 00000fffH
	add	ecx, edx
	mov	WORD PTR _r1$[ebp], cx

; 517  :   reg.F.H = r1>0xFFF?1:0;

	movzx	eax, WORD PTR _r1$[ebp]
	cmp	eax, 4095				; 00000fffH
	jle	SHORT $LN3@ADD_16bit
	mov	DWORD PTR tv130[ebp], 1
	jmp	SHORT $LN4@ADD_16bit
$LN3@ADD_16bit:
	mov	DWORD PTR tv130[ebp], 0
$LN4@ADD_16bit:
	mov	cl, BYTE PTR tv130[ebp]
	and	cl, 1
	shl	cl, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 223					; 000000dfH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 518  :   uint32_t r2 = (a&0xFFFF) + (b&0xFFFF);

	movzx	edx, WORD PTR _a$[ebp]
	and	edx, 65535				; 0000ffffH
	movzx	eax, WORD PTR _b$[ebp]
	and	eax, 65535				; 0000ffffH
	add	edx, eax
	mov	DWORD PTR _r2$[ebp], edx

; 519  :   reg.F.C = r2>0xFFFF?1:0;

	cmp	DWORD PTR _r2$[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN5@ADD_16bit
	mov	DWORD PTR tv148[ebp], 1
	jmp	SHORT $LN6@ADD_16bit
$LN5@ADD_16bit:
	mov	DWORD PTR tv148[ebp], 0
$LN6@ADD_16bit:
	mov	cl, BYTE PTR tv148[ebp]
	and	cl, 1
	shl	cl, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 239					; 000000efH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 520  : 	Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 521  : }

	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$ADD_16bit@$02$01@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::ADD_16bit<3,2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD@$04$0A@$09@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv245 = -32						; size = 2
tv232 = -30						; size = 2
tv206 = -28						; size = 2
tv193 = -26						; size = 2
tv169 = -24						; size = 2
tv145 = -22						; size = 2
tv92 = -20						; size = 2
tv79 = -18						; size = 2
_d16$1 = -16						; size = 2
_d16$2 = -12						; size = 2
_a8$3 = -7						; size = 1
_a8$4 = -6						; size = 1
_d8$5 = -5						; size = 1
_this$ = -4						; size = 4
??$LD@$04$0A@$09@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD<5,0,10>, COMDAT
; _this$ = ecx

; 446  : void Cpu::LD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 447  :   if (mode == 10) { //dest,d8

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN11@LD

; 448  : 		reg.raw8[dest] = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv79[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	imul	edx, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN11@LD:

; 449  : 	}else if (mode == 11) { //(dest),d8

	xor	edx, edx
	je	SHORT $LN9@LD

; 450  : 		auto d8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _d8$5[ebp], al

; 451  : 		mem_->Write8(reg.raw16[dest],d8);

	movzx	ecx, BYTE PTR _d8$5[ebp]
	push	ecx
	mov	edx, 2
	imul	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN9@LD:

; 452  : 	} else if (mode == 12) { //0xFF00+d8 src

	xor	eax, eax
	je	SHORT $LN7@LD

; 453  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv145[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$4[ebp], al

; 454  : 		mem_->Write8(0xFF00+a8,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, BYTE PTR _a8$4[ebp]
	add	edx, 65280				; 0000ff00H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN7@LD:

; 455  : 	} else if (mode == 13) { //dest,0xFF00+d8 

	xor	ecx, ecx
	je	SHORT $LN5@LD

; 456  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv169[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv169[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$3[ebp], al

; 457  : 		reg.raw8[dest] = mem_->Read8(0xFF00+a8);

	movzx	eax, BYTE PTR _a8$3[ebp]
	add	eax, 65280				; 0000ff00H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	imul	edx, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN5@LD:

; 458  : 	} else if (mode == 14) { //(d16),src

	xor	edx, edx
	je	$LN3@LD

; 459  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv193[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv193[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _d16$2[ebp], cx

; 460  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv206[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv206[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _d16$2[ebp]
	or	ecx, eax
	mov	WORD PTR _d16$2[ebp], cx

; 461  :     mem_->Write8(d16,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, WORD PTR _d16$2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN3@LD:

; 462  : 	} else if (mode == 15) { //src,(d16)

	xor	ecx, ecx
	je	$LN12@LD

; 463  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv232[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv232[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	ax, al
	mov	WORD PTR _d16$1[ebp], ax

; 464  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv245[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	movzx	eax, WORD PTR _d16$1[ebp]
	or	eax, edx
	mov	WORD PTR _d16$1[ebp], ax

; 465  :     reg.raw8[dest] = mem_->Read8(d16);

	movzx	ecx, WORD PTR _d16$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al
$LN12@LD:

; 466  : 	}
; 467  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD@$04$0A@$09@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD<5,0,10>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$DEC_8bit@$04$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$DEC_8bit@$04$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::DEC_8bit<5,0>, COMDAT
; _this$ = ecx

; 796  : void Cpu::DEC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 797  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 798  : 
; 799  :   if (mode==0) {

	mov	eax, 1
	test	eax, eax
	je	$LN6@DEC_8bit

; 800  :     //updateCpuFlagH(reg.raw8[dest],1,1);
; 801  :     --reg.raw8[dest];

	mov	ecx, 1
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	sub	al, 1
	mov	ecx, 1
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 802  :     if ((reg.raw8[dest]&0xF)==0xF)

	mov	eax, 1
	imul	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	and	edx, 15					; 0000000fH
	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN5@DEC_8bit

; 803  :       reg.F.H = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 804  :     else 

	jmp	SHORT $LN4@DEC_8bit
$LN5@DEC_8bit:

; 805  :       reg.F.H = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
$LN4@DEC_8bit:

; 806  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	imul	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 807  :   } else {

	jmp	$LN7@DEC_8bit
$LN6@DEC_8bit:

; 808  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 809  : 
; 810  :     //updateCpuFlagH(data,1,1);
; 811  :     --data;

	mov	al, BYTE PTR _data$1[ebp]
	sub	al, 1
	mov	BYTE PTR _data$1[ebp], al

; 812  :     if ((data&0xF)==0xF)

	movzx	ecx, BYTE PTR _data$1[ebp]
	and	ecx, 15					; 0000000fH
	cmp	ecx, 15					; 0000000fH
	jne	SHORT $LN2@DEC_8bit

; 813  :       reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 814  :     else

	jmp	SHORT $LN1@DEC_8bit
$LN2@DEC_8bit:

; 815  :       reg.F.H = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 223					; 000000dfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al
$LN1@DEC_8bit:

; 816  :     updateCpuFlagZ(data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 817  :     mem_->Write8(reg.HL,data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+1070]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
$LN7@DEC_8bit:

; 818  : 
; 819  :   }
; 820  :   
; 821  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$DEC_8bit@$04$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::DEC_8bit<5,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$INC_8bit@$04$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$INC_8bit@$04$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::INC_8bit<5,0>, COMDAT
; _this$ = ecx

; 770  : void Cpu::INC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 771  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 772  : 
; 773  :   if (mode==0) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@INC_8bit

; 774  :     updateCpuFlagH(reg.raw8[dest],1,0);

	push	0
	push	1
	mov	ecx, 1
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+1064]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 775  :     ++reg.raw8[dest];

	mov	ecx, 1
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	add	al, 1
	mov	ecx, 1
	imul	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 776  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	imul	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 777  :   } else {

	jmp	SHORT $LN3@INC_8bit
$LN2@INC_8bit:

; 778  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 779  : 		updateCpuFlagH(data,1,0);

	push	0
	push	1
	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 780  :     ++data;

	mov	cl, BYTE PTR _data$1[ebp]
	add	cl, 1
	mov	BYTE PTR _data$1[ebp], cl

; 781  :     mem_->Write8(reg.HL,data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 782  :      updateCpuFlagZ(data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
$LN3@INC_8bit:

; 783  :   }
; 784  :     
; 785  :  
; 786  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$INC_8bit@$04$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::INC_8bit<5,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$INC_16bit@$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$INC_16bit@$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::INC_16bit<2>, COMDAT
; _this$ = ecx

; 789  : void Cpu::INC_16bit() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 790  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 791  :   ++reg.raw16[dest];

	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+eax+1064]
	add	dx, 1
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax+1064], dx

; 792  :   Tick();Tick();Tick();Tick(); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 793  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$INC_16bit@$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::INC_16bit<2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD$rr@$01$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LD$rr@$01$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD$rr<2,1>, COMDAT
; _this$ = ecx

; 392  : void Cpu::LD$rr() { //(dest), src

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 393  : 	mem_->Write8(reg.raw16[dest],reg.raw8[src]);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 394  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD$rr@$01$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD$rr<2,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrd16@$01@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv95 = -8						; size = 2
tv78 = -6						; size = 2
_this$ = -4						; size = 4
??$LDrd16@$01@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrd16<2>, COMDAT
; _this$ = ecx

; 412  : void Cpu::LDrd16() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 413  : 	reg.raw16[dest] = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv78[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv78[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+edx+1064], cx

; 414  : 	reg.raw16[dest] |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv95[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv95[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [ecx+eax+1064]
	or	eax, edx
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx+1064], ax

; 415  :   if (dest != RegAF && (reg.raw16[dest]>=0xFE00&&reg.raw16[dest]<=0xFEFF) && emu_->lcd_driver()->lcdc().lcd_enable == 1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@LDrd16
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+ecx+1064]
	cmp	eax, 65024				; 0000fe00H
	jl	SHORT $LN2@LDrd16
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+ecx+1064]
	cmp	eax, 65279				; 0000feffH
	jg	SHORT $LN2@LDrd16
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?lcd_driver@Emu@gb@emulation@@QAEPAVLCDDriver@23@XZ ; emulation::gb::Emu::lcd_driver
	mov	ecx, eax
	call	?lcdc@LCDDriver@gb@emulation@@QAEABTLCDControlRegister@23@XZ ; emulation::gb::LCDDriver::lcdc
	mov	dl, BYTE PTR [eax]
	shr	dl, 7
	and	dl, 1
	movzx	eax, dl
	cmp	eax, 1
	jne	SHORT $LN2@LDrd16

; 416  :     sprite_bug = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+8], 2
$LN2@LDrd16:

; 417  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrd16@$01@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrd16<2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD@$01$0A@$09@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv245 = -32						; size = 2
tv232 = -30						; size = 2
tv206 = -28						; size = 2
tv193 = -26						; size = 2
tv169 = -24						; size = 2
tv145 = -22						; size = 2
tv92 = -20						; size = 2
tv79 = -18						; size = 2
_d16$1 = -16						; size = 2
_d16$2 = -12						; size = 2
_a8$3 = -7						; size = 1
_a8$4 = -6						; size = 1
_d8$5 = -5						; size = 1
_this$ = -4						; size = 4
??$LD@$01$0A@$09@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD<2,0,10>, COMDAT
; _this$ = ecx

; 446  : void Cpu::LD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 447  :   if (mode == 10) { //dest,d8

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN11@LD

; 448  : 		reg.raw8[dest] = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv79[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN11@LD:

; 449  : 	}else if (mode == 11) { //(dest),d8

	xor	edx, edx
	je	SHORT $LN9@LD

; 450  : 		auto d8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _d8$5[ebp], al

; 451  : 		mem_->Write8(reg.raw16[dest],d8);

	movzx	ecx, BYTE PTR _d8$5[ebp]
	push	ecx
	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN9@LD:

; 452  : 	} else if (mode == 12) { //0xFF00+d8 src

	xor	eax, eax
	je	SHORT $LN7@LD

; 453  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv145[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$4[ebp], al

; 454  : 		mem_->Write8(0xFF00+a8,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, BYTE PTR _a8$4[ebp]
	add	edx, 65280				; 0000ff00H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN7@LD:

; 455  : 	} else if (mode == 13) { //dest,0xFF00+d8 

	xor	ecx, ecx
	je	SHORT $LN5@LD

; 456  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv169[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv169[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$3[ebp], al

; 457  : 		reg.raw8[dest] = mem_->Read8(0xFF00+a8);

	movzx	eax, BYTE PTR _a8$3[ebp]
	add	eax, 65280				; 0000ff00H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN5@LD:

; 458  : 	} else if (mode == 14) { //(d16),src

	xor	edx, edx
	je	$LN3@LD

; 459  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv193[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv193[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _d16$2[ebp], cx

; 460  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv206[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv206[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _d16$2[ebp]
	or	ecx, eax
	mov	WORD PTR _d16$2[ebp], cx

; 461  :     mem_->Write8(d16,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, WORD PTR _d16$2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN3@LD:

; 462  : 	} else if (mode == 15) { //src,(d16)

	xor	ecx, ecx
	je	$LN12@LD

; 463  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv232[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv232[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	ax, al
	mov	WORD PTR _d16$1[ebp], ax

; 464  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv245[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	movzx	eax, WORD PTR _d16$1[ebp]
	or	eax, edx
	mov	WORD PTR _d16$1[ebp], ax

; 465  :     reg.raw8[dest] = mem_->Read8(d16);

	movzx	ecx, WORD PTR _d16$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al
$LN12@LD:

; 466  : 	}
; 467  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD@$01$0A@$09@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD<2,0,10>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$DEC_8bit@$01$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$DEC_8bit@$01$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::DEC_8bit<2,0>, COMDAT
; _this$ = ecx

; 796  : void Cpu::DEC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 797  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 798  : 
; 799  :   if (mode==0) {

	mov	eax, 1
	test	eax, eax
	je	$LN6@DEC_8bit

; 800  :     //updateCpuFlagH(reg.raw8[dest],1,1);
; 801  :     --reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	sub	al, 1
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 802  :     if ((reg.raw8[dest]&0xF)==0xF)

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	and	edx, 15					; 0000000fH
	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN5@DEC_8bit

; 803  :       reg.F.H = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 804  :     else 

	jmp	SHORT $LN4@DEC_8bit
$LN5@DEC_8bit:

; 805  :       reg.F.H = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
$LN4@DEC_8bit:

; 806  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 807  :   } else {

	jmp	$LN7@DEC_8bit
$LN6@DEC_8bit:

; 808  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 809  : 
; 810  :     //updateCpuFlagH(data,1,1);
; 811  :     --data;

	mov	al, BYTE PTR _data$1[ebp]
	sub	al, 1
	mov	BYTE PTR _data$1[ebp], al

; 812  :     if ((data&0xF)==0xF)

	movzx	ecx, BYTE PTR _data$1[ebp]
	and	ecx, 15					; 0000000fH
	cmp	ecx, 15					; 0000000fH
	jne	SHORT $LN2@DEC_8bit

; 813  :       reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 814  :     else

	jmp	SHORT $LN1@DEC_8bit
$LN2@DEC_8bit:

; 815  :       reg.F.H = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 223					; 000000dfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al
$LN1@DEC_8bit:

; 816  :     updateCpuFlagZ(data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 817  :     mem_->Write8(reg.HL,data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+1070]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
$LN7@DEC_8bit:

; 818  : 
; 819  :   }
; 820  :   
; 821  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$DEC_8bit@$01$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::DEC_8bit<2,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$INC_8bit@$01$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$INC_8bit@$01$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::INC_8bit<2,0>, COMDAT
; _this$ = ecx

; 770  : void Cpu::INC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 771  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 772  : 
; 773  :   if (mode==0) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@INC_8bit

; 774  :     updateCpuFlagH(reg.raw8[dest],1,0);

	push	0
	push	1
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+1064]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 775  :     ++reg.raw8[dest];

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	add	al, 1
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 776  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 777  :   } else {

	jmp	SHORT $LN3@INC_8bit
$LN2@INC_8bit:

; 778  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 779  : 		updateCpuFlagH(data,1,0);

	push	0
	push	1
	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 780  :     ++data;

	mov	cl, BYTE PTR _data$1[ebp]
	add	cl, 1
	mov	BYTE PTR _data$1[ebp], cl

; 781  :     mem_->Write8(reg.HL,data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 782  :      updateCpuFlagZ(data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
$LN3@INC_8bit:

; 783  :   }
; 784  :     
; 785  :  
; 786  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$INC_8bit@$01$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::INC_8bit<2,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$DEC_16bit@$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$DEC_16bit@$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::DEC_16bit<1>, COMDAT
; _this$ = ecx

; 824  : void Cpu::DEC_16bit() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 825  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 826  :   --reg.raw16[dest];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+eax+1064]
	sub	dx, 1
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax+1064], dx

; 827  :   Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 828  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$DEC_16bit@$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::DEC_16bit<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDr$r@$00$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LDr$r@$00$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDr$r<1,1>, COMDAT
; _this$ = ecx

; 397  : void Cpu::LDr$r() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 398  : 	reg.raw8[dest] = mem_->Read8(reg.raw16[src]);

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 399  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDr$r@$00$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDr$r<1,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$ADD_16bit@$02$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv148 = -28						; size = 4
tv130 = -24						; size = 4
_r2$ = -20						; size = 4
_r1$ = -16						; size = 2
_b$ = -12						; size = 2
_a$ = -8						; size = 2
_this$ = -4						; size = 4
??$ADD_16bit@$02$00@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::ADD_16bit<3,1>, COMDAT
; _this$ = ecx

; 510  : void Cpu::ADD_16bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 511  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 512  :   uint16_t a=0,b=0;

	xor	eax, eax
	mov	WORD PTR _a$[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _b$[ebp], cx

; 513  :   a = reg.raw16[dest];

	mov	edx, 2
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+edx+1064]
	mov	WORD PTR _a$[ebp], cx

; 514  :   b = reg.raw16[src];

	mov	edx, 2
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+edx+1064]
	mov	WORD PTR _b$[ebp], cx

; 515  :   reg.raw16[dest] = a + b;

	movzx	edx, WORD PTR _a$[ebp]
	movzx	eax, WORD PTR _b$[ebp]
	add	edx, eax
	mov	ecx, 2
	imul	ecx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+1064], dx

; 516  :   uint16_t r1 = (a&0xFFF) + (b&0xFFF);

	movzx	ecx, WORD PTR _a$[ebp]
	and	ecx, 4095				; 00000fffH
	movzx	edx, WORD PTR _b$[ebp]
	and	edx, 4095				; 00000fffH
	add	ecx, edx
	mov	WORD PTR _r1$[ebp], cx

; 517  :   reg.F.H = r1>0xFFF?1:0;

	movzx	eax, WORD PTR _r1$[ebp]
	cmp	eax, 4095				; 00000fffH
	jle	SHORT $LN3@ADD_16bit
	mov	DWORD PTR tv130[ebp], 1
	jmp	SHORT $LN4@ADD_16bit
$LN3@ADD_16bit:
	mov	DWORD PTR tv130[ebp], 0
$LN4@ADD_16bit:
	mov	cl, BYTE PTR tv130[ebp]
	and	cl, 1
	shl	cl, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 223					; 000000dfH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 518  :   uint32_t r2 = (a&0xFFFF) + (b&0xFFFF);

	movzx	edx, WORD PTR _a$[ebp]
	and	edx, 65535				; 0000ffffH
	movzx	eax, WORD PTR _b$[ebp]
	and	eax, 65535				; 0000ffffH
	add	edx, eax
	mov	DWORD PTR _r2$[ebp], edx

; 519  :   reg.F.C = r2>0xFFFF?1:0;

	cmp	DWORD PTR _r2$[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN5@ADD_16bit
	mov	DWORD PTR tv148[ebp], 1
	jmp	SHORT $LN6@ADD_16bit
$LN5@ADD_16bit:
	mov	DWORD PTR tv148[ebp], 0
$LN6@ADD_16bit:
	mov	cl, BYTE PTR tv148[ebp]
	and	cl, 1
	shl	cl, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 239					; 000000efH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 520  : 	Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 521  : }

	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$ADD_16bit@$02$00@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::ADD_16bit<3,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD@$02$0A@$09@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv245 = -32						; size = 2
tv232 = -30						; size = 2
tv206 = -28						; size = 2
tv193 = -26						; size = 2
tv169 = -24						; size = 2
tv145 = -22						; size = 2
tv92 = -20						; size = 2
tv79 = -18						; size = 2
_d16$1 = -16						; size = 2
_d16$2 = -12						; size = 2
_a8$3 = -7						; size = 1
_a8$4 = -6						; size = 1
_d8$5 = -5						; size = 1
_this$ = -4						; size = 4
??$LD@$02$0A@$09@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD<3,0,10>, COMDAT
; _this$ = ecx

; 446  : void Cpu::LD() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 447  :   if (mode == 10) { //dest,d8

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN11@LD

; 448  : 		reg.raw8[dest] = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv79[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	imul	edx, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN11@LD:

; 449  : 	}else if (mode == 11) { //(dest),d8

	xor	edx, edx
	je	SHORT $LN9@LD

; 450  : 		auto d8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv92[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv92[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _d8$5[ebp], al

; 451  : 		mem_->Write8(reg.raw16[dest],d8);

	movzx	ecx, BYTE PTR _d8$5[ebp]
	push	ecx
	mov	edx, 2
	imul	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+1064]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN9@LD:

; 452  : 	} else if (mode == 12) { //0xFF00+d8 src

	xor	eax, eax
	je	SHORT $LN7@LD

; 453  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv145[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$4[ebp], al

; 454  : 		mem_->Write8(0xFF00+a8,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, BYTE PTR _a8$4[ebp]
	add	edx, 65280				; 0000ff00H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN7@LD:

; 455  : 	} else if (mode == 13) { //dest,0xFF00+d8 

	xor	ecx, ecx
	je	SHORT $LN5@LD

; 456  :     uint8_t a8 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv169[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv169[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _a8$3[ebp], al

; 457  : 		reg.raw8[dest] = mem_->Read8(0xFF00+a8);

	movzx	eax, BYTE PTR _a8$3[ebp]
	add	eax, 65280				; 0000ff00H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, 1
	imul	edx, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+edx+1064], al
	jmp	$LN12@LD
$LN5@LD:

; 458  : 	} else if (mode == 14) { //(d16),src

	xor	edx, edx
	je	$LN3@LD

; 459  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv193[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv193[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _d16$2[ebp], cx

; 460  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv206[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv206[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _d16$2[ebp]
	or	ecx, eax
	mov	WORD PTR _d16$2[ebp], cx

; 461  :     mem_->Write8(d16,reg.raw8[src]);

	mov	edx, 1
	imul	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1064]
	push	ecx
	movzx	edx, WORD PTR _d16$2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
	jmp	$LN12@LD
$LN3@LD:

; 462  : 	} else if (mode == 15) { //src,(d16)

	xor	ecx, ecx
	je	$LN12@LD

; 463  : 		uint16_t d16 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv232[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv232[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	ax, al
	mov	WORD PTR _d16$1[ebp], ax

; 464  : 		d16 |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv245[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	movzx	eax, WORD PTR _d16$1[ebp]
	or	eax, edx
	mov	WORD PTR _d16$1[ebp], ax

; 465  :     reg.raw8[dest] = mem_->Read8(d16);

	movzx	ecx, WORD PTR _d16$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al
$LN12@LD:

; 466  : 	}
; 467  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD@$02$0A@$09@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD<3,0,10>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$DEC_8bit@$02$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$DEC_8bit@$02$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::DEC_8bit<3,0>, COMDAT
; _this$ = ecx

; 796  : void Cpu::DEC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 797  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 798  : 
; 799  :   if (mode==0) {

	mov	eax, 1
	test	eax, eax
	je	$LN6@DEC_8bit

; 800  :     //updateCpuFlagH(reg.raw8[dest],1,1);
; 801  :     --reg.raw8[dest];

	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	sub	al, 1
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 802  :     if ((reg.raw8[dest]&0xF)==0xF)

	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	and	edx, 15					; 0000000fH
	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN5@DEC_8bit

; 803  :       reg.F.H = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 804  :     else 

	jmp	SHORT $LN4@DEC_8bit
$LN5@DEC_8bit:

; 805  :       reg.F.H = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
$LN4@DEC_8bit:

; 806  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 807  :   } else {

	jmp	$LN7@DEC_8bit
$LN6@DEC_8bit:

; 808  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 809  : 
; 810  :     //updateCpuFlagH(data,1,1);
; 811  :     --data;

	mov	al, BYTE PTR _data$1[ebp]
	sub	al, 1
	mov	BYTE PTR _data$1[ebp], al

; 812  :     if ((data&0xF)==0xF)

	movzx	ecx, BYTE PTR _data$1[ebp]
	and	ecx, 15					; 0000000fH
	cmp	ecx, 15					; 0000000fH
	jne	SHORT $LN2@DEC_8bit

; 813  :       reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 814  :     else

	jmp	SHORT $LN1@DEC_8bit
$LN2@DEC_8bit:

; 815  :       reg.F.H = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 223					; 000000dfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al
$LN1@DEC_8bit:

; 816  :     updateCpuFlagZ(data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 817  :     mem_->Write8(reg.HL,data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+1070]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8
$LN7@DEC_8bit:

; 818  : 
; 819  :   }
; 820  :   
; 821  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$DEC_8bit@$02$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::DEC_8bit<3,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$INC_8bit@$02$0A@@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_data$1 = -5						; size = 1
_this$ = -4						; size = 4
??$INC_8bit@$02$0A@@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::INC_8bit<3,0>, COMDAT
; _this$ = ecx

; 770  : void Cpu::INC_8bit() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 771  :   reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 772  : 
; 773  :   if (mode==0) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@INC_8bit

; 774  :     updateCpuFlagH(reg.raw8[dest],1,0);

	push	0
	push	1
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+1064]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 775  :     ++reg.raw8[dest];

	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+ecx+1064]
	add	al, 1
	mov	ecx, 1
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+1064], al

; 776  :     updateCpuFlagZ(reg.raw8[dest]);

	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 777  :   } else {

	jmp	SHORT $LN3@INC_8bit
$LN2@INC_8bit:

; 778  :     uint8_t data = mem_->Read8(reg.HL);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _data$1[ebp], al

; 779  : 		updateCpuFlagH(data,1,0);

	push	0
	push	1
	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 780  :     ++data;

	mov	cl, BYTE PTR _data$1[ebp]
	add	cl, 1
	mov	BYTE PTR _data$1[ebp], cl

; 781  :     mem_->Write8(reg.HL,data);

	movzx	edx, BYTE PTR _data$1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 782  :      updateCpuFlagZ(data);

	movzx	eax, BYTE PTR _data$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
$LN3@INC_8bit:

; 783  :   }
; 784  :     
; 785  :  
; 786  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$INC_8bit@$02$0A@@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::INC_8bit<3,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$INC_16bit@$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$INC_16bit@$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::INC_16bit<1>, COMDAT
; _this$ = ecx

; 789  : void Cpu::INC_16bit() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 790  :   simulateSpriteBug();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::simulateSpriteBug

; 791  :   ++reg.raw16[dest];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+eax+1064]
	add	dx, 1
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax+1064], dx

; 792  :   Tick();Tick();Tick();Tick(); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 793  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$INC_16bit@$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::INC_16bit<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LD$rr@$00$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$LD$rr@$00$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LD$rr<1,1>, COMDAT
; _this$ = ecx

; 392  : void Cpu::LD$rr() { //(dest), src

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 393  : 	mem_->Write8(reg.raw16[dest],reg.raw8[src]);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1064]
	push	edx
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1064]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 394  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LD$rr@$00$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LD$rr<1,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
;	COMDAT ??$LDrd16@$00@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
tv95 = -8						; size = 2
tv78 = -6						; size = 2
_this$ = -4						; size = 4
??$LDrd16@$00@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::LDrd16<1>, COMDAT
; _this$ = ecx

; 412  : void Cpu::LDrd16() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 413  : 	reg.raw16[dest] = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv78[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv78[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	edx, 2
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+edx+1064], cx

; 414  : 	reg.raw16[dest] |= (mem_->Read8(reg.PC++))<<8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv95[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv95[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	edx, al
	shl	edx, 8
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [ecx+eax+1064]
	or	eax, edx
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx+1064], ax

; 415  :   if (dest != RegAF && (reg.raw16[dest]>=0xFE00&&reg.raw16[dest]<=0xFEFF) && emu_->lcd_driver()->lcdc().lcd_enable == 1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@LDrd16
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+ecx+1064]
	cmp	eax, 65024				; 0000fe00H
	jl	SHORT $LN2@LDrd16
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+ecx+1064]
	cmp	eax, 65279				; 0000feffH
	jg	SHORT $LN2@LDrd16
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?lcd_driver@Emu@gb@emulation@@QAEPAVLCDDriver@23@XZ ; emulation::gb::Emu::lcd_driver
	mov	ecx, eax
	call	?lcdc@LCDDriver@gb@emulation@@QAEABTLCDControlRegister@23@XZ ; emulation::gb::LCDDriver::lcdc
	mov	dl, BYTE PTR [eax]
	shr	dl, 7
	and	dl, 1
	movzx	eax, dl
	cmp	eax, 1
	jne	SHORT $LN2@LDrd16

; 416  :     sprite_bug = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+8], 2
$LN2@LDrd16:

; 417  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$LDrd16@$00@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::LDrd16<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\emu.h
;	COMDAT ?timer@Emu@gb@emulation@@QAEPAVTimer@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?timer@Emu@gb@emulation@@QAEPAVTimer@23@XZ PROC		; emulation::gb::Emu::timer, COMDAT
; _this$ = ecx

; 24   : 	Timer* timer() { return &timer_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1912				; 00000778H
	mov	esp, ebp
	pop	ebp
	ret	0
?timer@Emu@gb@emulation@@QAEPAVTimer@23@XZ ENDP		; emulation::gb::Emu::timer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\emu.h
;	COMDAT ?sc@Emu@gb@emulation@@QAEPAVSoundController@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?sc@Emu@gb@emulation@@QAEPAVSoundController@23@XZ PROC	; emulation::gb::Emu::sc, COMDAT
; _this$ = ecx

; 23   : 	SoundController* sc() { return &sc_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1696				; 000006a0H
	mov	esp, ebp
	pop	ebp
	ret	0
?sc@Emu@gb@emulation@@QAEPAVSoundController@23@XZ ENDP	; emulation::gb::Emu::sc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\emu.h
;	COMDAT ?lcd_driver@Emu@gb@emulation@@QAEPAVLCDDriver@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?lcd_driver@Emu@gb@emulation@@QAEPAVLCDDriver@23@XZ PROC ; emulation::gb::Emu::lcd_driver, COMDAT
; _this$ = ecx

; 22   :   LCDDriver* lcd_driver() { return &lcd_driver_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1616				; 00000650H
	mov	esp, ebp
	pop	ebp
	ret	0
?lcd_driver@Emu@gb@emulation@@QAEPAVLCDDriver@23@XZ ENDP ; emulation::gb::Emu::lcd_driver
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\emu.h
;	COMDAT ?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ PROC	; emulation::gb::Emu::memory, COMDAT
; _this$ = ecx

; 21   :   Memory* memory() { return &memory_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1160				; 00000488H
	mov	esp, ebp
	pop	ebp
	ret	0
?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ENDP	; emulation::gb::Emu::memory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\emu.h
;	COMDAT ?cartridge@Emu@gb@emulation@@QAEPAVCartridge@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?cartridge@Emu@gb@emulation@@QAEPAVCartridge@23@XZ PROC	; emulation::gb::Emu::cartridge, COMDAT
; _this$ = ecx

; 19   :   Cartridge* cartridge() { return &cartridge_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	mov	esp, ebp
	pop	ebp
	ret	0
?cartridge@Emu@gb@emulation@@QAEPAVCartridge@23@XZ ENDP	; emulation::gb::Emu::cartridge
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_a$ = -8						; size = 4
_this$ = -4						; size = 4
?DAA@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::DAA
; _this$ = ecx

; 995  : void Cpu::DAA() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 996  :  int a = reg.A;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1065]
	mov	DWORD PTR _a$[ebp], ecx

; 997  : 
; 998  :   if (!reg.F.N)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 6
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN9@DAA

; 999  :   {
; 1000 :       if (reg.F.H || (a & 0xF) > 9)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@DAA
	mov	edx, DWORD PTR _a$[ebp]
	and	edx, 15					; 0000000fH
	cmp	edx, 9
	jle	SHORT $LN8@DAA
$LN7@DAA:

; 1001 :           a += 0x06;

	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 6
	mov	DWORD PTR _a$[ebp], eax
$LN8@DAA:

; 1002 :       if (reg.F.C || a > 0x9F)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+1064]
	shr	dl, 4
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN5@DAA
	cmp	DWORD PTR _a$[ebp], 159			; 0000009fH
	jle	SHORT $LN6@DAA
$LN5@DAA:

; 1003 :           a += 0x60;

	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 96					; 00000060H
	mov	DWORD PTR _a$[ebp], ecx
$LN6@DAA:

; 1004 :   }
; 1005 :   else

	jmp	SHORT $LN4@DAA
$LN9@DAA:

; 1006 :   {
; 1007 :     if (reg.F.H)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@DAA

; 1008 :       a = (a - 6) & 0xFF;

	mov	edx, DWORD PTR _a$[ebp]
	sub	edx, 6
	and	edx, 255				; 000000ffH
	mov	DWORD PTR _a$[ebp], edx
$LN3@DAA:

; 1009 :       if (reg.F.C)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@DAA

; 1010 :           a -= 0x60;

	mov	eax, DWORD PTR _a$[ebp]
	sub	eax, 96					; 00000060H
	mov	DWORD PTR _a$[ebp], eax
$LN4@DAA:

; 1011 :   }
; 1012 : 
; 1013 : 
; 1014 :   if ((a & 0x100) == 0x100)

	mov	ecx, DWORD PTR _a$[ebp]
	and	ecx, 256				; 00000100H
	je	SHORT $LN1@DAA

; 1015 :       reg.F.C = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al
$LN1@DAA:

; 1016 : 
; 1017 :   a &= 0xFF;

	mov	edx, DWORD PTR _a$[ebp]
	and	edx, 255				; 000000ffH
	mov	DWORD PTR _a$[ebp], edx

; 1018 : 
; 1019 :   updateCpuFlagZ(a);

	movzx	eax, BYTE PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 1020 :   reg.F.H = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+1064]
	and	dl, 223					; 000000dfH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], dl

; 1021 :   reg.A = (uint8_t)a;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR [ecx+1065], dl

; 1022 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DAA@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::DAA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RETI@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::RETI
; _this$ = ecx

; 990  : void Cpu::RETI() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 991  : 	EI();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EI@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::EI

; 992  : 	RET();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RET@Cpu@gb@emulation@@AAEXXZ		; emulation::gb::Cpu::RET

; 993  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RETI@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::RETI
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EI@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::EI
; _this$ = ecx

; 985  : void Cpu::EI() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 986  :   ime = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1080], 1

; 987  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EI@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::EI
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DI@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::DI
; _this$ = ecx

; 981  : void Cpu::DI() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 982  :   ime = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1080], 0

; 983  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DI@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::DI
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CP_HL@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::CP_HL
; _this$ = ecx

; 977  : void Cpu::CP_HL() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 978  :   CP(reg.A,mem_->Read8(reg.HL));

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1070]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1065]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CP@Cpu@gb@emulation@@AAEXEE@Z		; emulation::gb::Cpu::CP

; 979  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CP_HL@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::CP_HL
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
tv75 = -6						; size = 2
_this$ = -4						; size = 4
?CP_d8@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::CP_d8
; _this$ = ecx

; 973  : void Cpu::CP_d8() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 974  :   CP(reg.A,mem_->Read8(reg.PC++));

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv75[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv75[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1065]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CP@Cpu@gb@emulation@@AAEXEE@Z		; emulation::gb::Cpu::CP

; 975  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CP_d8@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::CP_d8
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_a$ = 8							; size = 1
_b$ = 12						; size = 1
?CP@Cpu@gb@emulation@@AAEXEE@Z PROC			; emulation::gb::Cpu::CP
; _this$ = ecx

; 961  : void Cpu::CP(uint8_t a, uint8_t b) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 962  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 963  :   updateCpuFlagC(a,b,1);

	push	1
	movzx	eax, BYTE PTR _b$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 964  :   updateCpuFlagH(a,b,1);

	push	1
	movzx	edx, BYTE PTR _b$[ebp]
	push	edx
	movzx	eax, BYTE PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 965  :   updateCpuFlagZ(a-b);

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	sub	ecx, edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ

; 966  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?CP@Cpu@gb@emulation@@AAEXEE@Z ENDP			; emulation::gb::Cpu::CP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_oldC$ = -9						; size = 1
_r$ = -8						; size = 4
_this$ = -4						; size = 4
?RRA@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::RRA
; _this$ = ecx

; 950  : void Cpu::RRA() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 951  :   uint8_t& r = reg.A;;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1065				; 00000429H
	mov	DWORD PTR _r$[ebp], eax

; 952  :   uint8_t oldC = reg.F.C;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+1064]
	shr	dl, 4
	and	dl, 1
	mov	BYTE PTR _oldC$[ebp], dl

; 953  :   reg.F.C = r & 1;

	mov	eax, DWORD PTR _r$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 1
	and	cl, 1
	shl	cl, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 239					; 000000efH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 954  :   r = r >> 1;

	mov	edx, DWORD PTR _r$[ebp]
	movzx	eax, BYTE PTR [edx]
	sar	eax, 1
	mov	ecx, DWORD PTR _r$[ebp]
	mov	BYTE PTR [ecx], al

; 955  :   r |= oldC << 7;

	movzx	edx, BYTE PTR _oldC$[ebp]
	shl	edx, 7
	mov	eax, DWORD PTR _r$[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, edx
	mov	edx, DWORD PTR _r$[ebp]
	mov	BYTE PTR [edx], cl

; 956  :   reg.F.H = reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 957  :   reg.F.Z = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 958  :   //updateCpuFlagZ(r);
; 959  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RRA@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::RRA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_oldC$ = -9						; size = 1
_r$ = -8						; size = 4
_this$ = -4						; size = 4
?RLA@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::RLA
; _this$ = ecx

; 939  : void Cpu::RLA() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 940  :   uint8_t& r = reg.A;;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1065				; 00000429H
	mov	DWORD PTR _r$[ebp], eax

; 941  :   uint8_t oldC = reg.F.C;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+1064]
	shr	dl, 4
	and	dl, 1
	mov	BYTE PTR _oldC$[ebp], dl

; 942  :   reg.F.C = (r&0x80)>>7;

	mov	eax, DWORD PTR _r$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 128				; 00000080H
	sar	ecx, 7
	and	cl, 1
	shl	cl, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 239					; 000000efH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 943  :   r = r << 1;

	mov	edx, DWORD PTR _r$[ebp]
	movzx	eax, BYTE PTR [edx]
	shl	eax, 1
	mov	ecx, DWORD PTR _r$[ebp]
	mov	BYTE PTR [ecx], al

; 944  :   r |= oldC;

	movzx	edx, BYTE PTR _oldC$[ebp]
	mov	eax, DWORD PTR _r$[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, edx
	mov	edx, DWORD PTR _r$[ebp]
	mov	BYTE PTR [edx], cl

; 945  :   reg.F.H = reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 946  :     reg.F.Z = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 947  :   //updateCpuFlagZ(r);
; 948  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RLA@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::RLA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_r$ = -8						; size = 4
_this$ = -4						; size = 4
?RRCA@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::RRCA
; _this$ = ecx

; 929  : void Cpu::RRCA() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 930  :   uint8_t& r = reg.A;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1065				; 00000429H
	mov	DWORD PTR _r$[ebp], eax

; 931  :   reg.F.C = r&1;

	mov	ecx, DWORD PTR _r$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 1
	and	dl, 1
	shl	dl, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 239					; 000000efH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 932  :   r = r >> 1;

	mov	eax, DWORD PTR _r$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sar	ecx, 1
	mov	edx, DWORD PTR _r$[ebp]
	mov	BYTE PTR [edx], cl

; 933  :   r |= reg.F.C<<7;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	shl	edx, 7
	mov	eax, DWORD PTR _r$[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, edx
	mov	edx, DWORD PTR _r$[ebp]
	mov	BYTE PTR [edx], cl

; 934  :   reg.F.H = reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 935  :     reg.F.Z = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 936  :   //updateCpuFlagZ(r);
; 937  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RRCA@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::RRCA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_r$ = -8						; size = 4
_this$ = -4						; size = 4
?RLCA@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::RLCA
; _this$ = ecx

; 919  : void Cpu::RLCA() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 920  :   uint8_t& r = reg.A;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1065				; 00000429H
	mov	DWORD PTR _r$[ebp], eax

; 921  :   reg.F.C = (r&0x80)>>7;

	mov	ecx, DWORD PTR _r$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 128				; 00000080H
	sar	edx, 7
	and	dl, 1
	shl	dl, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 239					; 000000efH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 922  :   r = r << 1;

	mov	eax, DWORD PTR _r$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 1
	mov	edx, DWORD PTR _r$[ebp]
	mov	BYTE PTR [edx], cl

; 923  :   r |= reg.F.C;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	mov	eax, DWORD PTR _r$[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, edx
	mov	edx, DWORD PTR _r$[ebp]
	mov	BYTE PTR [edx], cl

; 924  :   reg.F.H = reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 925  :     reg.F.Z = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 926  :  // updateCpuFlagZ(r);
; 927  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RLCA@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::RLCA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RET@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::RET
; _this$ = ecx

; 882  : void Cpu::RET() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 883  :   reg.PC = pop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@Cpu@gb@emulation@@AAEEXZ		; emulation::gb::Cpu::pop
	movzx	ax, al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax

; 884  :   reg.PC |= pop() << 8;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@Cpu@gb@emulation@@AAEEXZ		; emulation::gb::Cpu::pop
	movzx	edx, al
	shl	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1074]
	or	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx

; 885  :   Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 886  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RET@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::RET
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
tv87 = -12						; size = 2
tv74 = -10						; size = 2
_nn$ = -8						; size = 2
_this$ = -4						; size = 4
?CALL@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::CALL
; _this$ = ecx

; 858  : void Cpu::CALL() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 859  :   uint16_t nn;
; 860  :   nn = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv74[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv74[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _nn$[ebp], cx

; 861  :   nn |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv87[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv87[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _nn$[ebp]
	or	ecx, eax
	mov	WORD PTR _nn$[ebp], cx

; 862  :   pushPC();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushPC@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::pushPC

; 863  :   reg.PC = nn;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _nn$[ebp]
	mov	WORD PTR [edx+1074], ax

; 864  : 
; 865  :   Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 866  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CALL@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::CALL
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?JP_HL@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::JP_HL
; _this$ = ecx

; 853  : void Cpu::JP_HL() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 854  :   reg.PC = reg.HL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1070]
	mov	WORD PTR [eax+1074], dx

; 855  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?JP_HL@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::JP_HL
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
tv87 = -12						; size = 2
tv74 = -10						; size = 2
_nn$ = -8						; size = 2
_this$ = -4						; size = 4
?JP@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::JP
; _this$ = ecx

; 830  : void Cpu::JP() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 831  :   uint16_t nn;
; 832  :   nn = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv74[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv74[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _nn$[ebp], cx

; 833  :   nn |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv87[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv87[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _nn$[ebp]
	or	ecx, eax
	mov	WORD PTR _nn$[ebp], cx

; 834  :   reg.PC = nn;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _nn$[ebp]
	mov	WORD PTR [edx+1074], ax

; 835  : 
; 836  :   Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 837  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?JP@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::JP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
tv74 = -8						; size = 2
_disp8$ = -5						; size = 1
_this$ = -4						; size = 4
?JR@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::JR
; _this$ = ecx

; 750  : void Cpu::JR() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 751  : 	 int8_t disp8 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv74[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv74[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _disp8$[ebp], al

; 752  :    reg.PC += disp8;

	movsx	ecx, BYTE PTR _disp8$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+1074]
	add	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax

; 753  :    Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 754  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?JR@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::JR
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
tv248 = -72						; size = 4
tv80 = -68						; size = 2
_r$1 = -66						; size = 1
_r$2 = -65						; size = 1
_r$3 = -64						; size = 1
_oldC$4 = -63						; size = 1
_r$5 = -62						; size = 1
_oldC$6 = -61						; size = 1
_r$7 = -60						; size = 1
_r$8 = -59						; size = 1
_r$9 = -58						; size = 1
_n1$10 = -57						; size = 1
_n0$11 = -56						; size = 1
_r$12 = -55						; size = 1
_bitshift$13 = -54					; size = 1
_test$14 = -53						; size = 1
_bitshift$15 = -52					; size = 1
_test$16 = -51						; size = 1
_bitshift$17 = -50					; size = 1
_test$18 = -49						; size = 1
_setr$ = -44						; size = 8
_getr$ = -28						; size = 8
_code$ = -9						; size = 1
_this$ = -4						; size = 4
?PREFIX_CB@Cpu@gb@emulation@@AAEXXZ PROC		; emulation::gb::Cpu::PREFIX_CB
; _this$ = ecx

; 644  : void Cpu::PREFIX_CB() {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 645  : 	uint8_t code = emu_->memory()->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv80[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv80[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _code$[ebp], al

; 646  : 
; 647  :   auto getr = [=]() {
; 648  :     if ((code&0x7) != 6) {
; 649  :       return reg.raw8[reg_index[code&0x7]];
; 650  :     } else {
; 651  : 
; 652  :       return mem_->Read8(reg.HL);
; 653  :     }
; 654  :   };

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR _code$[ebp]
	push	edx
	lea	ecx, DWORD PTR _getr$[ebp]
	call	??0<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QAE@ABEPAVCpu@gb@emulation@@@Z ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>

; 655  : 
; 656  :   auto setr = [=](uint8_t r) {
; 657  :     if ((code&0x7) != 6) {
; 658  :       reg.raw8[reg_index[code&0x7]] = r;
; 659  :     } else {
; 660  :       mem_->Write8(reg.HL,r);
; 661  :     }
; 662  :   };

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _code$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _setr$[ebp]
	call	??0<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QAE@ABEPAVCpu@gb@emulation@@@Z ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::<lambda_08bfd30db2c73e418a55b8072ee85de7>

; 663  : 
; 664  :    if ((code & 0xC0) == 0x40) { //bit

	movzx	edx, BYTE PTR _code$[ebp]
	and	edx, 192				; 000000c0H
	cmp	edx, 64					; 00000040H
	jne	SHORT $LN21@PREFIX_CB

; 665  :     uint8_t test = getr();

	lea	ecx, DWORD PTR _getr$[ebp]
	call	??R<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QBEEXZ ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::operator()
	mov	BYTE PTR _test$18[ebp], al

; 666  :     uint8_t bitshift = (code&0x38) >> 3;

	movzx	eax, BYTE PTR _code$[ebp]
	and	eax, 56					; 00000038H
	sar	eax, 3
	mov	BYTE PTR _bitshift$17[ebp], al

; 667  :     reg.F.Z = (~(((test&(1<<bitshift))>>bitshift))&0x1);

	movzx	edx, BYTE PTR _test$18[ebp]
	movzx	ecx, BYTE PTR _bitshift$17[ebp]
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, BYTE PTR _bitshift$17[ebp]
	sar	edx, cl
	not	edx
	and	edx, 1
	and	dl, 1
	shl	dl, 7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [ecx+1064]
	and	al, 127					; 0000007fH
	or	al, dl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 668  :     reg.F.H = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 669  :     reg.F.N = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 191					; 000000bfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al
	jmp	$LN20@PREFIX_CB
$LN21@PREFIX_CB:

; 670  : 
; 671  :   } else if ((code & 0xC0) == 0x80) { //res

	movzx	edx, BYTE PTR _code$[ebp]
	and	edx, 192				; 000000c0H
	cmp	edx, 128				; 00000080H
	jne	SHORT $LN19@PREFIX_CB

; 672  :     uint8_t test = getr();

	lea	ecx, DWORD PTR _getr$[ebp]
	call	??R<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QBEEXZ ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::operator()
	mov	BYTE PTR _test$16[ebp], al

; 673  :     uint8_t bitshift = (code&0x38) >> 3;

	movzx	eax, BYTE PTR _code$[ebp]
	and	eax, 56					; 00000038H
	sar	eax, 3
	mov	BYTE PTR _bitshift$15[ebp], al

; 674  :     test &= ~(1<<bitshift);

	movzx	ecx, BYTE PTR _bitshift$15[ebp]
	mov	edx, 1
	shl	edx, cl
	not	edx
	movzx	eax, BYTE PTR _test$16[ebp]
	and	eax, edx
	mov	BYTE PTR _test$16[ebp], al

; 675  :     setr(test);

	movzx	ecx, BYTE PTR _test$16[ebp]
	push	ecx
	lea	ecx, DWORD PTR _setr$[ebp]
	call	??R<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QBEXE@Z ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::operator()
	jmp	$LN20@PREFIX_CB
$LN19@PREFIX_CB:

; 676  :   } else if ((code & 0xC0) == 0xC0) { //set

	movzx	edx, BYTE PTR _code$[ebp]
	and	edx, 192				; 000000c0H
	cmp	edx, 192				; 000000c0H
	jne	SHORT $LN17@PREFIX_CB

; 677  :     uint8_t test = getr();

	lea	ecx, DWORD PTR _getr$[ebp]
	call	??R<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QBEEXZ ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::operator()
	mov	BYTE PTR _test$14[ebp], al

; 678  :     uint8_t bitshift = (code&0x38) >> 3;

	movzx	eax, BYTE PTR _code$[ebp]
	and	eax, 56					; 00000038H
	sar	eax, 3
	mov	BYTE PTR _bitshift$13[ebp], al

; 679  :     test |= (1<<bitshift);

	movzx	ecx, BYTE PTR _bitshift$13[ebp]
	mov	edx, 1
	shl	edx, cl
	movzx	eax, BYTE PTR _test$14[ebp]
	or	eax, edx
	mov	BYTE PTR _test$14[ebp], al

; 680  :     setr(test);

	movzx	ecx, BYTE PTR _test$14[ebp]
	push	ecx
	lea	ecx, DWORD PTR _setr$[ebp]
	call	??R<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QBEXE@Z ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::operator()
	jmp	$LN20@PREFIX_CB
$LN17@PREFIX_CB:

; 681  :   } else  if ((code & 0xF8) == 0x30) { //swap

	movzx	edx, BYTE PTR _code$[ebp]
	and	edx, 248				; 000000f8H
	cmp	edx, 48					; 00000030H
	jne	$LN15@PREFIX_CB

; 682  :     uint8_t r = getr();

	lea	ecx, DWORD PTR _getr$[ebp]
	call	??R<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QBEEXZ ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::operator()
	mov	BYTE PTR _r$12[ebp], al

; 683  :     uint8_t n0 = r&0xF;

	movzx	eax, BYTE PTR _r$12[ebp]
	and	eax, 15					; 0000000fH
	mov	BYTE PTR _n0$11[ebp], al

; 684  :     uint8_t n1 = (r&0xF0)>>4;

	movzx	ecx, BYTE PTR _r$12[ebp]
	and	ecx, 240				; 000000f0H
	sar	ecx, 4
	mov	BYTE PTR _n1$10[ebp], cl

; 685  :     r = n1 | (n0<<4);

	movzx	edx, BYTE PTR _n1$10[ebp]
	movzx	eax, BYTE PTR _n0$11[ebp]
	shl	eax, 4
	or	edx, eax
	mov	BYTE PTR _r$12[ebp], dl

; 686  :     setr(r);

	movzx	ecx, BYTE PTR _r$12[ebp]
	push	ecx
	lea	ecx, DWORD PTR _setr$[ebp]
	call	??R<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QBEXE@Z ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::operator()

; 687  :     reg.F.H  = reg.F.N = reg.F.C = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 239					; 000000efH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 191					; 000000bfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 223					; 000000dfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 688  :     updateCpuFlagZ(r);

	movzx	edx, BYTE PTR _r$12[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
	jmp	$LN20@PREFIX_CB
$LN15@PREFIX_CB:

; 689  :   } else if ((code&0xF8) == 0) { //RLC r

	movzx	eax, BYTE PTR _code$[ebp]
	and	eax, 248				; 000000f8H
	jne	$LN13@PREFIX_CB

; 690  :     uint8_t r = getr();

	lea	ecx, DWORD PTR _getr$[ebp]
	call	??R<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QBEEXZ ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::operator()
	mov	BYTE PTR _r$9[ebp], al

; 691  :     reg.F.C = (r&0x80)!=0?1:0;

	movzx	ecx, BYTE PTR _r$9[ebp]
	and	ecx, 128				; 00000080H
	je	SHORT $LN24@PREFIX_CB
	mov	DWORD PTR tv248[ebp], 1
	jmp	SHORT $LN25@PREFIX_CB
$LN24@PREFIX_CB:
	mov	DWORD PTR tv248[ebp], 0
$LN25@PREFIX_CB:
	mov	dl, BYTE PTR tv248[ebp]
	and	dl, 1
	shl	dl, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 239					; 000000efH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 692  :     r = r << 1;

	movzx	eax, BYTE PTR _r$9[ebp]
	shl	eax, 1
	mov	BYTE PTR _r$9[ebp], al

; 693  :     r |= reg.F.C;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+1064]
	shr	dl, 4
	and	dl, 1
	movzx	eax, dl
	movzx	ecx, BYTE PTR _r$9[ebp]
	or	ecx, eax
	mov	BYTE PTR _r$9[ebp], cl

; 694  :     setr(r);

	movzx	edx, BYTE PTR _r$9[ebp]
	push	edx
	lea	ecx, DWORD PTR _setr$[ebp]
	call	??R<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QBEXE@Z ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::operator()

; 695  :     reg.F.H  = reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 696  :     updateCpuFlagZ(r);

	movzx	eax, BYTE PTR _r$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
	jmp	$LN20@PREFIX_CB
$LN13@PREFIX_CB:

; 697  :   } else if ((code&0xF8) == 0x08) { //RRC r

	movzx	ecx, BYTE PTR _code$[ebp]
	and	ecx, 248				; 000000f8H
	cmp	ecx, 8
	jne	$LN11@PREFIX_CB

; 698  :     uint8_t r = getr();

	lea	ecx, DWORD PTR _getr$[ebp]
	call	??R<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QBEEXZ ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::operator()
	mov	BYTE PTR _r$8[ebp], al

; 699  :     reg.F.C = r&1;

	movzx	edx, BYTE PTR _r$8[ebp]
	and	edx, 1
	and	dl, 1
	shl	dl, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 239					; 000000efH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 700  :     r = r >> 1;

	movzx	eax, BYTE PTR _r$8[ebp]
	sar	eax, 1
	mov	BYTE PTR _r$8[ebp], al

; 701  :     r |= reg.F.C<<7;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+1064]
	shr	dl, 4
	and	dl, 1
	movzx	eax, dl
	shl	eax, 7
	movzx	ecx, BYTE PTR _r$8[ebp]
	or	ecx, eax
	mov	BYTE PTR _r$8[ebp], cl

; 702  :     setr(r);

	movzx	edx, BYTE PTR _r$8[ebp]
	push	edx
	lea	ecx, DWORD PTR _setr$[ebp]
	call	??R<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QBEXE@Z ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::operator()

; 703  :     reg.F.H  = reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 704  :     updateCpuFlagZ(r);

	movzx	eax, BYTE PTR _r$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
	jmp	$LN20@PREFIX_CB
$LN11@PREFIX_CB:

; 705  :   } else if ((code&0xF8) == 0x10) { //RL r

	movzx	ecx, BYTE PTR _code$[ebp]
	and	ecx, 248				; 000000f8H
	cmp	ecx, 16					; 00000010H
	jne	$LN9@PREFIX_CB

; 706  :     uint8_t r = getr();

	lea	ecx, DWORD PTR _getr$[ebp]
	call	??R<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QBEEXZ ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::operator()
	mov	BYTE PTR _r$7[ebp], al

; 707  :     uint8_t oldC = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _oldC$6[ebp], al

; 708  :     reg.F.C = ((r&0x80)>>7);

	movzx	ecx, BYTE PTR _r$7[ebp]
	and	ecx, 128				; 00000080H
	sar	ecx, 7
	and	cl, 1
	shl	cl, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 239					; 000000efH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 709  :     r = r << 1;

	movzx	edx, BYTE PTR _r$7[ebp]
	shl	edx, 1
	mov	BYTE PTR _r$7[ebp], dl

; 710  :     r |= oldC;

	movzx	eax, BYTE PTR _oldC$6[ebp]
	movzx	ecx, BYTE PTR _r$7[ebp]
	or	ecx, eax
	mov	BYTE PTR _r$7[ebp], cl

; 711  :     setr(r);

	movzx	edx, BYTE PTR _r$7[ebp]
	push	edx
	lea	ecx, DWORD PTR _setr$[ebp]
	call	??R<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QBEXE@Z ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::operator()

; 712  :     reg.F.H  = reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 713  :     updateCpuFlagZ(r);

	movzx	eax, BYTE PTR _r$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
	jmp	$LN20@PREFIX_CB
$LN9@PREFIX_CB:

; 714  :   } else if ((code&0xF8) == 0x18) { //RR r

	movzx	ecx, BYTE PTR _code$[ebp]
	and	ecx, 248				; 000000f8H
	cmp	ecx, 24					; 00000018H
	jne	$LN7@PREFIX_CB

; 715  :     uint8_t r = getr();

	lea	ecx, DWORD PTR _getr$[ebp]
	call	??R<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QBEEXZ ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::operator()
	mov	BYTE PTR _r$5[ebp], al

; 716  :     uint8_t oldC = reg.F.C;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR _oldC$4[ebp], al

; 717  :     reg.F.C = r&1;

	movzx	ecx, BYTE PTR _r$5[ebp]
	and	ecx, 1
	and	cl, 1
	shl	cl, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 239					; 000000efH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 718  :     r = r >> 1;

	movzx	edx, BYTE PTR _r$5[ebp]
	sar	edx, 1
	mov	BYTE PTR _r$5[ebp], dl

; 719  :     r |= oldC<<7;

	movzx	eax, BYTE PTR _oldC$4[ebp]
	shl	eax, 7
	movzx	ecx, BYTE PTR _r$5[ebp]
	or	ecx, eax
	mov	BYTE PTR _r$5[ebp], cl

; 720  :     setr(r);

	movzx	edx, BYTE PTR _r$5[ebp]
	push	edx
	lea	ecx, DWORD PTR _setr$[ebp]
	call	??R<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QBEXE@Z ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::operator()

; 721  :     reg.F.H  = reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 722  :     updateCpuFlagZ(r);

	movzx	eax, BYTE PTR _r$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
	jmp	$LN20@PREFIX_CB
$LN7@PREFIX_CB:

; 723  : 
; 724  :   } else if ((code&0xF8) == 0x20) { //SLA r

	movzx	ecx, BYTE PTR _code$[ebp]
	and	ecx, 248				; 000000f8H
	cmp	ecx, 32					; 00000020H
	jne	$LN5@PREFIX_CB

; 725  :     uint8_t r = getr();

	lea	ecx, DWORD PTR _getr$[ebp]
	call	??R<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QBEEXZ ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::operator()
	mov	BYTE PTR _r$3[ebp], al

; 726  :     reg.F.C = ((r&0x80)>>7);

	movzx	edx, BYTE PTR _r$3[ebp]
	and	edx, 128				; 00000080H
	sar	edx, 7
	and	dl, 1
	shl	dl, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 239					; 000000efH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 727  :     r = r << 1;

	movzx	eax, BYTE PTR _r$3[ebp]
	shl	eax, 1
	mov	BYTE PTR _r$3[ebp], al

; 728  :     r &= ~0x01;

	movzx	ecx, BYTE PTR _r$3[ebp]
	and	ecx, -2					; fffffffeH
	mov	BYTE PTR _r$3[ebp], cl

; 729  :     setr(r);

	movzx	edx, BYTE PTR _r$3[ebp]
	push	edx
	lea	ecx, DWORD PTR _setr$[ebp]
	call	??R<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QBEXE@Z ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::operator()

; 730  :     reg.F.H  = reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 731  :     updateCpuFlagZ(r);

	movzx	eax, BYTE PTR _r$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
	jmp	$LN20@PREFIX_CB
$LN5@PREFIX_CB:

; 732  :   } else if ((code&0xF8) == 0x28) { //SRA r

	movzx	ecx, BYTE PTR _code$[ebp]
	and	ecx, 248				; 000000f8H
	cmp	ecx, 40					; 00000028H
	jne	$LN3@PREFIX_CB

; 733  :     uint8_t r = getr();

	lea	ecx, DWORD PTR _getr$[ebp]
	call	??R<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QBEEXZ ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::operator()
	mov	BYTE PTR _r$2[ebp], al

; 734  :     reg.F.C = r&1;

	movzx	edx, BYTE PTR _r$2[ebp]
	and	edx, 1
	and	dl, 1
	shl	dl, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 239					; 000000efH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 735  :     r = (r&0x80) + (r >> 1);

	movzx	eax, BYTE PTR _r$2[ebp]
	and	eax, 128				; 00000080H
	movzx	ecx, BYTE PTR _r$2[ebp]
	sar	ecx, 1
	add	eax, ecx
	mov	BYTE PTR _r$2[ebp], al

; 736  :     setr(r);

	movzx	edx, BYTE PTR _r$2[ebp]
	push	edx
	lea	ecx, DWORD PTR _setr$[ebp]
	call	??R<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QBEXE@Z ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::operator()

; 737  :     reg.F.H  = reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 738  :     updateCpuFlagZ(r);

	movzx	eax, BYTE PTR _r$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
	jmp	$LN20@PREFIX_CB
$LN3@PREFIX_CB:

; 739  :   } else if ((code & 0xF8) == 0x38) { //SRL n

	movzx	ecx, BYTE PTR _code$[ebp]
	and	ecx, 248				; 000000f8H
	cmp	ecx, 56					; 00000038H
	jne	SHORT $LN20@PREFIX_CB

; 740  :     auto r = getr();

	lea	ecx, DWORD PTR _getr$[ebp]
	call	??R<lambda_cf4d431a50c7ddf749029b7e3fcc8a53>@@QBEEXZ ; <lambda_cf4d431a50c7ddf749029b7e3fcc8a53>::operator()
	mov	BYTE PTR _r$1[ebp], al

; 741  :     reg.F.C = r&1;

	movzx	edx, BYTE PTR _r$1[ebp]
	and	edx, 1
	and	dl, 1
	shl	dl, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 239					; 000000efH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 742  :     r >>= 1;

	mov	al, BYTE PTR _r$1[ebp]
	shr	al, 1
	mov	BYTE PTR _r$1[ebp], al

; 743  :     setr(r);

	movzx	ecx, BYTE PTR _r$1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _setr$[ebp]
	call	??R<lambda_08bfd30db2c73e418a55b8072ee85de7>@@QBEXE@Z ; <lambda_08bfd30db2c73e418a55b8072ee85de7>::operator()

; 744  :     reg.F.H  = reg.F.N = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 191					; 000000bfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 223					; 000000dfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 745  :     updateCpuFlagZ(r);

	movzx	edx, BYTE PTR _r$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ; emulation::gb::Cpu::updateCpuFlagZ
$LN20@PREFIX_CB:

; 746  :   }
; 747  :   Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 748  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN30@PREFIX_CB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 72					; 00000048H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN30@PREFIX_CB:
	DD	3
	DD	$LN29@PREFIX_CB
$LN29@PREFIX_CB:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN26@PREFIX_CB
	DD	-28					; ffffffe4H
	DD	8
	DD	$LN27@PREFIX_CB
	DD	-44					; ffffffd4H
	DD	8
	DD	$LN28@PREFIX_CB
$LN28@PREFIX_CB:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN27@PREFIX_CB:
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN26@PREFIX_CB:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
?PREFIX_CB@Cpu@gb@emulation@@AAEXXZ ENDP		; emulation::gb::Cpu::PREFIX_CB
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CPL@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::CPL
; _this$ = ecx

; 634  : void Cpu::CPL() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 635  :   reg.F.H = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 636  :   reg.F.N = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 637  :   reg.A = ~reg.A;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1065]
	not	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1065], cl

; 638  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CPL@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::CPL
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?STOP@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::STOP
; _this$ = ecx

; 630  : void Cpu::STOP() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 631  :   cpumode_ = CpuModeStop;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 2

; 632  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?STOP@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::STOP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HALT@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::HALT
; _this$ = ecx

; 626  : void Cpu::HALT() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 627  :   cpumode_ = CpuModeHalt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 1

; 628  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HALT@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::HALT
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CCF@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::CCF
; _this$ = ecx

; 621  : void Cpu::CCF() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 622  :   reg.F.H = reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 623  :   reg.F.C = ~reg.F.C;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	not	edx
	and	dl, 1
	shl	dl, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 239					; 000000efH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 624  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CCF@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::CCF
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SCF@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::SCF
; _this$ = ecx

; 616  : void Cpu::SCF() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 617  :   reg.F.H = reg.F.N = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 223					; 000000dfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 618  :   reg.F.C = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	or	cl, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 619  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SCF@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::SCF
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
tv90 = -12						; size = 2
_r8$ = -9						; size = 1
_a$ = -8						; size = 2
_this$ = -4						; size = 4
?ADD_SPr8@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::ADD_SPr8
; _this$ = ecx

; 523  : void Cpu::ADD_SPr8() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 524  :   reg.F.N  = reg.F.Z = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 525  : 	uint16_t a = reg.SP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1072]
	mov	WORD PTR _a$[ebp], cx

; 526  : 	int8_t r8 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv90[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv90[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _r8$[ebp], al

; 527  : 	reg.SP += r8;

	movsx	eax, BYTE PTR _r8$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+1072]
	add	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1072], dx

; 528  : 
; 529  :   updateCpuFlagC(a&0xFF,r8,0);

	push	0
	movzx	ecx, BYTE PTR _r8$[ebp]
	push	ecx
	movzx	edx, WORD PTR _a$[ebp]
	and	edx, 255				; 000000ffH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 530  :   updateCpuFlagH(a&0xFF,r8,0);

	push	0
	movzx	eax, BYTE PTR _r8$[ebp]
	push	eax
	movzx	ecx, WORD PTR _a$[ebp]
	and	ecx, 255				; 000000ffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 531  : 	Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 532  : 	Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 533  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ADD_SPr8@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::ADD_SPr8
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
tv87 = -12						; size = 2
tv74 = -10						; size = 2
_a16$ = -8						; size = 2
_this$ = -4						; size = 4
?LDa16SP@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::LDa16SP
; _this$ = ecx

; 491  : void Cpu::LDa16SP() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 492  :   uint16_t a16 = mem_->Read8(reg.PC++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	mov	WORD PTR tv74[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax
	movzx	edx, WORD PTR tv74[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	cx, al
	mov	WORD PTR _a16$[ebp], cx

; 493  :   a16 |= (mem_->Read8(reg.PC++))<<8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv87[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv87[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	movzx	eax, al
	shl	eax, 8
	movzx	ecx, WORD PTR _a16$[ebp]
	or	ecx, eax
	mov	WORD PTR _a16$[ebp], cx

; 494  :   mem_->Write8(a16,reg.SP&0xFF);

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+1072]
	and	eax, 255				; 000000ffH
	push	eax
	movzx	ecx, WORD PTR _a16$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 495  :   mem_->Write8(a16+1,reg.SP>>8);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1072]
	sar	ecx, 8
	push	ecx
	movzx	edx, WORD PTR _a16$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 496  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?LDa16SP@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::LDa16SP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
tv90 = -12						; size = 2
_r8$ = -9						; size = 1
_a$ = -8						; size = 2
_this$ = -4						; size = 4
?LDHLSPr8@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::LDHLSPr8
; _this$ = ecx

; 474  : void Cpu::LDHLSPr8() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 475  : 
; 476  : 
; 477  : 
; 478  :   reg.F.N  = reg.F.Z = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1064]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1064], cl

; 479  : 	uint16_t a = reg.SP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1072]
	mov	WORD PTR _a$[ebp], cx

; 480  : 	int8_t r8 = mem_->Read8(reg.PC++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1074]
	mov	WORD PTR tv90[ebp], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx
	movzx	ecx, WORD PTR tv90[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	BYTE PTR _r8$[ebp], al

; 481  : 	reg.HL = (reg.SP + r8);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1072]
	movsx	edx, BYTE PTR _r8$[ebp]
	add	ecx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1070], cx

; 482  :   updateCpuFlagC(a&0xFF,r8,0);

	push	0
	movzx	ecx, BYTE PTR _r8$[ebp]
	push	ecx
	movzx	edx, WORD PTR _a$[ebp]
	and	edx, 255				; 000000ffH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagC

; 483  :   updateCpuFlagH(a&0xFF,r8,0);

	push	0
	movzx	eax, BYTE PTR _r8$[ebp]
	push	eax
	movzx	ecx, WORD PTR _a$[ebp]
	and	ecx, 255				; 000000ffH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ; emulation::gb::Cpu::updateCpuFlagH

; 484  :   /*uint16_t r1 = (a&0xFFF) + (r8&0xFFF);
; 485  :   reg.F.H = r1>0xFFF?1:0;
; 486  :   uint32_t r2 = (a&0xFFFF) + (r8&0xFFFF);
; 487  :   reg.F.C = r2>0xFFFF?1:0;*/
; 488  : 	Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 489  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?LDHLSPr8@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::LDHLSPr8
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LDSPHL@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::LDSPHL
; _this$ = ecx

; 469  : void Cpu::LDSPHL() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 470  :   reg.SP = reg.HL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1070]
	mov	WORD PTR [eax+1072], dx

; 471  :   Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 472  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?LDSPHL@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::LDSPHL
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_t$ = -5						; size = 1
_this$ = -4						; size = 4
?RST@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::RST
; _this$ = ecx

; 379  : void Cpu::RST() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 380  :   pushPC();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushPC@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::pushPC

; 381  :   uint8_t t = (opcode&0x38)>>3;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1081]
	and	ecx, 56					; 00000038H
	sar	ecx, 3
	mov	BYTE PTR _t$[ebp], cl

; 382  :   reg.PC = t*8;

	movzx	edx, BYTE PTR _t$[ebp]
	shl	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx

; 383  :   Tick();Tick();Tick();Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick

; 384  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RST@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::RST
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_a$ = -8						; size = 4
_this$ = -4						; size = 4
?ILLEGAL@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::ILLEGAL
; _this$ = ecx

; 375  : void Cpu::ILLEGAL() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 376  : 	int a = 1;

	mov	DWORD PTR _a$[ebp], 1

; 377  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ILLEGAL@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::ILLEGAL
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NOP@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::NOP
; _this$ = ecx

; 368  : void Cpu::NOP() { 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 369  :   //Tick();
; 370  :   //Tick();
; 371  :   //Tick();
; 372  :   //Tick();
; 373  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NOP@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::NOP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ?pushPC@Cpu@gb@emulation@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pushPC@Cpu@gb@emulation@@AAEXXZ PROC			; emulation::gb::Cpu::pushPC, COMDAT
; _this$ = ecx

; 137  :   void pushPC() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 138  :     push((reg.PC&0xFF00)>>8);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+1074]
	and	ecx, 65280				; 0000ff00H
	sar	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@Cpu@gb@emulation@@AAEXE@Z		; emulation::gb::Cpu::push

; 139  :     push(reg.PC&0xFF);

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+1074]
	and	eax, 255				; 000000ffH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@Cpu@gb@emulation@@AAEXE@Z		; emulation::gb::Cpu::push

; 140  :   }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pushPC@Cpu@gb@emulation@@AAEXXZ ENDP			; emulation::gb::Cpu::pushPC
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ?pop@Cpu@gb@emulation@@AAEEXZ
_TEXT	SEGMENT
tv74 = -6						; size = 2
_this$ = -4						; size = 4
?pop@Cpu@gb@emulation@@AAEEXZ PROC			; emulation::gb::Cpu::pop, COMDAT
; _this$ = ecx

; 119  :   uint8_t pop() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 120  :     return mem_->Read8(reg.SP++);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1072]
	mov	WORD PTR tv74[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+1072]
	add	ax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1072], ax
	movzx	edx, WORD PTR tv74[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8

; 121  :   }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pop@Cpu@gb@emulation@@AAEEXZ ENDP			; emulation::gb::Cpu::pop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ?push@Cpu@gb@emulation@@AAEXE@Z
_TEXT	SEGMENT
tv71 = -6						; size = 2
_this$ = -4						; size = 4
_data$ = 8						; size = 1
?push@Cpu@gb@emulation@@AAEXE@Z PROC			; emulation::gb::Cpu::push, COMDAT
; _this$ = ecx

; 115  :   void push(uint8_t data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 116  :     mem_->Write8(--reg.SP,data);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1072]
	sub	cx, 1
	mov	WORD PTR tv71[ebp], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR tv71[ebp]
	mov	WORD PTR [edx+1072], ax
	movzx	ecx, BYTE PTR _data$[ebp]
	push	ecx
	movzx	edx, WORD PTR tv71[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1076]
	call	?Write8@Memory@gb@emulation@@QAEXGE@Z	; emulation::gb::Memory::Write8

; 117  :   }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push@Cpu@gb@emulation@@AAEXE@Z ENDP			; emulation::gb::Cpu::push
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_r$ = 8							; size = 1
?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z PROC		; emulation::gb::Cpu::updateCpuFlagZ, COMDAT
; _this$ = ecx

; 111  :   void updateCpuFlagZ(uint8_t r) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 112  :     reg.F.Z = r == 0?1:0;

	movzx	eax, BYTE PTR _r$[ebp]
	test	eax, eax
	jne	SHORT $LN3@updateCpuF
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@updateCpuF
$LN3@updateCpuF:
	mov	DWORD PTR tv69[ebp], 0
$LN4@updateCpuF:
	mov	cl, BYTE PTR tv69[ebp]
	and	cl, 1
	shl	cl, 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+1064]
	and	al, 127					; 0000007fH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1064], al

; 113  :   }

	mov	esp, ebp
	pop	ebp
	ret	4
?updateCpuFlagZ@Cpu@gb@emulation@@AAEXE@Z ENDP		; emulation::gb::Cpu::updateCpuFlagZ
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z
_TEXT	SEGMENT
tv93 = -16						; size = 4
tv76 = -12						; size = 4
_r1$1 = -5						; size = 1
_this$ = -4						; size = 4
_a$ = 8							; size = 1
_b$ = 12						; size = 1
_mode$ = 16						; size = 4
?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z PROC	; emulation::gb::Cpu::updateCpuFlagH, COMDAT
; _this$ = ecx

; 98   :   void updateCpuFlagH(uint8_t a,uint8_t b,int mode) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 99   :     /*if((dest^b^a)&0x10)
; 100  :       reg.F.H=1;
; 101  :     else
; 102  :       reg.F.H=0;*/
; 103  :     if (mode == 0) {

	cmp	DWORD PTR _mode$[ebp], 0
	jne	SHORT $LN2@updateCpuF

; 104  :       uint8_t r1 = (a&0xF) + (b&0xF);

	movzx	eax, BYTE PTR _a$[ebp]
	and	eax, 15					; 0000000fH
	movzx	ecx, BYTE PTR _b$[ebp]
	and	ecx, 15					; 0000000fH
	add	eax, ecx
	mov	BYTE PTR _r1$1[ebp], al

; 105  :       reg.F.H = r1>0xF?1:0;

	movzx	edx, BYTE PTR _r1$1[ebp]
	cmp	edx, 15					; 0000000fH
	jle	SHORT $LN5@updateCpuF
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN6@updateCpuF
$LN5@updateCpuF:
	mov	DWORD PTR tv76[ebp], 0
$LN6@updateCpuF:
	mov	al, BYTE PTR tv76[ebp]
	and	al, 1
	shl	al, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+1064]
	and	dl, 223					; 000000dfH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], dl

; 106  :     } else {

	jmp	SHORT $LN3@updateCpuF
$LN2@updateCpuF:

; 107  :       reg.F.H = (a&0xF) < (b&0xF) ? 1 : 0;

	movzx	ecx, BYTE PTR _a$[ebp]
	and	ecx, 15					; 0000000fH
	movzx	edx, BYTE PTR _b$[ebp]
	and	edx, 15					; 0000000fH
	cmp	ecx, edx
	jge	SHORT $LN7@updateCpuF
	mov	DWORD PTR tv93[ebp], 1
	jmp	SHORT $LN8@updateCpuF
$LN7@updateCpuF:
	mov	DWORD PTR tv93[ebp], 0
$LN8@updateCpuF:
	mov	al, BYTE PTR tv93[ebp]
	and	al, 1
	shl	al, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+1064]
	and	dl, 223					; 000000dfH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], dl
$LN3@updateCpuF:

; 108  :     }
; 109  :   }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?updateCpuFlagH@Cpu@gb@emulation@@AAEXEEH@Z ENDP	; emulation::gb::Cpu::updateCpuFlagH
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.h
;	COMDAT ?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z
_TEXT	SEGMENT
tv89 = -16						; size = 4
tv74 = -12						; size = 4
_r2$1 = -8						; size = 2
_this$ = -4						; size = 4
_a$ = 8							; size = 1
_b$ = 12						; size = 1
_mode$ = 16						; size = 4
?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z PROC	; emulation::gb::Cpu::updateCpuFlagC, COMDAT
; _this$ = ecx

; 89   :   void updateCpuFlagC(uint8_t a,uint8_t b,int mode) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 90   :     if (mode == 0) {

	cmp	DWORD PTR _mode$[ebp], 0
	jne	SHORT $LN2@updateCpuF

; 91   :       uint16_t r2 = (a) + (b);

	movzx	eax, BYTE PTR _a$[ebp]
	movzx	ecx, BYTE PTR _b$[ebp]
	add	eax, ecx
	mov	WORD PTR _r2$1[ebp], ax

; 92   :       reg.F.C = r2>0xFF?1:0;

	movzx	edx, WORD PTR _r2$1[ebp]
	cmp	edx, 255				; 000000ffH
	jle	SHORT $LN5@updateCpuF
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN6@updateCpuF
$LN5@updateCpuF:
	mov	DWORD PTR tv74[ebp], 0
$LN6@updateCpuF:
	mov	al, BYTE PTR tv74[ebp]
	and	al, 1
	shl	al, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+1064]
	and	dl, 239					; 000000efH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], dl

; 93   :     } else {

	jmp	SHORT $LN3@updateCpuF
$LN2@updateCpuF:

; 94   :       reg.F.C = a < b ? 1 : 0;

	movzx	ecx, BYTE PTR _a$[ebp]
	movzx	edx, BYTE PTR _b$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN7@updateCpuF
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN8@updateCpuF
$LN7@updateCpuF:
	mov	DWORD PTR tv89[ebp], 0
$LN8@updateCpuF:
	mov	al, BYTE PTR tv89[ebp]
	and	al, 1
	shl	al, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+1064]
	and	dl, 239					; 000000efH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1064], dl
$LN3@updateCpuF:

; 95   :     }
; 96   :   }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?updateCpuFlagC@Cpu@gb@emulation@@AAEXEEH@Z ENDP	; emulation::gb::Cpu::updateCpuFlagC
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ PROC	; emulation::gb::Cpu::simulateSpriteBug
; _this$ = ecx

; 1024 : void Cpu::simulateSpriteBug() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1025 :    
; 1026 :   if (sprite_bug == 1) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	cmp	ecx, 1
	jne	SHORT $LN2@simulateSp

; 1027 :     emu_->lcd_driver()->sprite_bug_counter = 80;//20cycles

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?lcd_driver@Emu@gb@emulation@@QAEPAVLCDDriver@23@XZ ; emulation::gb::Emu::lcd_driver
	mov	BYTE PTR [eax+8], 80			; 00000050H

; 1028 :     //auto oam = emu_->memory()->oam();
; 1029 :     //for (int i=8;i<0xA0;++i)
; 1030 :     //  oam[i] = rand()&0xFF;
; 1031 :     sprite_bug = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+8], 0
$LN2@simulateSp:

; 1032 :   }
; 1033 :   
; 1034 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?simulateSpriteBug@Cpu@gb@emulation@@AAEXXZ ENDP	; emulation::gb::Cpu::simulateSpriteBug
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
tv254 = -28						; size = 4
tv236 = -24						; size = 4
tv218 = -20						; size = 4
tv200 = -16						; size = 4
tv182 = -12						; size = 4
tv94 = -8						; size = 2
_test$1 = -5						; size = 1
_this$ = -4						; size = 4
_dt$ = 8						; size = 8
?Step@Cpu@gb@emulation@@QAEXN@Z PROC			; emulation::gb::Cpu::Step
; _this$ = ecx

; 323  : void Cpu::Step(double dt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 324  :   this->dt = dt;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _dt$[ebp]
	movsd	QWORD PTR [eax+32], xmm0

; 325  : 	cycles = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0

; 326  :   //reg.F._unused = 0;//always 0 according to docs
; 327  :   //StopAt(0xC47A);
; 328  :   //StopAt(0x0100);
; 329  :   //StopAt(0x0073);
; 330  :   if (cpumode_ == CpuModeStop) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 2
	jne	SHORT $LN16@Step

; 331  :     cycles = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 1
	mov	DWORD PTR [eax+20], 0

; 332  :     return;

	jmp	$LN17@Step
$LN16@Step:

; 333  :   }
; 334  :   if (cpumode_ == CpuModeNormal) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	$LN15@Step

; 335  :     if (sprite_bug!=0) --sprite_bug;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+8]
	test	eax, eax
	je	SHORT $LN14@Step
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+8]
	sub	dl, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+8], dl
$LN14@Step:

; 336  :     opcode = emu_->memory()->Read8(reg.PC++);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1074]
	mov	WORD PTR tv94[ebp], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1074]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx
	movzx	eax, WORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?Read8@Memory@gb@emulation@@QAEEG@Z	; emulation::gb::Memory::Read8
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1081], al

; 337  :     (this->*(instructions[opcode]))();

	mov	eax, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [eax+1081]
	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN12@Step
$LN15@Step:

; 338  :   } else if (cpumode_ == CpuModeHalt) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN12@Step

; 339  :     Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Tick@Cpu@gb@emulation@@QAEXXZ		; emulation::gb::Cpu::Tick
$LN12@Step:

; 340  :   }
; 341  : 
; 342  :   if (ime) {

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1080]
	test	edx, edx
	je	$LN1@Step

; 343  :     uint8_t test = emu_->memory()->interrupt_enable() & emu_->memory()->interrupt_flag();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_enable@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_enable
	movzx	ebx, BYTE PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	movzx	edx, BYTE PTR [eax]
	and	ebx, edx
	mov	BYTE PTR _test$1[ebp], bl

; 344  : 		if (test) {

	movzx	eax, BYTE PTR _test$1[ebp]
	test	eax, eax
	je	$LN1@Step

; 345  : 			ime = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1080], 0

; 346  :       cpumode_ = CpuModeNormal;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0

; 347  : 			pushPC();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushPC@Cpu@gb@emulation@@AAEXXZ	; emulation::gb::Cpu::pushPC

; 348  : 			if (test & 0x1) { //vblank

	movzx	eax, BYTE PTR _test$1[ebp]
	and	eax, 1
	je	SHORT $LN9@Step

; 349  : 				reg.PC = 0x0040;

	mov	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx

; 350  : 				emu_->memory()->interrupt_flag() &= ~0x1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv182[ebp], eax
	mov	ecx, DWORD PTR tv182[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR tv182[ebp]
	mov	BYTE PTR [eax], dl
	jmp	$LN1@Step
$LN9@Step:

; 351  : 			} else if (test & 0x2) {

	movzx	ecx, BYTE PTR _test$1[ebp]
	and	ecx, 2
	je	SHORT $LN7@Step

; 352  : 				reg.PC = 0x0048; //lcdc status

	mov	edx, 72					; 00000048H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx

; 353  : 				emu_->memory()->interrupt_flag() &= ~0x2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv200[ebp], eax
	mov	edx, DWORD PTR tv200[ebp]
	movzx	eax, BYTE PTR [edx]
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR tv200[ebp]
	mov	BYTE PTR [ecx], al
	jmp	$LN1@Step
$LN7@Step:

; 354  : 			} else if (test & 0x4) {

	movzx	edx, BYTE PTR _test$1[ebp]
	and	edx, 4
	je	SHORT $LN5@Step

; 355  : 				reg.PC = 0x0050; //timer overflow

	mov	eax, 80					; 00000050H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1074], ax

; 356  : 				emu_->memory()->interrupt_flag() &= ~0x4;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv218[ebp], eax
	mov	eax, DWORD PTR tv218[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR tv218[ebp]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN1@Step
$LN5@Step:

; 357  : 			} else if (test & 0x8) {

	movzx	eax, BYTE PTR _test$1[ebp]
	and	eax, 8
	je	SHORT $LN3@Step

; 358  : 				reg.PC = 0x0058; //serial transfer

	mov	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx

; 359  : 				emu_->memory()->interrupt_flag() &= ~0x8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv236[ebp], eax
	mov	ecx, DWORD PTR tv236[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, -9					; fffffff7H
	mov	eax, DWORD PTR tv236[ebp]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN1@Step
$LN3@Step:

; 360  : 			} else if (test & 0x10) {

	movzx	ecx, BYTE PTR _test$1[ebp]
	and	ecx, 16					; 00000010H
	je	SHORT $LN1@Step

; 361  : 				reg.PC = 0x0060; //hi-lo p10-p13

	mov	edx, 96					; 00000060H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1074], dx

; 362  : 				emu_->memory()->interrupt_flag() &= ~0x10;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ; emulation::gb::Memory::interrupt_flag
	mov	DWORD PTR tv254[ebp], eax
	mov	edx, DWORD PTR tv254[ebp]
	movzx	eax, BYTE PTR [edx]
	and	eax, -17				; ffffffefH
	mov	ecx, DWORD PTR tv254[ebp]
	mov	BYTE PTR [ecx], al
$LN1@Step:
$LN17@Step:

; 363  : 			}
; 364  : 		}
; 365  :   }
; 366  : }

	pop	esi
	pop	ebx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Step@Cpu@gb@emulation@@QAEXN@Z ENDP			; emulation::gb::Cpu::Step
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
tv85 = -8						; size = 4
_this$ = -4						; size = 4
?Tick@Cpu@gb@emulation@@QAEXXZ PROC			; emulation::gb::Cpu::Tick
; _this$ = ecx

; 313  : void Cpu::Tick() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 314  :   ++cycles;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR [eax+20]
	adc	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], edx

; 315  : 	emu_->timer()->Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?timer@Emu@gb@emulation@@QAEPAVTimer@23@XZ ; emulation::gb::Emu::timer
	mov	ecx, eax
	call	?Tick@Timer@gb@emulation@@QAEXXZ	; emulation::gb::Timer::Tick

; 316  :   emu_->cartridge()->mbc->Tick();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?cartridge@Emu@gb@emulation@@QAEPAVCartridge@23@XZ ; emulation::gb::Emu::cartridge
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv85[ebp], eax
	mov	ecx, DWORD PTR tv85[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR tv85[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 317  : 	emu_->memory()->Tick();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	ecx, eax
	call	?Tick@Memory@gb@emulation@@QAEXXZ	; emulation::gb::Memory::Tick

; 318  :   emu_->lcd_driver()->Step(dt);

	mov	edx, DWORD PTR _this$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [edx+32]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?lcd_driver@Emu@gb@emulation@@QAEPAVLCDDriver@23@XZ ; emulation::gb::Emu::lcd_driver
	mov	ecx, eax
	call	?Step@LCDDriver@gb@emulation@@QAEXN@Z	; emulation::gb::LCDDriver::Step

; 319  : 	emu_->sc()->Step(dt);

	mov	ecx, DWORD PTR _this$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx+32]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?sc@Emu@gb@emulation@@QAEPAVSoundController@23@XZ ; emulation::gb::Emu::sc
	mov	ecx, eax
	call	?Step@SoundController@gb@emulation@@QAEXN@Z ; emulation::gb::SoundController::Step

; 320  : 
; 321  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Tick@Cpu@gb@emulation@@QAEXXZ ENDP			; emulation::gb::Cpu::Tick
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Reset@Cpu@gb@emulation@@UAEXXZ PROC			; emulation::gb::Cpu::Reset
; _this$ = ecx

; 304  : void Cpu::Reset() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 305  : 	memset(&reg,0,sizeof(reg));

	push	12					; 0000000cH
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1064				; 00000428H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 306  :   reg.PC = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1074], cx

; 307  :   cycles = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0

; 308  :   ime = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1080], 0

; 309  :   cpumode_ = CpuModeNormal;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0

; 310  :   sprite_bug = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+8], 0

; 311  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@Cpu@gb@emulation@@UAEXXZ ENDP			; emulation::gb::Cpu::Reset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Deinitialize@Cpu@gb@emulation@@UAEXXZ PROC		; emulation::gb::Cpu::Deinitialize
; _this$ = ecx

; 300  : void Cpu::Deinitialize() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 301  : 
; 302  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Deinitialize@Cpu@gb@emulation@@UAEXXZ ENDP		; emulation::gb::Cpu::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_emu$ = 8						; size = 4
?Initialize@Cpu@gb@emulation@@UAEXPAVEmu@23@@Z PROC	; emulation::gb::Cpu::Initialize
; _this$ = ecx

; 294  : void Cpu::Initialize(Emu* emu) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 295  :   Component::Initialize(emu);

	mov	eax, DWORD PTR _emu$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ; emulation::gb::Component::Initialize

; 296  :   mem_ = emu_->memory();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?memory@Emu@gb@emulation@@QAEPAVMemory@23@XZ ; emulation::gb::Emu::memory
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1076], eax

; 297  :   Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 298  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Initialize@Cpu@gb@emulation@@UAEXPAVEmu@23@@Z ENDP	; emulation::gb::Cpu::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Cpu@gb@emulation@@QAE@XZ PROC			; emulation::gb::Cpu::~Cpu
; _this$ = ecx

; 290  : Cpu::~Cpu() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Cpu@gb@emulation@@6B@

; 291  : 
; 292  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1Cpu@gb@emulation@@QAE@XZ ENDP			; emulation::gb::Cpu::~Cpu
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\cpu.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Cpu@gb@emulation@@QAE@XZ PROC			; emulation::gb::Cpu::Cpu
; _this$ = ecx

; 15   : Cpu::Cpu() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Component@gb@emulation@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Cpu@gb@emulation@@6B@

; 16   : 	instructions[0x00] = &Cpu::NOP;

	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?NOP@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::NOP

; 17   : 	instructions[0x01] = &Cpu::LDrd16<RegBC>;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrd16@$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrd16<1>

; 18   : 	instructions[0x02] = &Cpu::LD$rr<RegBC,RegA>;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LD$rr@$00$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD$rr<1,1>

; 19   : 	instructions[0x03] = &Cpu::INC_16bit<RegBC>;

	mov	ecx, 4
	imul	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$INC_16bit@$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::INC_16bit<1>

; 20   : 	instructions[0x04] = &Cpu::INC_8bit<RegB,0>;

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$INC_8bit@$02$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::INC_8bit<3,0>

; 21   : 	instructions[0x05] = &Cpu::DEC_8bit<RegB,0>;

	mov	edx, 4
	imul	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$DEC_8bit@$02$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::DEC_8bit<3,0>

; 22   : 	instructions[0x06] = &Cpu::LD<RegB,0,10>;

	mov	ecx, 4
	imul	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LD@$02$0A@$09@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD<3,0,10>

; 23   : 	instructions[0x07] = &Cpu::RLCA;

	mov	eax, 4
	imul	eax, 7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?RLCA@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RLCA

; 24   : 	instructions[0x08] = &Cpu::LDa16SP;

	mov	edx, 4
	shl	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ?LDa16SP@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDa16SP

; 25   : 	instructions[0x09] = &Cpu::ADD_16bit<RegHL,RegBC>;

	mov	ecx, 4
	imul	ecx, 9
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$ADD_16bit@$02$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADD_16bit<3,1>

; 26   : 	instructions[0x0A] = &Cpu::LDr$r<RegA,RegBC>;

	mov	eax, 4
	imul	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDr$r@$00$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDr$r<1,1>

; 27   : 	instructions[0x0B] = &Cpu::DEC_16bit<RegBC>;

	mov	edx, 4
	imul	edx, 11					; 0000000bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$DEC_16bit@$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::DEC_16bit<1>

; 28   : 	instructions[0x0C] = &Cpu::INC_8bit<RegC,0>;

	mov	ecx, 4
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$INC_8bit@$01$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::INC_8bit<2,0>

; 29   : 	instructions[0x0D] = &Cpu::DEC_8bit<RegC,0>;

	mov	eax, 4
	imul	eax, 13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$DEC_8bit@$01$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::DEC_8bit<2,0>

; 30   : 	instructions[0x0E] = &Cpu::LD<RegC,0,10>;

	mov	edx, 4
	imul	edx, 14					; 0000000eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LD@$01$0A@$09@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD<2,0,10>

; 31   : 	instructions[0x0F] = &Cpu::RRCA;

	mov	ecx, 4
	imul	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?RRCA@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RRCA

; 32   : 
; 33   : 	instructions[0x10] = &Cpu::STOP;

	mov	eax, 4
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?STOP@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::STOP

; 34   : 	instructions[0x11] = &Cpu::LDrd16<RegDE>;

	mov	edx, 4
	imul	edx, 17					; 00000011H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrd16@$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrd16<2>

; 35   : 	instructions[0x12] = &Cpu::LD$rr<RegDE,RegA>;

	mov	ecx, 4
	imul	ecx, 18					; 00000012H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LD$rr@$01$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD$rr<2,1>

; 36   : 	instructions[0x13] = &Cpu::INC_16bit<RegDE>;

	mov	eax, 4
	imul	eax, 19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$INC_16bit@$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::INC_16bit<2>

; 37   : 	instructions[0x14] = &Cpu::INC_8bit<RegD,0>;

	mov	edx, 4
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$INC_8bit@$04$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::INC_8bit<5,0>

; 38   : 	instructions[0x15] = &Cpu::DEC_8bit<RegD,0>;

	mov	ecx, 4
	imul	ecx, 21					; 00000015H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$DEC_8bit@$04$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::DEC_8bit<5,0>

; 39   : 	instructions[0x16] = &Cpu::LD<RegD,0,10>;

	mov	eax, 4
	imul	eax, 22					; 00000016H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LD@$04$0A@$09@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD<5,0,10>

; 40   : 	instructions[0x17] = &Cpu::RLA;

	mov	edx, 4
	imul	edx, 23					; 00000017H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ?RLA@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RLA

; 41   : 	instructions[0x18] = &Cpu::JR;

	mov	ecx, 4
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?JR@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::JR

; 42   : 	instructions[0x19] = &Cpu::ADD_16bit<RegHL,RegDE>;

	mov	eax, 4
	imul	eax, 25					; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$ADD_16bit@$02$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADD_16bit<3,2>

; 43   : 	instructions[0x1A] = &Cpu::LDr$r<RegA,RegDE>;

	mov	edx, 4
	imul	edx, 26					; 0000001aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDr$r@$00$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDr$r<1,2>

; 44   : 	instructions[0x1B] = &Cpu::DEC_16bit<RegDE>;

	mov	ecx, 4
	imul	ecx, 27					; 0000001bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$DEC_16bit@$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::DEC_16bit<2>

; 45   : 	instructions[0x1C] = &Cpu::INC_8bit<RegE,0>;

	mov	eax, 4
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$INC_8bit@$03$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::INC_8bit<4,0>

; 46   : 	instructions[0x1D] = &Cpu::DEC_8bit<RegE,0>;

	mov	edx, 4
	imul	edx, 29					; 0000001dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$DEC_8bit@$03$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::DEC_8bit<4,0>

; 47   : 	instructions[0x1E] = &Cpu::LD<RegE,0,10>;

	mov	ecx, 4
	imul	ecx, 30					; 0000001eH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LD@$03$0A@$09@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD<4,0,10>

; 48   : 	instructions[0x1F] = &Cpu::RRA;

	mov	eax, 4
	imul	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?RRA@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RRA

; 49   : 	
; 50   : 	instructions[0x20] = &Cpu::JR_cc<CpuFlagsZ,1>;

	mov	edx, 4
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$JR_cc@$06$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::JR_cc<7,1>

; 51   : 	instructions[0x21] = &Cpu::LDrd16<RegHL>;

	mov	ecx, 4
	imul	ecx, 33					; 00000021H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrd16@$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrd16<3>

; 52   : 	instructions[0x22] = &Cpu::LDI$regreg<RegHL,RegA>;

	mov	eax, 4
	imul	eax, 34					; 00000022H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDI$regreg@$02$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDI$regreg<3,1>

; 53   : 	instructions[0x23] = &Cpu::INC_16bit<RegHL>;

	mov	edx, 4
	imul	edx, 35					; 00000023H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$INC_16bit@$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::INC_16bit<3>

; 54   : 	instructions[0x24] = &Cpu::INC_8bit<RegH,0>;

	mov	ecx, 4
	imul	ecx, 36					; 00000024H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$INC_8bit@$06$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::INC_8bit<7,0>

; 55   : 	instructions[0x25] = &Cpu::DEC_8bit<RegH,0>;

	mov	eax, 4
	imul	eax, 37					; 00000025H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$DEC_8bit@$06$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::DEC_8bit<7,0>

; 56   : 	instructions[0x26] = &Cpu::LD<RegH,0,10>;

	mov	edx, 4
	imul	edx, 38					; 00000026H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LD@$06$0A@$09@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD<7,0,10>

; 57   :   instructions[0x27] = &Cpu::DAA;

	mov	ecx, 4
	imul	ecx, 39					; 00000027H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?DAA@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::DAA

; 58   : 	instructions[0x28] = &Cpu::JR_cc<CpuFlagsZ,0>;

	mov	eax, 4
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$JR_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::JR_cc<7,0>

; 59   : 	instructions[0x29] = &Cpu::ADD_16bit<RegHL,RegHL>;

	mov	edx, 4
	imul	edx, 41					; 00000029H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$ADD_16bit@$02$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADD_16bit<3,3>

; 60   : 	instructions[0x2A] = &Cpu::LDIreg$reg<RegA,RegHL>;

	mov	ecx, 4
	imul	ecx, 42					; 0000002aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDIreg$reg@$00$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDIreg$reg<1,3>

; 61   : 	instructions[0x2B] = &Cpu::DEC_16bit<RegHL>;

	mov	eax, 4
	imul	eax, 43					; 0000002bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$DEC_16bit@$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::DEC_16bit<3>

; 62   : 	instructions[0x2C] = &Cpu::INC_8bit<RegL,0>;

	mov	edx, 4
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$INC_8bit@$05$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::INC_8bit<6,0>

; 63   : 	instructions[0x2D] = &Cpu::DEC_8bit<RegL,0>;

	mov	ecx, 4
	imul	ecx, 45					; 0000002dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$DEC_8bit@$05$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::DEC_8bit<6,0>

; 64   : 	instructions[0x2E] = &Cpu::LD<RegL,0,10>;

	mov	eax, 4
	imul	eax, 46					; 0000002eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LD@$05$0A@$09@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD<6,0,10>

; 65   : 	instructions[0x2F] = &Cpu::CPL;

	mov	edx, 4
	imul	edx, 47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ?CPL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CPL

; 66   : 
; 67   : 	instructions[0x30] = &Cpu::JR_cc<CpuFlagsC,1>;

	mov	ecx, 4
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$JR_cc@$03$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::JR_cc<4,1>

; 68   : 	instructions[0x31] = &Cpu::LDrd16<RegSP>;

	mov	eax, 4
	imul	eax, 49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrd16@$03@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrd16<4>

; 69   : 	instructions[0x32] = &Cpu::LDD$regreg<RegHL,RegA>;

	mov	edx, 4
	imul	edx, 50					; 00000032H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDD$regreg@$02$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDD$regreg<3,1>

; 70   : 	instructions[0x33] = &Cpu::INC_16bit<RegSP>;

	mov	ecx, 4
	imul	ecx, 51					; 00000033H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$INC_16bit@$03@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::INC_16bit<4>

; 71   : 	instructions[0x34] = &Cpu::INC_8bit<RegHL,1>;

	mov	eax, 4
	imul	eax, 52					; 00000034H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$INC_8bit@$02$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::INC_8bit<3,1>

; 72   : 	instructions[0x35] = &Cpu::DEC_8bit<RegHL,1>;

	mov	edx, 4
	imul	edx, 53					; 00000035H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$DEC_8bit@$02$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::DEC_8bit<3,1>

; 73   : 	instructions[0x36] = &Cpu::LD<RegHL,0,11>;

	mov	ecx, 4
	imul	ecx, 54					; 00000036H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LD@$02$0A@$0L@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD<3,0,11>

; 74   : 	instructions[0x37] = &Cpu::SCF;

	mov	eax, 4
	imul	eax, 55					; 00000037H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?SCF@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SCF

; 75   : 	instructions[0x38] = &Cpu::JR_cc<CpuFlagsC,0>;

	mov	edx, 4
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$JR_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::JR_cc<4,0>

; 76   : 	instructions[0x39] = &Cpu::ADD_16bit<RegHL,RegSP>;

	mov	ecx, 4
	imul	ecx, 57					; 00000039H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$ADD_16bit@$02$03@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADD_16bit<3,4>

; 77   : 	instructions[0x3A] = &Cpu::LDDreg$reg<RegA,RegHL>;

	mov	eax, 4
	imul	eax, 58					; 0000003aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDDreg$reg@$00$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDDreg$reg<1,3>

; 78   : 	instructions[0x3B] = &Cpu::DEC_16bit<RegSP>;

	mov	edx, 4
	imul	edx, 59					; 0000003bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$DEC_16bit@$03@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::DEC_16bit<4>

; 79   : 	instructions[0x3C] = &Cpu::INC_8bit<RegA,0>;

	mov	ecx, 4
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$INC_8bit@$00$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::INC_8bit<1,0>

; 80   : 	instructions[0x3D] = &Cpu::DEC_8bit<RegA,0>;

	mov	eax, 4
	imul	eax, 61					; 0000003dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$DEC_8bit@$00$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::DEC_8bit<1,0>

; 81   : 	instructions[0x3E] = &Cpu::LD<RegA,0,10>;

	mov	edx, 4
	imul	edx, 62					; 0000003eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LD@$00$0A@$09@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD<1,0,10>

; 82   :   instructions[0x3F] = &Cpu::CCF;

	mov	ecx, 4
	imul	ecx, 63					; 0000003fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?CCF@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CCF

; 83   : 
; 84   : 	instructions[0x40] = &Cpu::LDrr<RegB,RegB>;

	mov	eax, 4
	shl	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$02$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<3,3>

; 85   : 	instructions[0x41] = &Cpu::LDrr<RegB,RegC>;

	mov	edx, 4
	imul	edx, 65					; 00000041H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$02$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<3,2>

; 86   : 	instructions[0x42] = &Cpu::LDrr<RegB,RegD>;

	mov	ecx, 4
	imul	ecx, 66					; 00000042H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$02$04@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<3,5>

; 87   : 	instructions[0x43] = &Cpu::LDrr<RegB,RegE>;

	mov	eax, 4
	imul	eax, 67					; 00000043H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$02$03@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<3,4>

; 88   : 	instructions[0x44] = &Cpu::LDrr<RegB,RegH>;

	mov	edx, 4
	imul	edx, 68					; 00000044H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$02$06@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<3,7>

; 89   : 	instructions[0x45] = &Cpu::LDrr<RegB,RegL>;

	mov	ecx, 4
	imul	ecx, 69					; 00000045H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$02$05@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<3,6>

; 90   : 	instructions[0x46] = &Cpu::LDr$r<RegB,RegHL>;

	mov	eax, 4
	imul	eax, 70					; 00000046H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDr$r@$02$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDr$r<3,3>

; 91   : 	instructions[0x47] = &Cpu::LDrr<RegB,RegA>;

	mov	edx, 4
	imul	edx, 71					; 00000047H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$02$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<3,1>

; 92   : 	instructions[0x48] = &Cpu::LDrr<RegC,RegB>;

	mov	ecx, 4
	imul	ecx, 72					; 00000048H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$01$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<2,3>

; 93   : 	instructions[0x49] = &Cpu::LDrr<RegC,RegC>;

	mov	eax, 4
	imul	eax, 73					; 00000049H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$01$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<2,2>

; 94   : 	instructions[0x4A] = &Cpu::LDrr<RegC,RegD>;

	mov	edx, 4
	imul	edx, 74					; 0000004aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$01$04@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<2,5>

; 95   : 	instructions[0x4B] = &Cpu::LDrr<RegC,RegE>;

	mov	ecx, 4
	imul	ecx, 75					; 0000004bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$01$03@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<2,4>

; 96   : 	instructions[0x4C] = &Cpu::LDrr<RegC,RegH>;

	mov	eax, 4
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$01$06@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<2,7>

; 97   : 	instructions[0x4D] = &Cpu::LDrr<RegC,RegL>;

	mov	edx, 4
	imul	edx, 77					; 0000004dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$01$05@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<2,6>

; 98   : 	instructions[0x4E] = &Cpu::LDr$r<RegC,RegHL>;

	mov	ecx, 4
	imul	ecx, 78					; 0000004eH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDr$r@$01$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDr$r<2,3>

; 99   : 	instructions[0x4F] = &Cpu::LDrr<RegC,RegA>;

	mov	eax, 4
	imul	eax, 79					; 0000004fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$01$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<2,1>

; 100  : 
; 101  : 	instructions[0x50] = &Cpu::LDrr<RegD,RegB>;

	mov	edx, 4
	imul	edx, 80					; 00000050H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$04$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<5,3>

; 102  : 	instructions[0x51] = &Cpu::LDrr<RegD,RegC>;

	mov	ecx, 4
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$04$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<5,2>

; 103  : 	instructions[0x52] = &Cpu::LDrr<RegD,RegD>;

	mov	eax, 4
	imul	eax, 82					; 00000052H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$04$04@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<5,5>

; 104  : 	instructions[0x53] = &Cpu::LDrr<RegD,RegE>;

	mov	edx, 4
	imul	edx, 83					; 00000053H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$04$03@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<5,4>

; 105  : 	instructions[0x54] = &Cpu::LDrr<RegD,RegH>;

	mov	ecx, 4
	imul	ecx, 84					; 00000054H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$04$06@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<5,7>

; 106  : 	instructions[0x55] = &Cpu::LDrr<RegD,RegL>;

	mov	eax, 4
	imul	eax, 85					; 00000055H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$04$05@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<5,6>

; 107  : 	instructions[0x56] = &Cpu::LDr$r<RegD,RegHL>;

	mov	edx, 4
	imul	edx, 86					; 00000056H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDr$r@$04$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDr$r<5,3>

; 108  : 	instructions[0x57] = &Cpu::LDrr<RegD,RegA>;

	mov	ecx, 4
	imul	ecx, 87					; 00000057H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$04$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<5,1>

; 109  : 	instructions[0x58] = &Cpu::LDrr<RegE,RegB>;

	mov	eax, 4
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$03$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<4,3>

; 110  : 	instructions[0x59] = &Cpu::LDrr<RegE,RegC>;

	mov	edx, 4
	imul	edx, 89					; 00000059H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$03$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<4,2>

; 111  : 	instructions[0x5A] = &Cpu::LDrr<RegE,RegD>;

	mov	ecx, 4
	imul	ecx, 90					; 0000005aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$03$04@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<4,5>

; 112  : 	instructions[0x5B] = &Cpu::LDrr<RegE,RegE>;

	mov	eax, 4
	imul	eax, 91					; 0000005bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$03$03@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<4,4>

; 113  : 	instructions[0x5C] = &Cpu::LDrr<RegE,RegH>;

	mov	edx, 4
	imul	edx, 92					; 0000005cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$03$06@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<4,7>

; 114  : 	instructions[0x5D] = &Cpu::LDrr<RegE,RegL>;

	mov	ecx, 4
	imul	ecx, 93					; 0000005dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$03$05@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<4,6>

; 115  : 	instructions[0x5E] = &Cpu::LDr$r<RegE,RegHL>;

	mov	eax, 4
	imul	eax, 94					; 0000005eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDr$r@$03$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDr$r<4,3>

; 116  : 	instructions[0x5F] = &Cpu::LDrr<RegE,RegA>;

	mov	edx, 4
	imul	edx, 95					; 0000005fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$03$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<4,1>

; 117  : 
; 118  : 	instructions[0x60] = &Cpu::LDrr<RegH,RegB>;

	mov	ecx, 4
	imul	ecx, 96					; 00000060H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$06$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<7,3>

; 119  : 	instructions[0x61] = &Cpu::LDrr<RegH,RegC>;

	mov	eax, 4
	imul	eax, 97					; 00000061H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$06$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<7,2>

; 120  : 	instructions[0x62] = &Cpu::LDrr<RegH,RegD>;

	mov	edx, 4
	imul	edx, 98					; 00000062H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$06$04@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<7,5>

; 121  : 	instructions[0x63] = &Cpu::LDrr<RegH,RegE>;

	mov	ecx, 4
	imul	ecx, 99					; 00000063H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$06$03@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<7,4>

; 122  : 	instructions[0x64] = &Cpu::LDrr<RegH,RegH>;

	mov	eax, 4
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$06$06@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<7,7>

; 123  : 	instructions[0x65] = &Cpu::LDrr<RegH,RegL>;

	mov	edx, 4
	imul	edx, 101				; 00000065H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$06$05@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<7,6>

; 124  : 	instructions[0x66] = &Cpu::LDr$r<RegH,RegHL>;

	mov	ecx, 4
	imul	ecx, 102				; 00000066H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDr$r@$06$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDr$r<7,3>

; 125  : 	instructions[0x67] = &Cpu::LDrr<RegH,RegA>;

	mov	eax, 4
	imul	eax, 103				; 00000067H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$06$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<7,1>

; 126  : 	instructions[0x68] = &Cpu::LDrr<RegL,RegB>;

	mov	edx, 4
	imul	edx, 104				; 00000068H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$05$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<6,3>

; 127  : 	instructions[0x69] = &Cpu::LDrr<RegL,RegC>;

	mov	ecx, 4
	imul	ecx, 105				; 00000069H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$05$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<6,2>

; 128  : 	instructions[0x6A] = &Cpu::LDrr<RegL,RegD>;

	mov	eax, 4
	imul	eax, 106				; 0000006aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$05$04@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<6,5>

; 129  : 	instructions[0x6B] = &Cpu::LDrr<RegL,RegE>;

	mov	edx, 4
	imul	edx, 107				; 0000006bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$05$03@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<6,4>

; 130  : 	instructions[0x6C] = &Cpu::LDrr<RegL,RegH>;

	mov	ecx, 4
	imul	ecx, 108				; 0000006cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$05$06@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<6,7>

; 131  : 	instructions[0x6D] = &Cpu::LDrr<RegL,RegL>;

	mov	eax, 4
	imul	eax, 109				; 0000006dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$05$05@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<6,6>

; 132  : 	instructions[0x6E] = &Cpu::LDr$r<RegL,RegHL>;

	mov	edx, 4
	imul	edx, 110				; 0000006eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDr$r@$05$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDr$r<6,3>

; 133  : 	instructions[0x6F] = &Cpu::LDrr<RegL,RegA>;

	mov	ecx, 4
	imul	ecx, 111				; 0000006fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$05$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<6,1>

; 134  : 
; 135  : 	instructions[0x70] = &Cpu::LD$rr<RegHL,RegB>;

	mov	eax, 4
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LD$rr@$02$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD$rr<3,3>

; 136  : 	instructions[0x71] = &Cpu::LD$rr<RegHL,RegC>;

	mov	edx, 4
	imul	edx, 113				; 00000071H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LD$rr@$02$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD$rr<3,2>

; 137  : 	instructions[0x72] = &Cpu::LD$rr<RegHL,RegD>;

	mov	ecx, 4
	imul	ecx, 114				; 00000072H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LD$rr@$02$04@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD$rr<3,5>

; 138  : 	instructions[0x73] = &Cpu::LD$rr<RegHL,RegE>;

	mov	eax, 4
	imul	eax, 115				; 00000073H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LD$rr@$02$03@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD$rr<3,4>

; 139  : 	instructions[0x74] = &Cpu::LD$rr<RegHL,RegH>;

	mov	edx, 4
	imul	edx, 116				; 00000074H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LD$rr@$02$06@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD$rr<3,7>

; 140  : 	instructions[0x75] = &Cpu::LD$rr<RegHL,RegL>;

	mov	ecx, 4
	imul	ecx, 117				; 00000075H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LD$rr@$02$05@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD$rr<3,6>

; 141  : 	instructions[0x76] = &Cpu::HALT;

	mov	eax, 4
	imul	eax, 118				; 00000076H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?HALT@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::HALT

; 142  : 	instructions[0x77] = &Cpu::LD$rr<RegHL,RegA>;

	mov	edx, 4
	imul	edx, 119				; 00000077H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LD$rr@$02$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD$rr<3,1>

; 143  : 	instructions[0x78] = &Cpu::LDrr<RegA,RegB>;

	mov	ecx, 4
	imul	ecx, 120				; 00000078H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$00$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<1,3>

; 144  : 	instructions[0x79] = &Cpu::LDrr<RegA,RegC>;

	mov	eax, 4
	imul	eax, 121				; 00000079H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$00$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<1,2>

; 145  : 	instructions[0x7A] = &Cpu::LDrr<RegA,RegD>;

	mov	edx, 4
	imul	edx, 122				; 0000007aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$00$04@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<1,5>

; 146  : 	instructions[0x7B] = &Cpu::LDrr<RegA,RegE>;

	mov	ecx, 4
	imul	ecx, 123				; 0000007bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDrr@$00$03@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<1,4>

; 147  : 	instructions[0x7C] = &Cpu::LDrr<RegA,RegH>;

	mov	eax, 4
	imul	eax, 124				; 0000007cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$00$06@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<1,7>

; 148  : 	instructions[0x7D] = &Cpu::LDrr<RegA,RegL>;

	mov	edx, 4
	imul	edx, 125				; 0000007dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDrr@$00$05@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<1,6>

; 149  : 	instructions[0x7E] = &Cpu::LDr$r<RegA,RegHL>;

	mov	ecx, 4
	imul	ecx, 126				; 0000007eH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LDr$r@$00$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDr$r<1,3>

; 150  : 	instructions[0x7F] = &Cpu::LDrr<RegA,RegA>;

	mov	eax, 4
	imul	eax, 127				; 0000007fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LDrr@$00$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDrr<1,1>

; 151  : 
; 152  : 	instructions[0x80] = &Cpu::ADD<RegA,RegB,0>;

	mov	edx, 4
	shl	edx, 7
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$ADD@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADD<1,3,0>

; 153  : 	instructions[0x81] = &Cpu::ADD<RegA,RegC,0>;

	mov	ecx, 4
	imul	ecx, 129				; 00000081H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$ADD@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADD<1,2,0>

; 154  : 	instructions[0x82] = &Cpu::ADD<RegA,RegD,0>;

	mov	eax, 4
	imul	eax, 130				; 00000082H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$ADD@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADD<1,5,0>

; 155  : 	instructions[0x83] = &Cpu::ADD<RegA,RegE,0>;

	mov	edx, 4
	imul	edx, 131				; 00000083H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$ADD@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADD<1,4,0>

; 156  : 	instructions[0x84] = &Cpu::ADD<RegA,RegH,0>;

	mov	ecx, 4
	imul	ecx, 132				; 00000084H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$ADD@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADD<1,7,0>

; 157  : 	instructions[0x85] = &Cpu::ADD<RegA,RegL,0>;

	mov	eax, 4
	imul	eax, 133				; 00000085H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$ADD@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADD<1,6,0>

; 158  : 	instructions[0x86] = &Cpu::ADD<RegA,RegHL,1>;

	mov	edx, 4
	imul	edx, 134				; 00000086H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$ADD@$00$02$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADD<1,3,1>

; 159  : 	instructions[0x87] = &Cpu::ADD<RegA,RegA,0>;

	mov	ecx, 4
	imul	ecx, 135				; 00000087H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$ADD@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADD<1,1,0>

; 160  : 	instructions[0x88] = &Cpu::ADC<RegA,RegB,0>;

	mov	eax, 4
	imul	eax, 136				; 00000088H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$ADC@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADC<1,3,0>

; 161  : 	instructions[0x89] = &Cpu::ADC<RegA,RegC,0>;

	mov	edx, 4
	imul	edx, 137				; 00000089H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$ADC@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADC<1,2,0>

; 162  : 	instructions[0x8A] = &Cpu::ADC<RegA,RegD,0>;

	mov	ecx, 4
	imul	ecx, 138				; 0000008aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$ADC@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADC<1,5,0>

; 163  : 	instructions[0x8B] = &Cpu::ADC<RegA,RegE,0>;

	mov	eax, 4
	imul	eax, 139				; 0000008bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$ADC@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADC<1,4,0>

; 164  : 	instructions[0x8C] = &Cpu::ADC<RegA,RegH,0>;

	mov	edx, 4
	imul	edx, 140				; 0000008cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$ADC@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADC<1,7,0>

; 165  : 	instructions[0x8D] = &Cpu::ADC<RegA,RegL,0>;

	mov	ecx, 4
	imul	ecx, 141				; 0000008dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$ADC@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADC<1,6,0>

; 166  : 	instructions[0x8E] = &Cpu::ADC<RegA,RegHL,1>;

	mov	eax, 4
	imul	eax, 142				; 0000008eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$ADC@$00$02$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADC<1,3,1>

; 167  : 	instructions[0x8F] = &Cpu::ADC<RegA,RegA,0>;

	mov	edx, 4
	imul	edx, 143				; 0000008fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$ADC@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADC<1,1,0>

; 168  : 
; 169  : 	instructions[0x90] = &Cpu::SUB<RegA,RegB,0>;

	mov	ecx, 4
	imul	ecx, 144				; 00000090H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$SUB@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SUB<1,3,0>

; 170  : 	instructions[0x91] = &Cpu::SUB<RegA,RegC,0>;

	mov	eax, 4
	imul	eax, 145				; 00000091H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$SUB@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SUB<1,2,0>

; 171  : 	instructions[0x92] = &Cpu::SUB<RegA,RegD,0>;

	mov	edx, 4
	imul	edx, 146				; 00000092H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$SUB@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SUB<1,5,0>

; 172  : 	instructions[0x93] = &Cpu::SUB<RegA,RegE,0>;

	mov	ecx, 4
	imul	ecx, 147				; 00000093H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$SUB@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SUB<1,4,0>

; 173  : 	instructions[0x94] = &Cpu::SUB<RegA,RegH,0>;

	mov	eax, 4
	imul	eax, 148				; 00000094H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$SUB@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SUB<1,7,0>

; 174  : 	instructions[0x95] = &Cpu::SUB<RegA,RegL,0>;

	mov	edx, 4
	imul	edx, 149				; 00000095H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$SUB@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SUB<1,6,0>

; 175  : 	instructions[0x96] = &Cpu::SUB<RegA,RegHL,1>;

	mov	ecx, 4
	imul	ecx, 150				; 00000096H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$SUB@$00$02$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SUB<1,3,1>

; 176  : 	instructions[0x97] = &Cpu::SUB<RegA,RegA,0>;

	mov	eax, 4
	imul	eax, 151				; 00000097H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$SUB@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SUB<1,1,0>

; 177  : 	instructions[0x98] = &Cpu::SBC<RegA,RegB,0>;

	mov	edx, 4
	imul	edx, 152				; 00000098H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$SBC@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SBC<1,3,0>

; 178  : 	instructions[0x99] = &Cpu::SBC<RegA,RegC,0>;

	mov	ecx, 4
	imul	ecx, 153				; 00000099H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$SBC@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SBC<1,2,0>

; 179  : 	instructions[0x9A] = &Cpu::SBC<RegA,RegD,0>;

	mov	eax, 4
	imul	eax, 154				; 0000009aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$SBC@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SBC<1,5,0>

; 180  : 	instructions[0x9B] = &Cpu::SBC<RegA,RegE,0>;

	mov	edx, 4
	imul	edx, 155				; 0000009bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$SBC@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SBC<1,4,0>

; 181  : 	instructions[0x9C] = &Cpu::SBC<RegA,RegH,0>;

	mov	ecx, 4
	imul	ecx, 156				; 0000009cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$SBC@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SBC<1,7,0>

; 182  : 	instructions[0x9D] = &Cpu::SBC<RegA,RegL,0>;

	mov	eax, 4
	imul	eax, 157				; 0000009dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$SBC@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SBC<1,6,0>

; 183  : 	instructions[0x9E] = &Cpu::SBC<RegA,RegHL,1>;

	mov	edx, 4
	imul	edx, 158				; 0000009eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$SBC@$00$02$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SBC<1,3,1>

; 184  : 	instructions[0x9F] = &Cpu::SBC<RegA,RegA,0>;

	mov	ecx, 4
	imul	ecx, 159				; 0000009fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$SBC@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SBC<1,1,0>

; 185  : 
; 186  : 	instructions[0xA0] = &Cpu::AND<RegA,RegB,0>;

	mov	eax, 4
	imul	eax, 160				; 000000a0H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$AND@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::AND<1,3,0>

; 187  : 	instructions[0xA1] = &Cpu::AND<RegA,RegC,0>;

	mov	edx, 4
	imul	edx, 161				; 000000a1H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$AND@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::AND<1,2,0>

; 188  : 	instructions[0xA2] = &Cpu::AND<RegA,RegD,0>;

	mov	ecx, 4
	imul	ecx, 162				; 000000a2H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$AND@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::AND<1,5,0>

; 189  : 	instructions[0xA3] = &Cpu::AND<RegA,RegE,0>;

	mov	eax, 4
	imul	eax, 163				; 000000a3H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$AND@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::AND<1,4,0>

; 190  : 	instructions[0xA4] = &Cpu::AND<RegA,RegH,0>;

	mov	edx, 4
	imul	edx, 164				; 000000a4H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$AND@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::AND<1,7,0>

; 191  : 	instructions[0xA5] = &Cpu::AND<RegA,RegL,0>;

	mov	ecx, 4
	imul	ecx, 165				; 000000a5H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$AND@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::AND<1,6,0>

; 192  : 	instructions[0xA6] = &Cpu::AND<RegA,RegHL,1>;

	mov	eax, 4
	imul	eax, 166				; 000000a6H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$AND@$00$02$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::AND<1,3,1>

; 193  : 	instructions[0xA7] = &Cpu::AND<RegA,RegA,0>;

	mov	edx, 4
	imul	edx, 167				; 000000a7H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$AND@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::AND<1,1,0>

; 194  : 	instructions[0xA8] = &Cpu::XOR<RegA,RegB,0>;

	mov	ecx, 4
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$XOR@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::XOR<1,3,0>

; 195  : 	instructions[0xA9] = &Cpu::XOR<RegA,RegC,0>;

	mov	eax, 4
	imul	eax, 169				; 000000a9H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$XOR@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::XOR<1,2,0>

; 196  : 	instructions[0xAA] = &Cpu::XOR<RegA,RegD,0>;

	mov	edx, 4
	imul	edx, 170				; 000000aaH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$XOR@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::XOR<1,5,0>

; 197  : 	instructions[0xAB] = &Cpu::XOR<RegA,RegE,0>;

	mov	ecx, 4
	imul	ecx, 171				; 000000abH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$XOR@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::XOR<1,4,0>

; 198  : 	instructions[0xAC] = &Cpu::XOR<RegA,RegH,0>;

	mov	eax, 4
	imul	eax, 172				; 000000acH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$XOR@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::XOR<1,7,0>

; 199  : 	instructions[0xAD] = &Cpu::XOR<RegA,RegL,0>;

	mov	edx, 4
	imul	edx, 173				; 000000adH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$XOR@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::XOR<1,6,0>

; 200  : 	instructions[0xAE] = &Cpu::XOR<RegA,RegHL,1>;

	mov	ecx, 4
	imul	ecx, 174				; 000000aeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$XOR@$00$02$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::XOR<1,3,1>

; 201  : 	instructions[0xAF] = &Cpu::XOR<RegA,RegA,0>;

	mov	eax, 4
	imul	eax, 175				; 000000afH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$XOR@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::XOR<1,1,0>

; 202  : 
; 203  : 	instructions[0xB0] = &Cpu::OR<RegA,RegB,0>;

	mov	edx, 4
	imul	edx, 176				; 000000b0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$OR@$00$02$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::OR<1,3,0>

; 204  : 	instructions[0xB1] = &Cpu::OR<RegA,RegC,0>;

	mov	ecx, 4
	imul	ecx, 177				; 000000b1H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$OR@$00$01$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::OR<1,2,0>

; 205  : 	instructions[0xB2] = &Cpu::OR<RegA,RegD,0>;

	mov	eax, 4
	imul	eax, 178				; 000000b2H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$OR@$00$04$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::OR<1,5,0>

; 206  : 	instructions[0xB3] = &Cpu::OR<RegA,RegE,0>;

	mov	edx, 4
	imul	edx, 179				; 000000b3H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$OR@$00$03$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::OR<1,4,0>

; 207  : 	instructions[0xB4] = &Cpu::OR<RegA,RegH,0>;

	mov	ecx, 4
	imul	ecx, 180				; 000000b4H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$OR@$00$06$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::OR<1,7,0>

; 208  : 	instructions[0xB5] = &Cpu::OR<RegA,RegL,0>;

	mov	eax, 4
	imul	eax, 181				; 000000b5H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$OR@$00$05$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::OR<1,6,0>

; 209  : 	instructions[0xB6] = &Cpu::OR<RegA,RegHL,1>;

	mov	edx, 4
	imul	edx, 182				; 000000b6H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$OR@$00$02$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::OR<1,3,1>

; 210  : 	instructions[0xB7] = &Cpu::OR<RegA,RegA,0>;

	mov	ecx, 4
	imul	ecx, 183				; 000000b7H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$OR@$00$00$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::OR<1,1,0>

; 211  :   instructions[0xB8] = &Cpu::CP_reg<RegB>;

	mov	eax, 4
	imul	eax, 184				; 000000b8H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$CP_reg@$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CP_reg<3>

; 212  :   instructions[0xB9] = &Cpu::CP_reg<RegC>;

	mov	edx, 4
	imul	edx, 185				; 000000b9H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$CP_reg@$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CP_reg<2>

; 213  :   instructions[0xBA] = &Cpu::CP_reg<RegD>;

	mov	ecx, 4
	imul	ecx, 186				; 000000baH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$CP_reg@$04@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CP_reg<5>

; 214  :   instructions[0xBB] = &Cpu::CP_reg<RegE>;

	mov	eax, 4
	imul	eax, 187				; 000000bbH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$CP_reg@$03@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CP_reg<4>

; 215  :   instructions[0xBC] = &Cpu::CP_reg<RegH>;

	mov	edx, 4
	imul	edx, 188				; 000000bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$CP_reg@$06@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CP_reg<7>

; 216  :   instructions[0xBD] = &Cpu::CP_reg<RegL>;

	mov	ecx, 4
	imul	ecx, 189				; 000000bdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$CP_reg@$05@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CP_reg<6>

; 217  :   instructions[0xBE] = &Cpu::CP_HL;

	mov	eax, 4
	imul	eax, 190				; 000000beH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?CP_HL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CP_HL

; 218  :   instructions[0xBF] = &Cpu::CP_reg<RegA>;

	mov	edx, 4
	imul	edx, 191				; 000000bfH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$CP_reg@$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CP_reg<1>

; 219  : 	
; 220  : 	instructions[0xC0] = &Cpu::RET_cc<CpuFlagsZ,1>;

	mov	ecx, 4
	imul	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$RET_cc@$06$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RET_cc<7,1>

; 221  : 	instructions[0xC1] = &Cpu::POP<RegBC>;

	mov	eax, 4
	imul	eax, 193				; 000000c1H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$POP@$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::POP<1>

; 222  : 	instructions[0xC2] = &Cpu::JP_cc<CpuFlagsZ,1>;

	mov	edx, 4
	imul	edx, 194				; 000000c2H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$JP_cc@$06$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::JP_cc<7,1>

; 223  : 	instructions[0xC3] = &Cpu::JP;

	mov	ecx, 4
	imul	ecx, 195				; 000000c3H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?JP@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::JP

; 224  : 	instructions[0xC4] = &Cpu::CALL_cc<CpuFlagsZ,1>;

	mov	eax, 4
	imul	eax, 196				; 000000c4H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$CALL_cc@$06$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CALL_cc<7,1>

; 225  : 	instructions[0xC5] = &Cpu::PUSH<RegBC>;

	mov	edx, 4
	imul	edx, 197				; 000000c5H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$PUSH@$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::PUSH<1>

; 226  :   instructions[0xC6] = &Cpu::ADD<RegA,0,2>;

	mov	ecx, 4
	imul	ecx, 198				; 000000c6H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$ADD@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADD<1,0,2>

; 227  : 	instructions[0xC7] = &Cpu::RST;

	mov	eax, 4
	imul	eax, 199				; 000000c7H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?RST@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RST

; 228  : 	instructions[0xC8] = &Cpu::RET_cc<CpuFlagsZ,0>;

	mov	edx, 4
	imul	edx, 200				; 000000c8H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$RET_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RET_cc<7,0>

; 229  : 	instructions[0xC9] = &Cpu::RET;

	mov	ecx, 4
	imul	ecx, 201				; 000000c9H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?RET@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RET

; 230  : 	instructions[0xCA] = &Cpu::JP_cc<CpuFlagsZ,0>;

	mov	eax, 4
	imul	eax, 202				; 000000caH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$JP_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::JP_cc<7,0>

; 231  : 	instructions[0xCB] = &Cpu::PREFIX_CB;

	mov	edx, 4
	imul	edx, 203				; 000000cbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ?PREFIX_CB@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::PREFIX_CB

; 232  : 	instructions[0xCC] = &Cpu::CALL_cc<CpuFlagsZ,0>;

	mov	ecx, 4
	imul	ecx, 204				; 000000ccH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$CALL_cc@$06$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CALL_cc<7,0>

; 233  : 	instructions[0xCD] = &Cpu::CALL;

	mov	eax, 4
	imul	eax, 205				; 000000cdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?CALL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CALL

; 234  : 	instructions[0xCE] = &Cpu::ADC<RegA,0,2>;

	mov	edx, 4
	imul	edx, 206				; 000000ceH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$ADC@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADC<1,0,2>

; 235  : 	instructions[0xCF] = &Cpu::RST;

	mov	ecx, 4
	imul	ecx, 207				; 000000cfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?RST@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RST

; 236  : 
; 237  : 	instructions[0xD0] = &Cpu::RET_cc<CpuFlagsC,1>;

	mov	eax, 4
	imul	eax, 208				; 000000d0H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$RET_cc@$03$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RET_cc<4,1>

; 238  : 	instructions[0xD1] = &Cpu::POP<RegDE>;

	mov	edx, 4
	imul	edx, 209				; 000000d1H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$POP@$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::POP<2>

; 239  : 	instructions[0xD2] = &Cpu::JP_cc<CpuFlagsC,1>;

	mov	ecx, 4
	imul	ecx, 210				; 000000d2H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$JP_cc@$03$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::JP_cc<4,1>

; 240  : 	instructions[0xD3] = &Cpu::ILLEGAL;

	mov	eax, 4
	imul	eax, 211				; 000000d3H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?ILLEGAL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ILLEGAL

; 241  : 	instructions[0xD4] = &Cpu::CALL_cc<CpuFlagsC,1>;

	mov	edx, 4
	imul	edx, 212				; 000000d4H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$CALL_cc@$03$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CALL_cc<4,1>

; 242  : 	instructions[0xD5] = &Cpu::PUSH<RegDE>;

	mov	ecx, 4
	imul	ecx, 213				; 000000d5H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$PUSH@$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::PUSH<2>

; 243  :   instructions[0xD6] = &Cpu::SUB<RegA,0,2>;

	mov	eax, 4
	imul	eax, 214				; 000000d6H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$SUB@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SUB<1,0,2>

; 244  : 	instructions[0xD7] = &Cpu::RST;

	mov	edx, 4
	imul	edx, 215				; 000000d7H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ?RST@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RST

; 245  : 	instructions[0xD8] = &Cpu::RET_cc<CpuFlagsC,0>;

	mov	ecx, 4
	imul	ecx, 216				; 000000d8H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$RET_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RET_cc<4,0>

; 246  : 	instructions[0xD9] = &Cpu::RETI;

	mov	eax, 4
	imul	eax, 217				; 000000d9H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?RETI@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RETI

; 247  : 	instructions[0xDA] = &Cpu::JP_cc<CpuFlagsC,0>;

	mov	edx, 4
	imul	edx, 218				; 000000daH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$JP_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::JP_cc<4,0>

; 248  : 	instructions[0xDB] = &Cpu::ILLEGAL;

	mov	ecx, 4
	imul	ecx, 219				; 000000dbH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?ILLEGAL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ILLEGAL

; 249  : 	instructions[0xDC] = &Cpu::CALL_cc<CpuFlagsC,0>;

	mov	eax, 4
	imul	eax, 220				; 000000dcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$CALL_cc@$03$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CALL_cc<4,0>

; 250  : 	instructions[0xDD] = &Cpu::ILLEGAL;

	mov	edx, 4
	imul	edx, 221				; 000000ddH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ?ILLEGAL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ILLEGAL

; 251  : 	instructions[0xDE] = &Cpu::SBC<RegA,0,2>;

	mov	ecx, 4
	imul	ecx, 222				; 000000deH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$SBC@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::SBC<1,0,2>

; 252  : 	instructions[0xDF] = &Cpu::RST;

	mov	eax, 4
	imul	eax, 223				; 000000dfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?RST@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RST

; 253  : 	
; 254  : 	instructions[0xE0] = &Cpu::LD<0,RegA,12>;

	mov	edx, 4
	imul	edx, 224				; 000000e0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LD@$0A@$00$0M@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD<0,1,12>

; 255  : 	instructions[0xE1] = &Cpu::POP<RegHL>;

	mov	ecx, 4
	imul	ecx, 225				; 000000e1H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$POP@$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::POP<3>

; 256  : 	instructions[0xE2] = &Cpu::LD$FF00rr<RegC,RegA>;

	mov	eax, 4
	imul	eax, 226				; 000000e2H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LD$FF00rr@$01$00@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD$FF00rr<2,1>

; 257  : 	instructions[0xE3] = &Cpu::ILLEGAL;

	mov	edx, 4
	imul	edx, 227				; 000000e3H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ?ILLEGAL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ILLEGAL

; 258  : 	instructions[0xE4] = &Cpu::ILLEGAL;

	mov	ecx, 4
	imul	ecx, 228				; 000000e4H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?ILLEGAL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ILLEGAL

; 259  : 	instructions[0xE5] = &Cpu::PUSH<RegHL>;

	mov	eax, 4
	imul	eax, 229				; 000000e5H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$PUSH@$02@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::PUSH<3>

; 260  :   instructions[0xE6] = &Cpu::AND<RegA,0,2>;

	mov	edx, 4
	imul	edx, 230				; 000000e6H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$AND@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::AND<1,0,2>

; 261  : 	instructions[0xE7] = &Cpu::RST;

	mov	ecx, 4
	imul	ecx, 231				; 000000e7H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?RST@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RST

; 262  : 	instructions[0xE8] = &Cpu::ADD_SPr8;

	mov	eax, 4
	imul	eax, 232				; 000000e8H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?ADD_SPr8@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ADD_SPr8

; 263  : 	instructions[0xE9] = &Cpu::JP_HL;

	mov	edx, 4
	imul	edx, 233				; 000000e9H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ?JP_HL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::JP_HL

; 264  : 	instructions[0xEA] = &Cpu::LD<0,RegA,14>;

	mov	ecx, 4
	imul	ecx, 234				; 000000eaH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LD@$0A@$00$0O@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD<0,1,14>

; 265  : 	instructions[0xEB] = &Cpu::ILLEGAL;

	mov	eax, 4
	imul	eax, 235				; 000000ebH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?ILLEGAL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ILLEGAL

; 266  : 	instructions[0xEC] = &Cpu::ILLEGAL;

	mov	edx, 4
	imul	edx, 236				; 000000ecH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ?ILLEGAL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ILLEGAL

; 267  : 	instructions[0xED] = &Cpu::ILLEGAL;

	mov	ecx, 4
	imul	ecx, 237				; 000000edH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?ILLEGAL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ILLEGAL

; 268  : 	instructions[0xEE] = &Cpu::XOR<RegA,0,2>;

	mov	eax, 4
	imul	eax, 238				; 000000eeH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$XOR@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::XOR<1,0,2>

; 269  : 	instructions[0xEF] = &Cpu::RST;

	mov	edx, 4
	imul	edx, 239				; 000000efH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ?RST@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RST

; 270  : 
; 271  : 	instructions[0xF0] = &Cpu::LD<RegA,0,13>;

	mov	ecx, 4
	imul	ecx, 240				; 000000f0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$LD@$00$0A@$0N@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD<1,0,13>

; 272  : 	instructions[0xF1] = &Cpu::POP<RegAF>;

	mov	eax, 4
	imul	eax, 241				; 000000f1H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$POP@$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::POP<0>

; 273  : 	instructions[0xF2] = &Cpu::LDr$FF00r<RegA,RegC>;

	mov	edx, 4
	imul	edx, 242				; 000000f2H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$LDr$FF00r@$00$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDr$FF00r<1,2>

; 274  : 	instructions[0xF3] = &Cpu::DI;

	mov	ecx, 4
	imul	ecx, 243				; 000000f3H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?DI@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::DI

; 275  : 	instructions[0xF4] = &Cpu::ILLEGAL;

	mov	eax, 4
	imul	eax, 244				; 000000f4H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?ILLEGAL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ILLEGAL

; 276  : 	instructions[0xF5] = &Cpu::PUSH<RegAF>;

	mov	edx, 4
	imul	edx, 245				; 000000f5H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ??$PUSH@$0A@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::PUSH<0>

; 277  :   instructions[0xF6] = &Cpu::OR<RegA,0,2>;

	mov	ecx, 4
	imul	ecx, 246				; 000000f6H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ??$OR@$00$0A@$01@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::OR<1,0,2>

; 278  : 	instructions[0xF7] = &Cpu::RST;

	mov	eax, 4
	imul	eax, 247				; 000000f7H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?RST@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RST

; 279  : 	instructions[0xF8] = &Cpu::LDHLSPr8;

	mov	edx, 4
	imul	edx, 248				; 000000f8H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ?LDHLSPr8@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDHLSPr8

; 280  : 	instructions[0xF9] = &Cpu::LDSPHL;

	mov	ecx, 4
	imul	ecx, 249				; 000000f9H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?LDSPHL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LDSPHL

; 281  : 	instructions[0xFA] = &Cpu::LD<RegA,0,15>;

	mov	eax, 4
	imul	eax, 250				; 000000faH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ??$LD@$00$0A@$0P@@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::LD<1,0,15>

; 282  : 	instructions[0xFB] = &Cpu::EI;

	mov	edx, 4
	imul	edx, 251				; 000000fbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ?EI@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::EI

; 283  : 	instructions[0xFC] = &Cpu::ILLEGAL;

	mov	ecx, 4
	imul	ecx, 252				; 000000fcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?ILLEGAL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ILLEGAL

; 284  : 	instructions[0xFD] = &Cpu::ILLEGAL;

	mov	eax, 4
	imul	eax, 253				; 000000fdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+40], OFFSET ?ILLEGAL@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::ILLEGAL

; 285  : 	instructions[0xFE] = &Cpu::CP_d8;

	mov	edx, 4
	imul	edx, 254				; 000000feH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+40], OFFSET ?CP_d8@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::CP_d8

; 286  :   instructions[0xFF] = &Cpu::RST;

	mov	ecx, 4
	imul	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+40], OFFSET ?RST@Cpu@gb@emulation@@AAEXXZ ; emulation::gb::Cpu::RST

; 287  : 	//-checked above
; 288  : }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0Cpu@gb@emulation@@QAE@XZ ENDP			; emulation::gb::Cpu::Cpu
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\lcd_driver.h
;	COMDAT ?lcdc@LCDDriver@gb@emulation@@QAEABTLCDControlRegister@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?lcdc@LCDDriver@gb@emulation@@QAEABTLCDControlRegister@23@XZ PROC ; emulation::gb::LCDDriver::lcdc, COMDAT
; _this$ = ecx

; 52   : 	const LCDControlRegister& lcdc() { return lcdc_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	esp, ebp
	pop	ebp
	ret	0
?lcdc@LCDDriver@gb@emulation@@QAEABTLCDControlRegister@23@XZ ENDP ; emulation::gb::LCDDriver::lcdc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ PROC	; emulation::gb::Memory::interrupt_flag, COMDAT
; _this$ = ecx

; 21   :   uint8_t& interrupt_flag() {  return ioports_[0x0F]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	imul	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax+184]
	mov	esp, ebp
	pop	ebp
	ret	0
?interrupt_flag@Memory@gb@emulation@@QAEAAEXZ ENDP	; emulation::gb::Memory::interrupt_flag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\memory.h
;	COMDAT ?interrupt_enable@Memory@gb@emulation@@QAEAAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?interrupt_enable@Memory@gb@emulation@@QAEAAEXZ PROC	; emulation::gb::Memory::interrupt_enable, COMDAT
; _this$ = ecx

; 20   :   uint8_t& interrupt_enable() { return interrupt_enable_register_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 439				; 000001b7H
	mov	esp, ebp
	pop	ebp
	ret	0
?interrupt_enable@Memory@gb@emulation@@QAEAAEXZ ENDP	; emulation::gb::Memory::interrupt_enable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0Component@gb@emulation@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Component@gb@emulation@@QAE@XZ PROC			; emulation::gb::Component::Component, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Component@gb@emulation@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Component@gb@emulation@@QAE@XZ ENDP			; emulation::gb::Component::Component
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\gb.h
;	COMDAT ?Reset@Component@gb@emulation@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Reset@Component@gb@emulation@@UAEXXZ PROC		; emulation::gb::Component::Reset, COMDAT
; _this$ = ecx

; 33   : 	virtual void Reset() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 34   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@Component@gb@emulation@@UAEXXZ ENDP		; emulation::gb::Component::Reset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\gb.h
;	COMDAT ?Deinitialize@Component@gb@emulation@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Deinitialize@Component@gb@emulation@@UAEXXZ PROC	; emulation::gb::Component::Deinitialize, COMDAT
; _this$ = ecx

; 31   : 	virtual void Deinitialize() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?Deinitialize@Component@gb@emulation@@UAEXXZ ENDP	; emulation::gb::Component::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File d:\personal\projects\gbemu\solution\code\emulation\gb\gb.h
;	COMDAT ?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_emu$ = 8						; size = 4
?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z PROC ; emulation::gb::Component::Initialize, COMDAT
; _this$ = ecx

; 28   :   virtual void Initialize(Emu* emu) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 29   :     emu_ = emu;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _emu$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 30   :   }

	mov	esp, ebp
	pop	ebp
	ret	4
?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ENDP ; emulation::gb::Component::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 137  : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$yc	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 130  : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Ignore@std@@QAE@XZ PROC				; std::_Ignore::_Ignore, COMDAT
; _this$ = ecx

; 120  : 	_Ignore()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Ignore@std@@QAE@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
