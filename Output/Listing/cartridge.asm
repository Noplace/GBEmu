; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

	TITLE	C:\Users\Khalid\Documents\GitHub\GBEmu\Solution\Code\emulation\gb\cartridge.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?value@?$_Abs@$0GE@@std@@2_JB			; std::_Abs<100>::value
PUBLIC	?value@?$_Abs@$0DLJKMKAA@@std@@2_JB		; std::_Abs<1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?value@?$_GcdX@$0GE@$0A@@std@@2_JB		; std::_GcdX<100,0>::value
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB	; std::_GcdX<1000000000,100>::value
PUBLIC	?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
PUBLIC	?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
PUBLIC	?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<100,1000000000>::value
PUBLIC	?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
PUBLIC	?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
PUBLIC	?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<100,1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$_Abs@$00@std@@2_JB			; std::_Abs<1>::value
PUBLIC	?value@?$_GcdX@$00$0A@@std@@2_JB		; std::_GcdX<1,0>::value
PUBLIC	?value@?$_GcdX@$00$00@std@@2_JB			; std::_GcdX<1,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?value@?$_Gcd@$00$00@std@@2_JB			; std::_Gcd<1,1>::value
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_monotonic@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_monotonic
PUBLIC	?is_steady@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_steady
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB		; std::_GcdX<10000000,1>::value
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB		; std::_GcdX<1,10000000>::value
PUBLIC	?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB		; std::_Gcd<1,10000000>::value
PUBLIC	?num@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::num
PUBLIC	?den@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::den
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?value@?$integral_constant@H$0A@@std@@2HB	; std::integral_constant<int,0>::value
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
PUBLIC	?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
PUBLIC	?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_nonNull
PUBLIC	?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelException
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_notInlined
PUBLIC	?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_structured
PUBLIC	?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_localCancel
PUBLIC	?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_reserved
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
PUBLIC	?value@?$_Abs@$0JIJGIA@@std@@2_JB		; std::_Abs<10000000>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB		; std::_GcdX<10000000,0>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_GcdX<10000000,10000000>::value
PUBLIC	?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Gcd<10000000,10000000>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?num@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::num
PUBLIC	?den@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::den
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?is_monotonic@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_monotonic
PUBLIC	?is_steady@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_steady
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	_ConcRT_ProviderGuid
PUBLIC	_ConcRTEventGuid
PUBLIC	_SchedulerEventGuid
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	_ScheduleGroupEventGuid
PUBLIC	_ContextEventGuid
PUBLIC	_ChoreEventGuid
PUBLIC	_VirtualProcessorEventGuid
PUBLIC	_LockEventGuid
PUBLIC	_ResourceManagerEventGuid
PUBLIC	_PPLParallelInvokeEventGuid
PUBLIC	_PPLParallelForEventGuid
PUBLIC	_PPLParallelForeachEventGuid
PUBLIC	_AgentEventGuid
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT _AgentEventGuid
CONST	SEGMENT
_AgentEventGuid DD 0b9b5b78cH
	DW	0713H
	DW	04898H
	DB	0a2H
	DB	01aH
	DB	0c6H
	DB	079H
	DB	049H
	DB	0dcH
	DB	0edH
	DB	07H
CONST	ENDS
;	COMDAT _PPLParallelForeachEventGuid
CONST	SEGMENT
_PPLParallelForeachEventGuid DD 05cb7d785H
	DW	09d66H
	DW	0465dH
	DB	0baH
	DB	0e1H
	DB	046H
	DB	011H
	DB	06H
	DB	01bH
	DB	054H
	DB	034H
CONST	ENDS
;	COMDAT _PPLParallelForEventGuid
CONST	SEGMENT
_PPLParallelForEventGuid DD 031c8da6bH
	DW	06165H
	DW	04042H
	DB	08bH
	DB	092H
	DB	094H
	DB	09eH
	DB	031H
	DB	05fH
	DB	04dH
	DB	084H
CONST	ENDS
;	COMDAT _PPLParallelInvokeEventGuid
CONST	SEGMENT
_PPLParallelInvokeEventGuid DD 0d1b5b133H
	DW	0ec3dH
	DW	049f4H
	DB	098H
	DB	0a3H
	DB	046H
	DB	04dH
	DB	01aH
	DB	09eH
	DB	046H
	DB	082H
CONST	ENDS
;	COMDAT _ResourceManagerEventGuid
CONST	SEGMENT
_ResourceManagerEventGuid DD 02718d25bH
	DW	05bf5H
	DW	04479H
	DB	08eH
	DB	088H
	DB	0baH
	DB	0bcH
	DB	064H
	DB	0bdH
	DB	0bfH
	DB	0caH
CONST	ENDS
;	COMDAT _LockEventGuid
CONST	SEGMENT
_LockEventGuid DD 079a60dc6H
	DW	05fc8H
	DW	04952H
	DB	0a4H
	DB	01cH
	DB	011H
	DB	063H
	DB	0aeH
	DB	0ecH
	DB	05eH
	DB	0b8H
CONST	ENDS
;	COMDAT _VirtualProcessorEventGuid
CONST	SEGMENT
_VirtualProcessorEventGuid DD 02f27805fH
	DW	01676H
	DW	04eccH
	DB	096H
	DB	0faH
	DB	07eH
	DB	0b0H
	DB	09dH
	DB	044H
	DB	030H
	DB	02fH
CONST	ENDS
;	COMDAT _ChoreEventGuid
CONST	SEGMENT
_ChoreEventGuid DD 07e854ec7H
	DW	0cdc4H
	DW	0405aH
	DB	0b5H
	DB	0b2H
	DB	0aaH
	DB	0f7H
	DB	0c9H
	DB	0e7H
	DB	0d4H
	DB	0cH
CONST	ENDS
;	COMDAT _ContextEventGuid
CONST	SEGMENT
_ContextEventGuid DD 05727a00fH
	DW	050beH
	DW	04519H
	DB	082H
	DB	056H
	DB	0f7H
	DB	069H
	DB	098H
	DB	071H
	DB	0feH
	DB	0cbH
CONST	ENDS
;	COMDAT _ScheduleGroupEventGuid
CONST	SEGMENT
_ScheduleGroupEventGuid DD 0e8a3bf1fH
	DW	0a86bH
	DW	04390H
	DB	09cH
	DB	060H
	DB	053H
	DB	090H
	DB	0b9H
	DB	069H
	DB	0d2H
	DB	02cH
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT _SchedulerEventGuid
CONST	SEGMENT
_SchedulerEventGuid DD 0e2091f8aH
	DW	01e0aH
	DW	04731H
	DB	084H
	DB	0a2H
	DB	0dH
	DB	0d5H
	DB	07cH
	DB	08aH
	DB	052H
	DB	061H
CONST	ENDS
;	COMDAT _ConcRTEventGuid
CONST	SEGMENT
_ConcRTEventGuid DD 072b14a7dH
	DW	0704cH
	DW	0423eH
	DB	092H
	DB	0f8H
	DB	07eH
	DB	06dH
	DB	064H
	DB	0bcH
	DB	0b9H
	DB	02aH
CONST	ENDS
;	COMDAT _ConcRT_ProviderGuid
CONST	SEGMENT
_ConcRT_ProviderGuid DD 0f7b697a3H
	DW	04db5H
	DW	04d3bH
	DB	0beH
	DB	071H
	DB	0c4H
	DB	0d2H
	DB	084H
	DB	0e6H
	DB	059H
	DB	02fH
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?is_steady@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@steady_clock@chrono@std@@2_NB DB 01H		; std::chrono::steady_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@steady_clock@chrono@std@@2_NB DB 01H	; std::chrono::steady_clock::is_monotonic
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::num
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0JIJGIA@@std@@2_JB DQ 0000000000989680H	; std::_Abs<10000000>::value
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_reserved
CONST	ENDS
;	COMDAT ?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_localCancel
CONST	ENDS
;	COMDAT ?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_structured
CONST	ENDS
;	COMDAT ?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB DD 0ffffffffH ; Concurrency::details::_TaskCollectionBase::_S_notInlined
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_cancelException
CONST	ENDS
;	COMDAT ?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB DD 08H ; Concurrency::details::_TaskCollectionBase::_S_nonNull
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
CONST	ENDS
;	COMDAT ?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
CONST	ENDS
;	COMDAT ?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB DD 00H ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@H$0A@@std@@2HB
CONST	SEGMENT
?value@?$integral_constant@H$0A@@std@@2HB DD 00H	; std::integral_constant<int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::ratio<1,10000000>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,10000000>::num
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000000>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000000,1>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?is_steady@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@system_clock@chrono@std@@2_NB DB 00H		; std::chrono::system_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@system_clock@chrono@std@@2_NB DB 00H	; std::chrono::system_clock::is_monotonic
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0A@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$00@std@@2_JB DQ 0000000000000001H	; std::_Abs<1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_Gcd<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB DD 03H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
CONST	ENDS
;	COMDAT ?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 02H ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 01H ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
CONST	ENDS
;	COMDAT ?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB DD 00H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<1000000000,100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0A@@std@@2_JB DQ 0000000000000064H	; std::_GcdX<100,0>::value
CONST	ENDS
CONST	SEGMENT
$SG130226 DB	'Code\emulation\gb\cartridge.cpp', 00H
$SG130231 DB	'Code\emulation\gb\cartridge.cpp', 00H
$SG130236 DB	'Code\emulation\gb\cartridge.cpp', 00H
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Abs<1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0GE@@std@@2_JB DQ 0000000000000064H	; std::_Abs<100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
PUBLIC	??0_Ignore@std@@QAE@XZ				; std::_Ignore::_Ignore
PUBLIC	?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ; emulation::gb::Component::Initialize
PUBLIC	?rom_size_bytes@CartridgeHeader@gb@emulation@@QAEIXZ ; emulation::gb::CartridgeHeader::rom_size_bytes
PUBLIC	?Initialize@Cartridge@gb@emulation@@UAEXPAVEmu@23@@Z ; emulation::gb::Cartridge::Initialize
PUBLIC	?Deinitialize@Cartridge@gb@emulation@@UAEXXZ	; emulation::gb::Cartridge::Deinitialize
PUBLIC	?LoadFile@Cartridge@gb@emulation@@QAEXPBDPAUCartridgeHeader@23@@Z ; emulation::gb::Cartridge::LoadFile
PUBLIC	?rom@Cartridge@gb@emulation@@QAEPBEXZ		; emulation::gb::Cartridge::rom
PUBLIC	?Read@Cartridge@gb@emulation@@QAEEG@Z		; emulation::gb::Cartridge::Read
PUBLIC	?Write@Cartridge@gb@emulation@@QAEXGE@Z		; emulation::gb::Cartridge::Write
PUBLIC	?Initialize@MemoryBankController@gb@emulation@@UAEXPAVCartridge@23@@Z ; emulation::gb::MemoryBankController::Initialize
PUBLIC	?Deinitialize@MemoryBankController@gb@emulation@@UAEXXZ ; emulation::gb::MemoryBankController::Deinitialize
PUBLIC	??0MemoryBankController@gb@emulation@@QAE@XZ	; emulation::gb::MemoryBankController::MemoryBankController
PUBLIC	??$SafeDeleteArray@E@@YAXPAPAE@Z		; SafeDeleteArray<unsigned char>
PUBLIC	?Deinitialize@MBCNone@gb@emulation@@UAEXXZ	; emulation::gb::MBCNone::Deinitialize
PUBLIC	?Read@MBCNone@gb@emulation@@UAEEG@Z		; emulation::gb::MBCNone::Read
PUBLIC	?Write@MBCNone@gb@emulation@@UAEXGE@Z		; emulation::gb::MBCNone::Write
PUBLIC	??0MBCNone@gb@emulation@@QAE@XZ			; emulation::gb::MBCNone::MBCNone
PUBLIC	?Initialize@MBC1@gb@emulation@@UAEXPAVCartridge@23@@Z ; emulation::gb::MBC1::Initialize
PUBLIC	?Deinitialize@MBC1@gb@emulation@@UAEXXZ		; emulation::gb::MBC1::Deinitialize
PUBLIC	?Read@MBC1@gb@emulation@@UAEEG@Z		; emulation::gb::MBC1::Read
PUBLIC	?Write@MBC1@gb@emulation@@UAEXGE@Z		; emulation::gb::MBC1::Write
PUBLIC	??0MBC1@gb@emulation@@QAE@XZ			; emulation::gb::MBC1::MBC1
PUBLIC	??$SafeDelete@VMemoryBankController@gb@emulation@@@@YAXPAPAVMemoryBankController@gb@emulation@@@Z ; SafeDelete<emulation::gb::MemoryBankController>
PUBLIC	??_7MemoryBankController@gb@emulation@@6B@	; emulation::gb::MemoryBankController::`vftable'
PUBLIC	??_C@_0EO@OHMNHGO@c?3?2users?2khalid?2documents?2github@ ; `string'
PUBLIC	??_7MBCNone@gb@emulation@@6B@			; emulation::gb::MBCNone::`vftable'
PUBLIC	??_7MBC1@gb@emulation@@6B@			; emulation::gb::MBC1::`vftable'
PUBLIC	??_R4MemoryBankController@gb@emulation@@6B@	; emulation::gb::MemoryBankController::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMemoryBankController@gb@emulation@@@8	; emulation::gb::MemoryBankController `RTTI Type Descriptor'
PUBLIC	??_R3MemoryBankController@gb@emulation@@8	; emulation::gb::MemoryBankController::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MemoryBankController@gb@emulation@@8	; emulation::gb::MemoryBankController::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MemoryBankController@gb@emulation@@8 ; emulation::gb::MemoryBankController::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4MBCNone@gb@emulation@@6B@			; emulation::gb::MBCNone::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMBCNone@gb@emulation@@@8		; emulation::gb::MBCNone `RTTI Type Descriptor'
PUBLIC	??_R3MBCNone@gb@emulation@@8			; emulation::gb::MBCNone::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MBCNone@gb@emulation@@8			; emulation::gb::MBCNone::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MBCNone@gb@emulation@@8		; emulation::gb::MBCNone::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4MBC1@gb@emulation@@6B@			; emulation::gb::MBC1::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMBC1@gb@emulation@@@8			; emulation::gb::MBC1 `RTTI Type Descriptor'
PUBLIC	??_R3MBC1@gb@emulation@@8			; emulation::gb::MBC1::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MBC1@gb@emulation@@8			; emulation::gb::MBC1::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MBC1@gb@emulation@@8		; emulation::gb::MBC1::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__purecall:PROC
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_memcpy:PROC
EXTRN	__imp__DebugBreak@0:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??2@YAPAXIHPBDH@Z:PROC				; operator new
EXTRN	??_U@YAPAXIHPBDH@Z:PROC				; operator new[]
EXTRN	?ReadWholeFileBinary@io@core@@YAXPBDPAPAEAAI@Z:PROC ; core::io::ReadWholeFileBinary
EXTRN	?DestroyFileBuffer@io@core@@YAXPAPAE@Z:PROC	; core::io::DestroyFileBuffer
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_ignore	DB	01H DUP (?)
__Tuple_alloc DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@MBC1@gb@emulation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MBC1@gb@emulation@@8 DD FLAT:??_R0?AVMBC1@gb@emulation@@@8 ; emulation::gb::MBC1::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MBC1@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R2MBC1@gb@emulation@@8
rdata$r	SEGMENT
??_R2MBC1@gb@emulation@@8 DD FLAT:??_R1A@?0A@EA@MBC1@gb@emulation@@8 ; emulation::gb::MBC1::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@MemoryBankController@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R3MBC1@gb@emulation@@8
rdata$r	SEGMENT
??_R3MBC1@gb@emulation@@8 DD 00H			; emulation::gb::MBC1::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2MBC1@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMBC1@gb@emulation@@@8
_DATA	SEGMENT
??_R0?AVMBC1@gb@emulation@@@8 DD FLAT:??_7type_info@@6B@ ; emulation::gb::MBC1 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMBC1@gb@emulation@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MBC1@gb@emulation@@6B@
rdata$r	SEGMENT
??_R4MBC1@gb@emulation@@6B@ DD 00H			; emulation::gb::MBC1::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMBC1@gb@emulation@@@8
	DD	FLAT:??_R3MBC1@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MBCNone@gb@emulation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MBCNone@gb@emulation@@8 DD FLAT:??_R0?AVMBCNone@gb@emulation@@@8 ; emulation::gb::MBCNone::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MBCNone@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R2MBCNone@gb@emulation@@8
rdata$r	SEGMENT
??_R2MBCNone@gb@emulation@@8 DD FLAT:??_R1A@?0A@EA@MBCNone@gb@emulation@@8 ; emulation::gb::MBCNone::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@MemoryBankController@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R3MBCNone@gb@emulation@@8
rdata$r	SEGMENT
??_R3MBCNone@gb@emulation@@8 DD 00H			; emulation::gb::MBCNone::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2MBCNone@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMBCNone@gb@emulation@@@8
_DATA	SEGMENT
??_R0?AVMBCNone@gb@emulation@@@8 DD FLAT:??_7type_info@@6B@ ; emulation::gb::MBCNone `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMBCNone@gb@emulation@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MBCNone@gb@emulation@@6B@
rdata$r	SEGMENT
??_R4MBCNone@gb@emulation@@6B@ DD 00H			; emulation::gb::MBCNone::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMBCNone@gb@emulation@@@8
	DD	FLAT:??_R3MBCNone@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MemoryBankController@gb@emulation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MemoryBankController@gb@emulation@@8 DD FLAT:??_R0?AVMemoryBankController@gb@emulation@@@8 ; emulation::gb::MemoryBankController::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryBankController@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R2MemoryBankController@gb@emulation@@8
rdata$r	SEGMENT
??_R2MemoryBankController@gb@emulation@@8 DD FLAT:??_R1A@?0A@EA@MemoryBankController@gb@emulation@@8 ; emulation::gb::MemoryBankController::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MemoryBankController@gb@emulation@@8
rdata$r	SEGMENT
??_R3MemoryBankController@gb@emulation@@8 DD 00H	; emulation::gb::MemoryBankController::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MemoryBankController@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMemoryBankController@gb@emulation@@@8
_DATA	SEGMENT
??_R0?AVMemoryBankController@gb@emulation@@@8 DD FLAT:??_7type_info@@6B@ ; emulation::gb::MemoryBankController `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMemoryBankController@gb@emulation@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MemoryBankController@gb@emulation@@6B@
rdata$r	SEGMENT
??_R4MemoryBankController@gb@emulation@@6B@ DD 00H	; emulation::gb::MemoryBankController::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMemoryBankController@gb@emulation@@@8
	DD	FLAT:??_R3MemoryBankController@gb@emulation@@8
rdata$r	ENDS
;	COMDAT ??_7MBC1@gb@emulation@@6B@
CONST	SEGMENT
??_7MBC1@gb@emulation@@6B@ DD FLAT:??_R4MBC1@gb@emulation@@6B@ ; emulation::gb::MBC1::`vftable'
	DD	FLAT:?Initialize@MBC1@gb@emulation@@UAEXPAVCartridge@23@@Z
	DD	FLAT:?Deinitialize@MBC1@gb@emulation@@UAEXXZ
	DD	FLAT:?Read@MBC1@gb@emulation@@UAEEG@Z
	DD	FLAT:?Write@MBC1@gb@emulation@@UAEXGE@Z
CONST	ENDS
;	COMDAT ??_7MBCNone@gb@emulation@@6B@
CONST	SEGMENT
??_7MBCNone@gb@emulation@@6B@ DD FLAT:??_R4MBCNone@gb@emulation@@6B@ ; emulation::gb::MBCNone::`vftable'
	DD	FLAT:?Initialize@MemoryBankController@gb@emulation@@UAEXPAVCartridge@23@@Z
	DD	FLAT:?Deinitialize@MBCNone@gb@emulation@@UAEXXZ
	DD	FLAT:?Read@MBCNone@gb@emulation@@UAEEG@Z
	DD	FLAT:?Write@MBCNone@gb@emulation@@UAEXGE@Z
CONST	ENDS
;	COMDAT ??_C@_0EO@OHMNHGO@c?3?2users?2khalid?2documents?2github@
CONST	SEGMENT
??_C@_0EO@OHMNHGO@c?3?2users?2khalid?2documents?2github@ DB 'c:\users\kha'
	DB	'lid\documents\github\gbemu\solution\code\emulation\gb\cartrid'
	DB	'ge.h', 00H					; `string'
CONST	ENDS
;	COMDAT ??_7MemoryBankController@gb@emulation@@6B@
CONST	SEGMENT
??_7MemoryBankController@gb@emulation@@6B@ DD FLAT:??_R4MemoryBankController@gb@emulation@@6B@ ; emulation::gb::MemoryBankController::`vftable'
	DD	FLAT:?Initialize@MemoryBankController@gb@emulation@@UAEXPAVCartridge@23@@Z
	DD	FLAT:?Deinitialize@MemoryBankController@gb@emulation@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\wincore\types.h
;	COMDAT ??$SafeDelete@VMemoryBankController@gb@emulation@@@@YAXPAPAVMemoryBankController@gb@emulation@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_ppInterfaceToDelete$ = 8				; size = 4
??$SafeDelete@VMemoryBankController@gb@emulation@@@@YAXPAPAVMemoryBankController@gb@emulation@@@Z PROC ; SafeDelete<emulation::gb::MemoryBankController>, COMDAT

; 35   : inline void SafeDelete(Interface **ppInterfaceToDelete) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 36   :     if (*ppInterfaceToDelete != NULL) {

	mov	eax, DWORD PTR _ppInterfaceToDelete$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SafeDelete

; 37   :         delete (*ppInterfaceToDelete);

	mov	ecx, DWORD PTR _ppInterfaceToDelete$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 38   :         (*ppInterfaceToDelete) = NULL;

	mov	ecx, DWORD PTR _ppInterfaceToDelete$[ebp]
	mov	DWORD PTR [ecx], 0
$LN2@SafeDelete:

; 39   :     }
; 40   : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$SafeDelete@VMemoryBankController@gb@emulation@@@@YAXPAPAVMemoryBankController@gb@emulation@@@Z ENDP ; SafeDelete<emulation::gb::MemoryBankController>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0MBC1@gb@emulation@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MBC1@gb@emulation@@QAE@XZ PROC			; emulation::gb::MBC1::MBC1, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0MemoryBankController@gb@emulation@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7MBC1@gb@emulation@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0MBC1@gb@emulation@@QAE@XZ ENDP			; emulation::gb::MBC1::MBC1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Write@MBC1@gb@emulation@@UAEXGE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_address$ = 8						; size = 2
_data$ = 12						; size = 1
?Write@MBC1@gb@emulation@@UAEXGE@Z PROC			; emulation::gb::MBC1::Write, COMDAT
; _this$ = ecx

; 52   :   void Write(uint16_t address, uint8_t data) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 53   :    if (address >= 0x0000 && address <= 0x1FFF) {

	movzx	eax, WORD PTR _address$[ebp]
	test	eax, eax
	jl	SHORT $LN13@Write
	movzx	ecx, WORD PTR _address$[ebp]
	cmp	ecx, 8191				; 00001fffH
	jg	SHORT $LN13@Write

; 54   : 	    eram_enable = data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _data$[ebp]
	mov	BYTE PTR [edx+12], al
	jmp	$LN14@Write
$LN13@Write:

; 55   : 	  } else if (address >= 0x2000 && address <= 0x3FFF) {

	movzx	ecx, WORD PTR _address$[ebp]
	cmp	ecx, 8192				; 00002000H
	jl	SHORT $LN11@Write
	movzx	edx, WORD PTR _address$[ebp]
	cmp	edx, 16383				; 00003fffH
	jg	SHORT $LN11@Write

; 56   :       rom_bank_number = data&0x1F;

	movzx	eax, BYTE PTR _data$[ebp]
	and	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+16], al

; 57   :       if (rom_bank_number == 0)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	test	eax, eax
	jne	SHORT $LN10@Write

; 58   :         rom_bank_number = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+16], 1
$LN10@Write:

; 59   :     } else if (address >= 0x4000 && address <= 0x5FFF) {

	jmp	$LN14@Write
$LN11@Write:
	movzx	edx, WORD PTR _address$[ebp]
	cmp	edx, 16384				; 00004000H
	jl	SHORT $LN8@Write
	movzx	eax, WORD PTR _address$[ebp]
	cmp	eax, 24575				; 00005fffH
	jg	SHORT $LN8@Write

; 60   :       if (mode==0) {

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	jne	SHORT $LN7@Write

; 61   :         rom_bank_number |= (data&0x3)<<5;

	movzx	eax, BYTE PTR _data$[ebp]
	and	eax, 3
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	or	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+16], dl

; 62   :         //ram_bank_number = 0;
; 63   :       } else {

	jmp	SHORT $LN6@Write
$LN7@Write:

; 64   :         //rom_bank_number &= 0x1F;
; 65   :         ram_bank_number = data&3;

	movzx	ecx, BYTE PTR _data$[ebp]
	and	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+18], cl
$LN6@Write:

; 66   :       }

	jmp	SHORT $LN14@Write
$LN8@Write:

; 67   :     } else if (address >= 0x6000 && address <= 0x7FFF) {

	movzx	eax, WORD PTR _address$[ebp]
	cmp	eax, 24576				; 00006000H
	jl	SHORT $LN4@Write
	movzx	ecx, WORD PTR _address$[ebp]
	cmp	ecx, 32767				; 00007fffH
	jg	SHORT $LN4@Write

; 68   :        mode = data&1;

	movzx	edx, BYTE PTR _data$[ebp]
	and	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+17], dl
	jmp	SHORT $LN14@Write
$LN4@Write:

; 69   : 
; 70   :     } else if (address >= 0xA000 && address <= 0xBFFF) {

	movzx	ecx, WORD PTR _address$[ebp]
	cmp	ecx, 40960				; 0000a000H
	jl	SHORT $LN14@Write
	movzx	edx, WORD PTR _address$[ebp]
	cmp	edx, 49151				; 0000bfffH
	jg	SHORT $LN14@Write

; 71   :       if ((eram_enable&0x0A)==0x0A)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+12]
	and	ecx, 10					; 0000000aH
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN14@Write

; 72   :         eram_[address&0x1FFF] = data;

	movzx	edx, WORD PTR _address$[ebp]
	and	edx, 8191				; 00001fffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	al, BYTE PTR _data$[ebp]
	mov	BYTE PTR [ecx+edx], al
$LN14@Write:

; 73   : 	  }
; 74   :   }

	mov	esp, ebp
	pop	ebp
	ret	8
?Write@MBC1@gb@emulation@@UAEXGE@Z ENDP			; emulation::gb::MBC1::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Read@MBC1@gb@emulation@@UAEEG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_address$ = 8						; size = 2
?Read@MBC1@gb@emulation@@UAEEG@Z PROC			; emulation::gb::MBC1::Read, COMDAT
; _this$ = ecx

; 39   :   uint8_t Read(uint16_t address) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 40   :     if (address >= 0x0000 && address <= 0x3FFF) {

	movzx	eax, WORD PTR _address$[ebp]
	test	eax, eax
	jl	SHORT $LN7@Read
	movzx	ecx, WORD PTR _address$[ebp]
	cmp	ecx, 16383				; 00003fffH
	jg	SHORT $LN7@Read

; 41   : 	    return cartridge->rom()[address];

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?rom@Cartridge@gb@emulation@@QAEPBEXZ	; emulation::gb::Cartridge::rom
	movzx	ecx, WORD PTR _address$[ebp]
	mov	al, BYTE PTR [eax+ecx]
	jmp	$LN8@Read
	jmp	$LN6@Read
$LN7@Read:

; 42   : 	  } else if (address >= 0x4000 && address <= 0x7FFF) {

	movzx	edx, WORD PTR _address$[ebp]
	cmp	edx, 16384				; 00004000H
	jl	SHORT $LN5@Read
	movzx	eax, WORD PTR _address$[ebp]
	cmp	eax, 32767				; 00007fffH
	jg	SHORT $LN5@Read

; 43   :       return cartridge->rom()[address+0x4000*(rom_bank_number-1)];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?rom@Cartridge@gb@emulation@@QAEPBEXZ	; emulation::gb::Cartridge::rom
	movzx	edx, WORD PTR _address$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [ecx+16]
	sub	ecx, 1
	shl	ecx, 14					; 0000000eH
	add	edx, ecx
	mov	al, BYTE PTR [eax+edx]
	jmp	SHORT $LN8@Read
	jmp	SHORT $LN6@Read
$LN5@Read:

; 44   :     } else if (address >= 0xA000 && address <= 0xBFFF) {

	movzx	edx, WORD PTR _address$[ebp]
	cmp	edx, 40960				; 0000a000H
	jl	SHORT $LN6@Read
	movzx	eax, WORD PTR _address$[ebp]
	cmp	eax, 49151				; 0000bfffH
	jg	SHORT $LN6@Read

; 45   :       if ((eram_enable&0x0A)==0x0A)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+12]
	and	edx, 10					; 0000000aH
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN2@Read

; 46   :         return eram_[(address&0x1FFF)+(0x2000*ram_bank_number*mode)];

	movzx	eax, WORD PTR _address$[ebp]
	and	eax, 8191				; 00001fffH
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+18]
	shl	edx, 13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [ecx+17]
	imul	edx, ecx
	add	eax, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	al, BYTE PTR [ecx+eax]
	jmp	SHORT $LN8@Read

; 47   :       else

	jmp	SHORT $LN6@Read
$LN2@Read:

; 48   :         return 0;

	xor	al, al
	jmp	SHORT $LN8@Read
$LN6@Read:

; 49   :     }
; 50   :     return 0;

	xor	al, al
$LN8@Read:

; 51   :   }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Read@MBC1@gb@emulation@@UAEEG@Z ENDP			; emulation::gb::MBC1::Read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Deinitialize@MBC1@gb@emulation@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Deinitialize@MBC1@gb@emulation@@UAEXXZ PROC		; emulation::gb::MBC1::Deinitialize, COMDAT
; _this$ = ecx

; 36   :   void Deinitialize() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 37   :     MemoryBankController::Deinitialize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Deinitialize@MemoryBankController@gb@emulation@@UAEXXZ ; emulation::gb::MemoryBankController::Deinitialize

; 38   :   }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Deinitialize@MBC1@gb@emulation@@UAEXXZ ENDP		; emulation::gb::MBC1::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Initialize@MBC1@gb@emulation@@UAEXPAVCartridge@23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cartridge$ = 8						; size = 4
?Initialize@MBC1@gb@emulation@@UAEXPAVCartridge@23@@Z PROC ; emulation::gb::MBC1::Initialize, COMDAT
; _this$ = ecx

; 28   :   void Initialize(Cartridge* cartridge) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 29   :     MemoryBankController::Initialize(cartridge);

	mov	eax, DWORD PTR _cartridge$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Initialize@MemoryBankController@gb@emulation@@UAEXPAVCartridge@23@@Z ; emulation::gb::MemoryBankController::Initialize

; 30   :     eram_enable = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+12], 0

; 31   :     eram_enable = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+12], 0

; 32   :     rom_bank_number = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+16], 1

; 33   :     ram_bank_number = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+18], 0

; 34   :     mode = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+17], 0

; 35   :   }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Initialize@MBC1@gb@emulation@@UAEXPAVCartridge@23@@Z ENDP ; emulation::gb::MBC1::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0MBCNone@gb@emulation@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MBCNone@gb@emulation@@QAE@XZ PROC			; emulation::gb::MBCNone::MBCNone, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0MemoryBankController@gb@emulation@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7MBCNone@gb@emulation@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0MBCNone@gb@emulation@@QAE@XZ ENDP			; emulation::gb::MBCNone::MBCNone
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Write@MBCNone@gb@emulation@@UAEXGE@Z
_TEXT	SEGMENT
_a$ = -8						; size = 4
_this$ = -4						; size = 4
_address$ = 8						; size = 2
_data$ = 12						; size = 1
?Write@MBCNone@gb@emulation@@UAEXGE@Z PROC		; emulation::gb::MBCNone::Write, COMDAT
; _this$ = ecx

; 21   :   void Write(uint16_t address, uint8_t data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 22   :     int a = 1;

	mov	DWORD PTR _a$[ebp], 1

; 23   :   }

	mov	esp, ebp
	pop	ebp
	ret	8
?Write@MBCNone@gb@emulation@@UAEXGE@Z ENDP		; emulation::gb::MBCNone::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Read@MBCNone@gb@emulation@@UAEEG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_address$ = 8						; size = 2
?Read@MBCNone@gb@emulation@@UAEEG@Z PROC		; emulation::gb::MBCNone::Read, COMDAT
; _this$ = ecx

; 11   :   uint8_t Read(uint16_t address) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 12   :       if (address >= 0x0000 && address <= 0x3FFF) {

	movzx	eax, WORD PTR _address$[ebp]
	test	eax, eax
	jl	SHORT $LN5@Read
	movzx	ecx, WORD PTR _address$[ebp]
	cmp	ecx, 16383				; 00003fffH
	jg	SHORT $LN5@Read

; 13   : 	    return cartridge->rom()[address];

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?rom@Cartridge@gb@emulation@@QAEPBEXZ	; emulation::gb::Cartridge::rom
	movzx	ecx, WORD PTR _address$[ebp]
	mov	al, BYTE PTR [eax+ecx]
	jmp	SHORT $LN6@Read
	jmp	SHORT $LN4@Read
$LN5@Read:

; 14   : 	  } else if (address >= 0x4000 && address <= 0x7FFF) {

	movzx	edx, WORD PTR _address$[ebp]
	cmp	edx, 16384				; 00004000H
	jl	SHORT $LN3@Read
	movzx	eax, WORD PTR _address$[ebp]
	cmp	eax, 32767				; 00007fffH
	jg	SHORT $LN3@Read

; 15   :       return cartridge->rom()[address];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?rom@Cartridge@gb@emulation@@QAEPBEXZ	; emulation::gb::Cartridge::rom
	movzx	edx, WORD PTR _address$[ebp]
	mov	al, BYTE PTR [eax+edx]
	jmp	SHORT $LN6@Read
	jmp	SHORT $LN4@Read
$LN3@Read:

; 16   :     } else if (address >= 0xA000 && address <= 0xBFFF) {

	movzx	eax, WORD PTR _address$[ebp]
	cmp	eax, 40960				; 0000a000H
	jl	SHORT $LN4@Read
	movzx	ecx, WORD PTR _address$[ebp]
	cmp	ecx, 49151				; 0000bfffH
	jg	SHORT $LN4@Read

; 17   :       return 0;

	xor	al, al
	jmp	SHORT $LN6@Read
$LN4@Read:

; 18   : 	  }
; 19   :     return 0;

	xor	al, al
$LN6@Read:

; 20   :   }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Read@MBCNone@gb@emulation@@UAEEG@Z ENDP		; emulation::gb::MBCNone::Read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\mbc.h
;	COMDAT ?Deinitialize@MBCNone@gb@emulation@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Deinitialize@MBCNone@gb@emulation@@UAEXXZ PROC		; emulation::gb::MBCNone::Deinitialize, COMDAT
; _this$ = ecx

; 8    :   void Deinitialize() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 9    :     MemoryBankController::Deinitialize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Deinitialize@MemoryBankController@gb@emulation@@UAEXXZ ; emulation::gb::MemoryBankController::Deinitialize

; 10   :   }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Deinitialize@MBCNone@gb@emulation@@UAEXXZ ENDP		; emulation::gb::MBCNone::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\wincore\types.h
;	COMDAT ??$SafeDeleteArray@E@@YAXPAPAE@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_ppInterfaceToDelete$ = 8				; size = 4
??$SafeDeleteArray@E@@YAXPAPAE@Z PROC			; SafeDeleteArray<unsigned char>, COMDAT

; 43   : inline void SafeDeleteArray(Interface **ppInterfaceToDelete) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 44   :     if (*ppInterfaceToDelete != NULL) {

	mov	eax, DWORD PTR _ppInterfaceToDelete$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SafeDelete

; 45   :         delete [] (*ppInterfaceToDelete);

	mov	ecx, DWORD PTR _ppInterfaceToDelete$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 46   :         (*ppInterfaceToDelete) = NULL;

	mov	ecx, DWORD PTR _ppInterfaceToDelete$[ebp]
	mov	DWORD PTR [ecx], 0
$LN2@SafeDelete:

; 47   :     }
; 48   : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$SafeDeleteArray@E@@YAXPAPAE@Z ENDP			; SafeDeleteArray<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0MemoryBankController@gb@emulation@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MemoryBankController@gb@emulation@@QAE@XZ PROC	; emulation::gb::MemoryBankController::MemoryBankController, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7MemoryBankController@gb@emulation@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0MemoryBankController@gb@emulation@@QAE@XZ ENDP	; emulation::gb::MemoryBankController::MemoryBankController
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\cartridge.h
;	COMDAT ?Deinitialize@MemoryBankController@gb@emulation@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Deinitialize@MemoryBankController@gb@emulation@@UAEXXZ PROC ; emulation::gb::MemoryBankController::Deinitialize, COMDAT
; _this$ = ecx

; 108  :   virtual void Deinitialize() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 109  :      SafeDeleteArray(&eram_); 

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	call	??$SafeDeleteArray@E@@YAXPAPAE@Z	; SafeDeleteArray<unsigned char>
	add	esp, 4

; 110  :   };

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Deinitialize@MemoryBankController@gb@emulation@@UAEXXZ ENDP ; emulation::gb::MemoryBankController::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\cartridge.h
;	COMDAT ?Initialize@MemoryBankController@gb@emulation@@UAEXPAVCartridge@23@@Z
_TEXT	SEGMENT
tv68 = -20						; size = 4
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
_cartridge$ = 8						; size = 4
?Initialize@MemoryBankController@gb@emulation@@UAEXPAVCartridge@23@@Z PROC ; emulation::gb::MemoryBankController::Initialize, COMDAT
; _this$ = ecx

; 99   :   virtual void Initialize(Cartridge* cartridge) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 100  :     this->cartridge = cartridge;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cartridge$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 101  :     switch (cartridge->header->ram_size) {

	mov	edx, DWORD PTR _cartridge$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+73]
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 3
	ja	$LN7@Initialize
	mov	edx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN9@Initialize[edx*4]
$LN4@Initialize:

; 102  :       case 0 : eram_ = nullptr; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	jmp	SHORT $LN7@Initialize
$LN3@Initialize:

; 103  :       case 1 : eram_ = new uint8_t[2048]; break;

	push	103					; 00000067H
	push	OFFSET ??_C@_0EO@OHMNHGO@c?3?2users?2khalid?2documents?2github@
	push	1
	push	2048					; 00000800H
	call	??_U@YAPAXIHPBDH@Z			; operator new[]
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN7@Initialize
$LN2@Initialize:

; 104  :       case 2 : eram_ = new uint8_t[0x2000]; break;

	push	104					; 00000068H
	push	OFFSET ??_C@_0EO@OHMNHGO@c?3?2users?2khalid?2documents?2github@
	push	1
	push	8192					; 00002000H
	call	??_U@YAPAXIHPBDH@Z			; operator new[]
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN7@Initialize
$LN1@Initialize:

; 105  :       case 3 : eram_ = new uint8_t[0x8000]; break;

	push	105					; 00000069H
	push	OFFSET ??_C@_0EO@OHMNHGO@c?3?2users?2khalid?2documents?2github@
	push	1
	push	32768					; 00008000H
	call	??_U@YAPAXIHPBDH@Z			; operator new[]
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T1[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edx+8], eax
$LN7@Initialize:

; 106  :     }
; 107  :   }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN9@Initialize:
	DD	$LN4@Initialize
	DD	$LN3@Initialize
	DD	$LN2@Initialize
	DD	$LN1@Initialize
?Initialize@MemoryBankController@gb@emulation@@UAEXPAVCartridge@23@@Z ENDP ; emulation::gb::MemoryBankController::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\cartridge.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_address$ = 8						; size = 2
_data$ = 12						; size = 1
?Write@Cartridge@gb@emulation@@QAEXGE@Z PROC		; emulation::gb::Cartridge::Write
; _this$ = ecx

; 54   : void Cartridge::Write(uint16_t address, uint8_t data) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 55   :   mbc->Write(address,data);

	mov	esi, esp
	movzx	eax, BYTE PTR _data$[ebp]
	push	eax
	movzx	ecx, WORD PTR _address$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 56   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Write@Cartridge@gb@emulation@@QAEXGE@Z ENDP		; emulation::gb::Cartridge::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\cartridge.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_address$ = 8						; size = 2
?Read@Cartridge@gb@emulation@@QAEEG@Z PROC		; emulation::gb::Cartridge::Read
; _this$ = ecx

; 50   : uint8_t Cartridge::Read(uint16_t address) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 51   :   return mbc->Read(address);

	mov	esi, esp
	movzx	eax, WORD PTR _address$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 52   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Read@Cartridge@gb@emulation@@QAEEG@Z ENDP		; emulation::gb::Cartridge::Read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\cartridge.h
;	COMDAT ?rom@Cartridge@gb@emulation@@QAEPBEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?rom@Cartridge@gb@emulation@@QAEPBEXZ PROC		; emulation::gb::Cartridge::rom, COMDAT
; _this$ = ecx

; 83   :   const uint8_t* rom() { return rom_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	esp, ebp
	pop	ebp
	ret	0
?rom@Cartridge@gb@emulation@@QAEPBEXZ ENDP		; emulation::gb::Cartridge::rom
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\cartridge.cpp
_TEXT	SEGMENT
tv169 = -52						; size = 4
tv152 = -48						; size = 4
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
_length$ = -24						; size = 4
_data$ = -12						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
_header$ = 12						; size = 4
?LoadFile@Cartridge@gb@emulation@@QAEXPBDPAUCartridgeHeader@23@@Z PROC ; emulation::gb::Cartridge::LoadFile
; _this$ = ecx

; 20   : void Cartridge::LoadFile(const char* filename, CartridgeHeader* header) {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 21   : 	SafeDeleteArray(&rom_);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	??$SafeDeleteArray@E@@YAXPAPAE@Z	; SafeDeleteArray<unsigned char>
	add	esp, 4

; 22   :   if (mbc) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN6@LoadFile

; 23   :     mbc->Deinitialize();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 24   : 		delete mbc;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T4[ebp], edx
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@LoadFile:

; 25   : 	}
; 26   :   uint8_t* data;
; 27   :   size_t length;
; 28   :   core::io::ReadWholeFileBinary(filename,&data,length);

	lea	ecx, DWORD PTR _length$[ebp]
	push	ecx
	lea	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?ReadWholeFileBinary@io@core@@YAXPBDPAPAEAAI@Z ; core::io::ReadWholeFileBinary
	add	esp, 12					; 0000000cH

; 29   :   memcpy(header,data+0x100,0x50);

	push	80					; 00000050H
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 256				; 00000100H
	push	ecx
	mov	edx, DWORD PTR _header$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 30   :   if (header->rom_size_bytes() == 0) {

	mov	ecx, DWORD PTR _header$[ebp]
	call	?rom_size_bytes@CartridgeHeader@gb@emulation@@QAEIXZ ; emulation::gb::CartridgeHeader::rom_size_bytes
	test	eax, eax
	jne	SHORT $LN5@LoadFile

; 31   :     //report error
; 32   :     return;

	jmp	$LN7@LoadFile
$LN5@LoadFile:

; 33   :   }
; 34   :   rom_ = new uint8_t[header->rom_size_bytes()];

	push	34					; 00000022H
	push	OFFSET $SG130226
	push	1
	mov	ecx, DWORD PTR _header$[ebp]
	call	?rom_size_bytes@CartridgeHeader@gb@emulation@@QAEIXZ ; emulation::gb::CartridgeHeader::rom_size_bytes
	push	eax
	call	??_U@YAPAXIHPBDH@Z			; operator new[]
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [eax+16], ecx

; 35   :   memcpy(rom_,data,header->rom_size_bytes());

	mov	ecx, DWORD PTR _header$[ebp]
	call	?rom_size_bytes@CartridgeHeader@gb@emulation@@QAEIXZ ; emulation::gb::CartridgeHeader::rom_size_bytes
	push	eax
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 36   :   this->header = (CartridgeHeader*)&rom_[0x100];

	mov	edx, 1
	shl	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 37   :   if (header->cartridge_type == 0) {

	mov	edx, DWORD PTR _header$[ebp]
	movzx	eax, BYTE PTR [edx+71]
	test	eax, eax
	jne	SHORT $LN4@LoadFile

; 38   :     mbc = new MBCNone();

	push	38					; 00000026H
	push	OFFSET $SG130231
	push	1
	push	16					; 00000010H
	call	??2@YAPAXIHPBDH@Z			; operator new
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN9@LoadFile
	mov	ecx, DWORD PTR $T2[ebp]
	call	??0MBCNone@gb@emulation@@QAE@XZ
	mov	DWORD PTR tv152[ebp], eax
	jmp	SHORT $LN10@LoadFile
$LN9@LoadFile:
	mov	DWORD PTR tv152[ebp], 0
$LN10@LoadFile:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv152[ebp]
	mov	DWORD PTR [ecx+12], edx
	jmp	SHORT $LN3@LoadFile
$LN4@LoadFile:

; 39   :   } else if (header->cartridge_type == 1) {

	mov	eax, DWORD PTR _header$[ebp]
	movzx	ecx, BYTE PTR [eax+71]
	cmp	ecx, 1
	jne	SHORT $LN2@LoadFile

; 40   :     mbc = new MBC1();

	push	40					; 00000028H
	push	OFFSET $SG130236
	push	1
	push	20					; 00000014H
	call	??2@YAPAXIHPBDH@Z			; operator new
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN11@LoadFile
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0MBC1@gb@emulation@@QAE@XZ
	mov	DWORD PTR tv169[ebp], eax
	jmp	SHORT $LN12@LoadFile
$LN11@LoadFile:
	mov	DWORD PTR tv169[ebp], 0
$LN12@LoadFile:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv169[ebp]
	mov	DWORD PTR [edx+12], eax

; 41   :   } else {

	jmp	SHORT $LN3@LoadFile
$LN2@LoadFile:

; 42   : 		DebugBreak();

	mov	esi, esp
	call	DWORD PTR __imp__DebugBreak@0
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@LoadFile:

; 43   : 	}
; 44   :   mbc->Initialize(this);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 45   :   core::io::DestroyFileBuffer(&data);

	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	?DestroyFileBuffer@io@core@@YAXPAPAE@Z	; core::io::DestroyFileBuffer
	add	esp, 4
$LN7@LoadFile:

; 46   : 
; 47   :   
; 48   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@LoadFile
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN16@LoadFile:
	DD	2
	DD	$LN15@LoadFile
$LN15@LoadFile:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN13@LoadFile
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN14@LoadFile
$LN14@LoadFile:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN13@LoadFile:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
?LoadFile@Cartridge@gb@emulation@@QAEXPBDPAUCartridgeHeader@23@@Z ENDP ; emulation::gb::Cartridge::LoadFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\cartridge.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Deinitialize@Cartridge@gb@emulation@@UAEXXZ PROC	; emulation::gb::Cartridge::Deinitialize
; _this$ = ecx

; 13   : void Cartridge::Deinitialize() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 14   :   core::io::DestroyFileBuffer(&rom_);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	?DestroyFileBuffer@io@core@@YAXPAPAE@Z	; core::io::DestroyFileBuffer
	add	esp, 4

; 15   :   if (mbc)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN1@Deinitiali

; 16   :     mbc->Deinitialize();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Deinitiali:

; 17   :   SafeDelete(&mbc);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	call	??$SafeDelete@VMemoryBankController@gb@emulation@@@@YAXPAPAVMemoryBankController@gb@emulation@@@Z ; SafeDelete<emulation::gb::MemoryBankController>
	add	esp, 4

; 18   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Deinitialize@Cartridge@gb@emulation@@UAEXXZ ENDP	; emulation::gb::Cartridge::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\cartridge.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_emu$ = 8						; size = 4
?Initialize@Cartridge@gb@emulation@@UAEXPAVEmu@23@@Z PROC ; emulation::gb::Cartridge::Initialize
; _this$ = ecx

; 7    : void Cartridge::Initialize(Emu* emu) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 8    :   Component::Initialize(emu);

	mov	eax, DWORD PTR _emu$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ; emulation::gb::Component::Initialize

; 9    :   rom_ = nullptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 10   :   mbc = nullptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 11   : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Initialize@Cartridge@gb@emulation@@UAEXPAVEmu@23@@Z ENDP ; emulation::gb::Cartridge::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\cartridge.h
;	COMDAT ?rom_size_bytes@CartridgeHeader@gb@emulation@@QAEIXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?rom_size_bytes@CartridgeHeader@gb@emulation@@QAEIXZ PROC ; emulation::gb::CartridgeHeader::rom_size_bytes, COMDAT
; _this$ = ecx

; 51   :   uint32_t rom_size_bytes() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 52   :     if (rom_size < 10){

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+72]
	cmp	ecx, 10					; 0000000aH
	jge	SHORT $LN7@rom_size_b

; 53   :       return 0x8000 << rom_size;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [edx+72]
	mov	eax, 32768				; 00008000H
	shl	eax, cl
	jmp	SHORT $LN8@rom_size_b

; 54   :     } else {

	jmp	SHORT $LN6@rom_size_b
$LN7@rom_size_b:

; 55   :       switch (rom_size) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+72]
	mov	BYTE PTR tv72[ebp], cl
	cmp	BYTE PTR tv72[ebp], 82			; 00000052H
	je	SHORT $LN3@rom_size_b
	cmp	BYTE PTR tv72[ebp], 83			; 00000053H
	je	SHORT $LN2@rom_size_b
	cmp	BYTE PTR tv72[ebp], 84			; 00000054H
	je	SHORT $LN1@rom_size_b
	jmp	SHORT $LN6@rom_size_b
$LN3@rom_size_b:

; 56   :         case 0x52:return 0x120000;

	mov	eax, 1179648				; 00120000H
	jmp	SHORT $LN8@rom_size_b
$LN2@rom_size_b:

; 57   :         case 0x53:return 0x140000;

	mov	eax, 1310720				; 00140000H
	jmp	SHORT $LN8@rom_size_b
$LN1@rom_size_b:

; 58   :         case 0x54:return 0x180000;

	mov	eax, 1572864				; 00180000H
	jmp	SHORT $LN8@rom_size_b
$LN6@rom_size_b:

; 59   :       }
; 60   :     }
; 61   :     return 0;

	xor	eax, eax
$LN8@rom_size_b:

; 62   :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?rom_size_bytes@CartridgeHeader@gb@emulation@@QAEIXZ ENDP ; emulation::gb::CartridgeHeader::rom_size_bytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\emulation\gb\gb.h
;	COMDAT ?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_emu$ = 8						; size = 4
?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z PROC ; emulation::gb::Component::Initialize, COMDAT
; _this$ = ecx

; 28   :   virtual void Initialize(Emu* emu) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 29   :     emu_ = emu;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _emu$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 30   :   }

	mov	esp, ebp
	pop	ebp
	ret	4
?Initialize@Component@gb@emulation@@UAEXPAVEmu@23@@Z ENDP ; emulation::gb::Component::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 137  : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$yc	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 130  : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Ignore@std@@QAE@XZ PROC				; std::_Ignore::_Ignore, COMDAT
; _this$ = ecx

; 120  : 	_Ignore()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Ignore@std@@QAE@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
