; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

	TITLE	C:\Users\Khalid\Documents\GitHub\GBEmu\Solution\Code\audio\wave_output.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__GUID_00000001_0000_0010_8000_00aa00389b71
;	COMDAT __GUID_00000001_0000_0010_8000_00aa00389b71
CONST	SEGMENT
__GUID_00000001_0000_0010_8000_00aa00389b71 DD 01H
	DW	00H
	DW	010H
	DB	080H
	DB	00H
	DB	00H
	DB	0aaH
	DB	00H
	DB	038H
	DB	09bH
	DB	071H
CONST	ENDS
PUBLIC	??0WaveOutput@@QAE@XZ				; WaveOutput::WaveOutput
PUBLIC	??1WaveOutput@@QAE@XZ				; WaveOutput::~WaveOutput
PUBLIC	?Initialize@WaveOutput@@QAEHXZ			; WaveOutput::Initialize
PUBLIC	?Deinitialize@WaveOutput@@QAEHXZ		; WaveOutput::Deinitialize
PUBLIC	?Open@WaveOutput@@QAEHHIHHH@Z			; WaveOutput::Open
PUBLIC	?Close@WaveOutput@@QAEHXZ			; WaveOutput::Close
PUBLIC	?Flush@WaveOutput@@QAEHH@Z			; WaveOutput::Flush
PUBLIC	?Write@WaveOutput@@QAEHPACH@Z			; WaveOutput::Write
PUBLIC	?WaveOutDone@WaveOutput@@KGXPAUHWAVEOUT__@@IKPAUwavehdr_tag@@K@Z ; WaveOutput::WaveOutDone
PUBLIC	?BitScanF@@YAHI@Z				; BitScanF
PUBLIC	??$SafeDeleteArray@X@@YAXPAPAX@Z		; SafeDeleteArray<void>
PUBLIC	__real@408f400000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__waveOutOpen@24:PROC
EXTRN	__imp__waveOutClose@4:PROC
EXTRN	__imp__waveOutPrepareHeader@12:PROC
EXTRN	__imp__waveOutUnprepareHeader@12:PROC
EXTRN	__imp__waveOutWrite@12:PROC
EXTRN	__imp__waveOutReset@4:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\wincore\types.h
;	COMDAT ??$SafeDeleteArray@X@@YAXPAPAX@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_ppInterfaceToDelete$ = 8				; size = 4
??$SafeDeleteArray@X@@YAXPAPAX@Z PROC			; SafeDeleteArray<void>, COMDAT

; 43   : inline void SafeDeleteArray(Interface **ppInterfaceToDelete) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 44   :     if (*ppInterfaceToDelete != NULL) {

	mov	eax, DWORD PTR _ppInterfaceToDelete$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SafeDelete

; 45   :         delete [] (*ppInterfaceToDelete);

	mov	ecx, DWORD PTR _ppInterfaceToDelete$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 46   :         (*ppInterfaceToDelete) = NULL;

	mov	ecx, DWORD PTR _ppInterfaceToDelete$[ebp]
	mov	DWORD PTR [ecx], 0
$LN2@SafeDelete:

; 47   :     }
; 48   : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$SafeDeleteArray@X@@YAXPAPAX@Z ENDP			; SafeDeleteArray<void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\wave_output.cpp
_TEXT	SEGMENT
_result$ = -8						; size = 4
_i$ = 8							; size = 4
?BitScanF@@YAHI@Z PROC					; BitScanF

; 6    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 7    :   DWORD result;
; 8    :   _BitScanForward(&result,i);

	bsf	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _result$[ebp], eax

; 9    : 
; 10   :   /*	_asm
; 11   : 	{
; 12   : 		xor		edx,edx
; 13   : 		bsf		eax,[i]
; 14   : 		setnz	dl
; 15   : 		dec		edx
; 16   : 		or		eax,edx
; 17   : 	}
; 18   : */
; 19   :   return result;

	mov	eax, DWORD PTR _result$[ebp]

; 20   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@BitScanF
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@BitScanF:
	DD	1
	DD	$LN4@BitScanF
$LN4@BitScanF:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN3@BitScanF
$LN3@BitScanF:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
?BitScanF@@YAHI@Z ENDP					; BitScanF
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\wave_output.cpp
_TEXT	SEGMENT
_self$ = -12						; size = 4
_end$ = -8						; size = 4
_copy$ = -4						; size = 4
_hwo$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_dwInstance$ = 16					; size = 4
_pWHdr$ = 20						; size = 4
_dwParam2$ = 24						; size = 4
?WaveOutDone@WaveOutput@@KGXPAUHWAVEOUT__@@IKPAUwavehdr_tag@@K@Z PROC ; WaveOutput::WaveOutDone

; 242  : void CALLBACK WaveOutput::WaveOutDone(HWAVEOUT hwo, uint32_t uMsg, DWORD_PTR dwInstance, WAVEHDR *pWHdr, DWORD_PTR dwParam2) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 243  : 	int32_t	copy,end;
; 244  : 
; 245  :   WaveOutput* self = reinterpret_cast<WaveOutput*>(dwInstance);

	mov	eax, DWORD PTR _dwInstance$[ebp]
	mov	DWORD PTR _self$[ebp], eax

; 246  : 
; 247  : 	if (uMsg==WOM_DONE && self->open)	{			//If a wave block is through playing, and the output

	cmp	DWORD PTR _uMsg$[ebp], 957		; 000003bdH
	jne	$LN7@WaveOutDon
	mov	ecx, DWORD PTR _self$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$LN7@WaveOutDon

; 248  : 												// device is open
; 249  : 		copy=self->buffer.length;							//Get the current length of data in the input buffer

	mov	edx, DWORD PTR _self$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR _copy$[ebp], eax

; 250  : 		if (copy>=self->blk.min)					//Is there enough data to fill a block?

	mov	ecx, DWORD PTR _self$[ebp]
	mov	edx, DWORD PTR _copy$[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jl	$LN5@WaveOutDon

; 251  : 		{
; 252  : 			//Calculate copy size --------------
; 253  : 			if (copy>self->blk.max) copy=self->blk.max;	//Limit copy size to max block size

	mov	eax, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR _copy$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jle	SHORT $LN4@WaveOutDon
	mov	edx, DWORD PTR _self$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _copy$[ebp], eax
$LN4@WaveOutDon:

; 254  : 												//Remove any partial samples (needed for 24-bit output)
; 255  : 			copy=(copy/self->wav.fmt.Format.nBlockAlign)*self->wav.fmt.Format.nBlockAlign;

	mov	ecx, DWORD PTR _self$[ebp]
	movzx	ecx, WORD PTR [ecx+172]
	mov	eax, DWORD PTR _copy$[ebp]
	cdq
	idiv	ecx
	mov	edx, DWORD PTR _self$[ebp]
	movzx	ecx, WORD PTR [edx+172]
	imul	eax, ecx
	mov	DWORD PTR _copy$[ebp], eax

; 256  : 
; 257  : 			//Copy samples to wave block -------
; 258  : 			if (copy<=self->buffer.size-self->buffer.read)	//Does copy size wrap around input buffer?

	mov	edx, DWORD PTR _self$[ebp]
	mov	eax, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	sub	ecx, DWORD PTR [eax+56]
	cmp	DWORD PTR _copy$[ebp], ecx
	jg	SHORT $LN3@WaveOutDon

; 259  : 			{									//Straight linear copy
; 260  : 				memcpy(pWHdr->lpData,(void*)((uintptr_t)self->buffer.pIn+self->buffer.read),copy);

	mov	edx, DWORD PTR _copy$[ebp]
	push	edx
	mov	eax, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _self$[ebp]
	add	ecx, DWORD PTR [edx+56]
	push	ecx
	mov	eax, DWORD PTR _pWHdr$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 261  : 				self->buffer.read+=copy;				//Move read index forward

	mov	edx, DWORD PTR _self$[ebp]
	mov	eax, DWORD PTR [edx+56]
	add	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _self$[ebp]
	mov	DWORD PTR [ecx+56], eax

; 262  : 			}
; 263  : 			else

	jmp	SHORT $LN2@WaveOutDon
$LN3@WaveOutDon:

; 264  : 			{
; 265  : 				end=self->buffer.size-self->buffer.read;		//Bytes to end of input buffer

	mov	edx, DWORD PTR _self$[ebp]
	mov	eax, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	sub	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _end$[ebp], ecx

; 266  : 				memcpy(pWHdr->lpData,(void*)((uintptr_t)self->buffer.pIn+self->buffer.read),end);

	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _self$[ebp]
	add	ecx, DWORD PTR [edx+56]
	push	ecx
	mov	eax, DWORD PTR _pWHdr$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 267  : 				self->buffer.read=copy-end;			//Bytes left in buffer

	mov	edx, DWORD PTR _copy$[ebp]
	sub	edx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR _self$[ebp]
	mov	DWORD PTR [eax+56], edx

; 268  : 				memcpy((void*)((uintptr_t)pWHdr->lpData+end),self->buffer.pIn,self->buffer.read);

	mov	ecx, DWORD PTR _self$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	push	ecx
	mov	edx, DWORD PTR _pWHdr$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _end$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN2@WaveOutDon:

; 269  : 			}
; 270  : 
; 271  : 			//Send block to driver -------------
; 272  : 			self->buffer.queued_length-=pWHdr->dwBufferLength;	//Update stats

	mov	ecx, DWORD PTR _self$[ebp]
	mov	edx, DWORD PTR _pWHdr$[ebp]
	mov	eax, DWORD PTR [ecx+88]
	sub	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _self$[ebp]
	mov	DWORD PTR [ecx+88], eax

; 273  : 			self->buffer.queued_length+=copy;

	mov	edx, DWORD PTR _self$[ebp]
	mov	eax, DWORD PTR [edx+88]
	add	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _self$[ebp]
	mov	DWORD PTR [ecx+88], eax

; 274  : 			self->blk.cnt++;

	mov	edx, DWORD PTR _self$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, 1
	mov	ecx, DWORD PTR _self$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 275  : 			self->blk.size+=copy;

	mov	eax, DWORD PTR _copy$[ebp]
	cdq
	mov	ecx, DWORD PTR _self$[ebp]
	add	eax, DWORD PTR [ecx+40]
	adc	edx, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _self$[ebp]
	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+44], edx

; 276  : 
; 277  : 			self->buffer.length-=copy;					//Update input buffer length

	mov	edx, DWORD PTR _self$[ebp]
	mov	eax, DWORD PTR [edx+84]
	sub	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _self$[ebp]
	mov	DWORD PTR [ecx+84], eax

; 278  : 			pWHdr->dwBufferLength=copy;			//Set data length in block

	mov	edx, DWORD PTR _pWHdr$[ebp]
	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [edx+4], eax

; 279  : 			waveOutWrite(self->wav.handle,pWHdr,sizeof(WAVEHDR));

	mov	esi, esp
	push	32					; 00000020H
	mov	ecx, DWORD PTR _pWHdr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _self$[ebp]
	mov	eax, DWORD PTR [edx+104]
	push	eax
	call	DWORD PTR __imp__waveOutWrite@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 280  : 
; 281  : 			self->wav.idle&=~pWHdr->dwUser;			//This block is in use

	mov	ecx, DWORD PTR _pWHdr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	not	edx
	mov	eax, DWORD PTR _self$[ebp]
	and	edx, DWORD PTR [eax+724]
	mov	ecx, DWORD PTR _self$[ebp]
	mov	DWORD PTR [ecx+724], edx

; 282  : 		}
; 283  : 		else

	jmp	SHORT $LN7@WaveOutDon
$LN5@WaveOutDon:

; 284  : 			self->wav.idle|=pWHdr->dwUser;			//Mark the corresponding bit that this block is idle

	mov	edx, DWORD PTR _self$[ebp]
	mov	eax, DWORD PTR _pWHdr$[ebp]
	mov	ecx, DWORD PTR [edx+724]
	or	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _self$[ebp]
	mov	DWORD PTR [edx+724], ecx
$LN7@WaveOutDon:

; 285  : 	}
; 286  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?WaveOutDone@WaveOutput@@KGXPAUHWAVEOUT__@@IKPAUwavehdr_tag@@K@Z ENDP ; WaveOutput::WaveOutDone
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\wave_output.cpp
_TEXT	SEGMENT
_copy$ = -8						; size = 4
_this$ = -4						; size = 4
_pIn$ = 8						; size = 4
_len$ = 12						; size = 4
?Write@WaveOutput@@QAEHPACH@Z PROC			; WaveOutput::Write
; _this$ = ecx

; 210  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 211  : 	uint32_t		copy;
; 212  : 
; 213  : 
; 214  : 	if (!open || len>buffer.size-(buffer.length-buffer.queued_length))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@Write
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+84]
	sub	eax, DWORD PTR [edx+88]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	sub	edx, eax
	cmp	DWORD PTR _len$[ebp], edx
	jle	SHORT $LN5@Write
$LN4@Write:

; 215  : 		return S_FALSE;								//If device isn't open, or buffer is full

	mov	eax, 1
	jmp	$LN6@Write
$LN5@Write:

; 216  : 
; 217  : 	//Copy data to input buffer ----------------
; 218  : 	if (len<=buffer.size-buffer.write)			//Will data fit without wrapping around?

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+48]
	sub	edx, DWORD PTR [ecx+60]
	cmp	DWORD PTR _len$[ebp], edx
	jg	SHORT $LN3@Write

; 219  : 	{
; 220  : 		memcpy((void*)((uintptr_t)buffer.pIn+buffer.write),pIn,len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pIn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+60]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 221  : 		buffer.write+=len;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	add	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], eax

; 222  : 	}
; 223  : 	else

	jmp	SHORT $LN2@Write
$LN3@Write:

; 224  : 	{
; 225  : 		copy=buffer.size-buffer.write;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	sub	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _copy$[ebp], ecx

; 226  : 		memcpy((void*)((uintptr_t)buffer.pIn+buffer.write),pIn,copy);

	mov	edx, DWORD PTR _copy$[ebp]
	push	edx
	mov	eax, DWORD PTR _pIn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+60]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 227  : 		buffer.write=len-copy;

	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, DWORD PTR _copy$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], ecx

; 228  : 		memcpy(buffer.pIn,pIn+copy,buffer.write);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _pIn$[ebp]
	add	edx, DWORD PTR _copy$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN2@Write:

; 229  : 	}
; 230  : 	buffer.length+=len;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], eax

; 231  : 	buffer.bytes+=(uint32_t)len;						//Casting as a uint32_t generates less code

	mov	edx, DWORD PTR _len$[ebp]
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+64]
	adc	eax, DWORD PTR [ecx+68]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], edx
	mov	DWORD PTR [ecx+68], eax

; 232  : 	buffer.total_bytes+=(uint32_t)len;

	mov	edx, DWORD PTR _len$[ebp]
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+72]
	adc	eax, DWORD PTR [ecx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], edx
	mov	DWORD PTR [ecx+76], eax

; 233  : 
; 234  : 	if (wav.idle && buffer.length>=blk.min)		//If any blocks are empty, and there's enough data,

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+724], 0
	je	SHORT $LN1@Write
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+84]
	cmp	edx, DWORD PTR [ecx+28]
	jl	SHORT $LN1@Write

; 235  : 	{											// add a block to the queue
; 236  : 		WaveOutDone(wav.handle,WOM_DONE,(DWORD_PTR)this,&wav.hdr[BitScanF(wav.idle)],0);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+724]
	push	ecx
	call	?BitScanF@@YAHI@Z			; BitScanF
	add	esp, 4
	shl	eax, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+eax+212]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	push	957					; 000003bdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	push	eax
	call	?WaveOutDone@WaveOutput@@KGXPAUHWAVEOUT__@@IKPAUwavehdr_tag@@K@Z ; WaveOutput::WaveOutDone
$LN1@Write:

; 237  : 	}
; 238  : 
; 239  : 	return S_OK;

	xor	eax, eax
$LN6@Write:

; 240  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Write@WaveOutput@@QAEHPACH@Z ENDP			; WaveOutput::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\wave_output.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
?Flush@WaveOutput@@QAEHH@Z PROC				; WaveOutput::Flush
; _this$ = ecx

; 197  : int WaveOutput::Flush(int32_t t) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 	buffer.length=0;								//Set size to 0 so reset won't start new buffers

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0

; 199  : 	buffer.write=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 0

; 200  : 	buffer.read=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0

; 201  : 	buffer.bytes=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], 0
	mov	DWORD PTR [eax+68], 0

; 202  : 	wav.samples=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+728], 0
	mov	DWORD PTR [ecx+732], 0

; 203  : 	wav.smpCnt=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+748], 0

; 204  : 
; 205  : 	waveOutReset(wav.handle);					//Reset output device

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	call	DWORD PTR __imp__waveOutReset@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 206  :   return S_OK;

	xor	eax, eax

; 207  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Flush@WaveOutput@@QAEHH@Z ENDP				; WaveOutput::Flush
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\wave_output.cpp
_TEXT	SEGMENT
tv173 = -40						; size = 8
tv170 = -32						; size = 8
tv164 = -24						; size = 8
tv161 = -16						; size = 8
_i$ = -8						; size = 4
_this$ = -4						; size = 4
?Close@WaveOutput@@QAEHXZ PROC				; WaveOutput::Close
; _this$ = ecx

; 177  : int WaveOutput::Close() {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 178  : 	int32_t	i;
; 179  :   
; 180  : 	wav.ttime+=(int32_t)(wav.samples * 1000.0 / (int32_t)wav.fmt.Format.nSamplesPerSec);

	mov	eax, DWORD PTR _this$[ebp]
	fild	QWORD PTR [eax+728]
	fstp	QWORD PTR tv161[ebp]
	fld	QWORD PTR tv161[ebp]
	fstp	QWORD PTR tv164[ebp]
	movsd	xmm0, QWORD PTR tv164[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	mov	ecx, DWORD PTR _this$[ebp]
	cvtsi2sd xmm1, DWORD PTR [ecx+164]
	divsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+744]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+744], edx

; 181  : 	buffer.total_time+=(int32_t)(buffer.bytes * 1000.0 / (int32_t)wav.fmt.Format.nAvgBytesPerSec);

	mov	edx, DWORD PTR _this$[ebp]
	fild	QWORD PTR [edx+64]
	fstp	QWORD PTR tv170[ebp]
	fld	QWORD PTR tv170[ebp]
	fstp	QWORD PTR tv173[ebp]
	movsd	xmm0, QWORD PTR tv173[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2sd xmm1, DWORD PTR [eax+168]
	divsd	xmm0, xmm1
	cvttsd2si ecx, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+80]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], ecx

; 182  : 
; 183  : 	open=0;									//Device will no longer be open

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 184  : 	wav.idle=(uint32_t)~0>>(32-blk.num);			//All blocks are free

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR [edx+24]
	or	eax, -1
	shr	eax, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+724], eax

; 185  : 
; 186  : 	waveOutReset(wav.handle);					//Tell Windows to reset the output device

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	push	eax
	call	DWORD PTR __imp__waveOutReset@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 187  : 
; 188  : 	for (i=0;i<blk.num;i++)					//Unlock memory used by blocks

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@Close
$LN2@Close:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@Close:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $LN1@Close

; 189  : 		waveOutUnprepareHeader(wav.handle,&wav.hdr[i],sizeof(WAVEHDR));

	mov	esi, esp
	push	32					; 00000020H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+212]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	push	edx
	call	DWORD PTR __imp__waveOutUnprepareHeader@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN2@Close
$LN1@Close:

; 190  : 
; 191  : 	waveOutClose(wav.handle);					//Close output device

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	call	DWORD PTR __imp__waveOutClose@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 192  : 
; 193  : 	//if (g_hCfg) WriteStats();
; 194  :   return S_OK;

	xor	eax, eax

; 195  : }

	pop	edi
	pop	esi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Close@WaveOutput@@QAEHXZ ENDP				; WaveOutput::Close
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\wave_output.cpp
_TEXT	SEGMENT
tv224 = -36						; size = 4
tv175 = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
_cfg_direct$ = -20					; size = 4
_cfbufferLen$ = -16					; size = 4
_i$ = -12						; size = 4
_error$ = -8						; size = 4
_this$ = -4						; size = 4
_rate$ = 8						; size = 4
_chn$ = 12						; size = 4
_bits$ = 16						; size = 4
_bufferlenms$ = 20					; size = 4
_prebufferms$ = 24					; size = 4
?Open@WaveOutput@@QAEHHIHHH@Z PROC			; WaveOutput::Open
; _this$ = ecx

; 60   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 	//int8_t	str[256];
; 62   : 	int32_t	error,i;
; 63   : 
; 64   : 
; 65   : 	if (chn>2) return -1;						//No more than stereo

	cmp	DWORD PTR _chn$[ebp], 2
	jbe	SHORT $LN15@Open
	or	eax, -1
	jmp	$LN16@Open
$LN15@Open:

; 66   : 
; 67   : 	if (open) Close();						//Verify device was closed

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN14@Open
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Close@WaveOutput@@QAEHXZ		; WaveOutput::Close
$LN14@Open:

; 68   : 
; 69   : 	//if (cfg.changed)	{
; 70   : 		blk.num=4;//cfg.numBlk;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 4

; 71   : 		blk.min=2*1024;//cfg.minBlk*1024;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 2048		; 00000800H

; 72   : 		blk.max=64*1024;//cfg.maxBlk*1024;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 65536		; 00010000H

; 73   :     SafeDeleteArray(&buffer.pOut);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	push	ecx
	call	??$SafeDeleteArray@X@@YAXPAPAX@Z	; SafeDeleteArray<void>
	add	esp, 4

; 74   :     buffer.pOut= new uint8_t[(blk.num * blk.max)];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	imul	ecx, DWORD PTR [eax+32]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx+96], eax

; 75   :   //}
; 76   : 
; 77   : 	//Build format structure -------------------
; 78   : 	wav.fmt.Format.wFormatTag				= WAVE_FORMAT_EXTENSIBLE;

	mov	ecx, 65534				; 0000fffeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+160], cx

; 79   : 	wav.fmt.Format.nChannels				= chn;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _chn$[ebp]
	mov	WORD PTR [eax+162], cx

; 80   : 	wav.fmt.Format.nSamplesPerSec			= rate;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rate$[ebp]
	mov	DWORD PTR [edx+164], eax

; 81   : 	wav.fmt.Format.wBitsPerSample			= (bits+7)&~7;		//Round bits per sample up to nearest byte

	mov	ecx, DWORD PTR _bits$[ebp]
	add	ecx, 7
	and	ecx, -8					; fffffff8H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+174], cx

; 82   : 	wav.fmt.Format.nBlockAlign			= chn * wav.fmt.Format.wBitsPerSample>>3;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+174]
	imul	ecx, DWORD PTR _chn$[ebp]
	shr	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+172], cx

; 83   : 	wav.fmt.Format.nAvgBytesPerSec		= wav.fmt.Format.nBlockAlign * wav.fmt.Format.nSamplesPerSec;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+172]
	mov	edx, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [edx+164]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+168], ecx

; 84   : 	wav.fmt.Format.cbSize					= 22;

	mov	ecx, 22					; 00000016H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+176], cx

; 85   : 	wav.fmt.Samples.wValidBitsPerSample	= bits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _bits$[ebp]
	mov	WORD PTR [eax+178], cx

; 86   : 	wav.fmt.dwChannelMask					= chn==2 ? 3 : 4;	//Select left & right (stereo) or center (mono)

	cmp	DWORD PTR _chn$[ebp], 2
	jne	SHORT $LN18@Open
	mov	DWORD PTR tv175[ebp], 3
	jmp	SHORT $LN19@Open
$LN18@Open:
	mov	DWORD PTR tv175[ebp], 4
$LN19@Open:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv175[ebp]
	mov	DWORD PTR [edx+180], eax

; 87   : 	wav.fmt.SubFormat						= KSDATAFORMAT_SUBTYPE_PCM;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	mov	edx, DWORD PTR __GUID_00000001_0000_0010_8000_00aa00389b71
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __GUID_00000001_0000_0010_8000_00aa00389b71+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __GUID_00000001_0000_0010_8000_00aa00389b71+8
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __GUID_00000001_0000_0010_8000_00aa00389b71+12
	mov	DWORD PTR [ecx+12], eax

; 88   : 
; 89   :   int cfbufferLen = 2000;

	mov	DWORD PTR _cfbufferLen$[ebp], 2000	; 000007d0H

; 90   : 	//Check size of ring buffer ----------------
; 91   : 	buffer.size=(wav.fmt.Format.nSamplesPerSec *
; 92   : 				wav.fmt.Format.nBlockAlign * 
; 93   : 				cfbufferLen) / 1000;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+172]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, edx
	imul	ecx, DWORD PTR [eax+164]
	imul	ecx, DWORD PTR _cfbufferLen$[ebp]
	mov	eax, ecx
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], eax

; 94   : 
; 95   : 	if (buffer.asize < buffer.size)				//If allocated size is less than needed size

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+52]
	cmp	edx, DWORD PTR [ecx+48]
	jge	SHORT $LN13@Open

; 96   : 	{
; 97   : 		//buffer.pIn=realloc(buffer.pIn,buffer.size);
; 98   :     SafeDeleteArray(&buffer.pIn);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 92					; 0000005cH
	push	eax
	call	??$SafeDeleteArray@X@@YAXPAPAX@Z	; SafeDeleteArray<void>
	add	esp, 4

; 99   :     buffer.pIn = new uint8_t[buffer.size];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+92], ecx

; 100  : 		buffer.asize=buffer.size;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+52], ecx
$LN13@Open:

; 101  : 	}
; 102  : 
; 103  : 	//Open audio device ------------------------
; 104  :   int cfg_direct = 0;//WAVE_FORMAT_DIRECT

	mov	DWORD PTR _cfg_direct$[ebp], 0

; 105  : 	error=waveOutOpen(&wav.handle,device,(tWAVEFORMATEX*)&wav.fmt,DWORD_PTR(WaveOutDone),DWORD_PTR(this),CALLBACK_FUNCTION|WAVE_ALLOWSYNC|cfg_direct);

	mov	edx, DWORD PTR _cfg_direct$[ebp]
	or	edx, 196610				; 00030002H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	OFFSET ?WaveOutDone@WaveOutput@@KGXPAUHWAVEOUT__@@IKPAUwavehdr_tag@@K@Z ; WaveOutput::WaveOutDone
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	push	ecx
	call	DWORD PTR __imp__waveOutOpen@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _error$[ebp], eax

; 106  : 	switch (error)

	mov	edx, DWORD PTR _error$[ebp]
	mov	DWORD PTR tv224[ebp], edx
	cmp	DWORD PTR tv224[ebp], 0
	je	SHORT $LN10@Open
	jmp	$LN11@Open
$LN10@Open:

; 107  : 	{
; 108  : 	case(MMSYSERR_NOERROR):
; 109  : 		wav.idle=(uint32_t)~0>>(32-blk.num);		//All blocks are free

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR [eax+24]
	or	edx, -1
	shr	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+724], edx

; 110  : 
; 111  : 		//Initialize wave blocks ---------------
; 112  : 		for (i=0;i<blk.num;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Open
$LN8@Open:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN9@Open:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	$LN7@Open

; 113  : 		{
; 114  : 			memset(&wav.hdr[i],0,sizeof(WAVEHDR));

	push	32					; 00000020H
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+212]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 115  : 
; 116  : 			wav.hdr[i].lpData=(LPSTR)buffer.pOut+(blk.max*i);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	imul	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+96]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+ecx+212], edx

; 117  : 			wav.hdr[i].dwBufferLength=blk.max;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+ecx+216], eax

; 118  : 			waveOutPrepareHeader(wav.handle,&wav.hdr[i],sizeof(WAVEHDR));

	mov	esi, esp
	push	32					; 00000020H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+212]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	push	edx
	call	DWORD PTR __imp__waveOutPrepareHeader@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 119  : 
; 120  : 			wav.hdr[i].dwBufferLength=0;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+216], 0

; 121  : 			wav.hdr[i].dwUser=(DWORD_PTR)(1<<i);			//Bit corresponding to block

	mov	edx, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+224], edx

; 122  : 			wav.hdr[i].dwFlags|=WHDR_DONE;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+228]
	or	ecx, 1
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+228], ecx

; 123  : 		}

	jmp	$LN8@Open
$LN7@Open:

; 124  : 
; 125  : 		memset(&wav.time,0,sizeof(MMTIME));

	push	12					; 0000000cH
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 126  : 		wav.time.wType=TIME_SAMPLES;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+200], 2

; 127  : 		wav.samples=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+728], 0
	mov	DWORD PTR [eax+732], 0

; 128  : 		wav.smpCnt=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+748], 0

; 129  : 
; 130  : 		buffer.bytes=0;							//No bytes have been written

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 0
	mov	DWORD PTR [edx+68], 0

; 131  : 
; 132  : 		buffer.length=0;							//Nothing is in input buffer

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0

; 133  : 		buffer.queued_length=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 0

; 134  : 		buffer.write=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 0

; 135  : 		buffer.read=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 136  : 
; 137  : 		blk.cnt=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 138  : 		blk.size=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0
	mov	DWORD PTR [edx+44], 0

; 139  : 
; 140  : 		paused=0;								//Output isn't paused

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 141  : 		open=1;								//Device is open

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 1

; 142  : 
; 143  : 		return ((buffer.size / wav.fmt.Format.nBlockAlign) * 1000) / wav.fmt.Format.nSamplesPerSec;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [edx+172]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	cdq
	idiv	ecx
	imul	eax, 1000				; 000003e8H
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+164]
	jmp	SHORT $LN16@Open
$LN11@Open:

; 144  : 
; 145  : 	case(MMSYSERR_ALLOCATED):
; 146  : 		//sprintf(str,"%s is already in use",wav.cap.szPname);
; 147  : 		//MessageBox(outMod.hMainWindow,str,"WaveOut WDM",MB_ICONERROR|MB_OK);
; 148  : 		break;
; 149  : 
; 150  : 	case(MMSYSERR_BADDEVICEID):
; 151  : 		//sprintf(str,"Invalid output device ID [%i].  Check your configuration.",cfg.device);
; 152  : 		//MessageBox(outMod.hMainWindow,str,"WaveOut WDM",MB_ICONERROR|MB_OK);
; 153  : 		break;
; 154  : 
; 155  : 	case(MMSYSERR_NODRIVER):
; 156  : 		//sprintf(str,"No driver is loaded for %s",wav.cap.szPname);
; 157  : 		//MessageBox(outMod.hMainWindow,str,"WaveOut WDM",MB_ICONERROR|MB_OK);
; 158  : 		break;
; 159  : 
; 160  : 	case(MMSYSERR_NOMEM):
; 161  : 		//MessageBox(outMod.hMainWindow,"Unable to allocate memory for output device","WaveOut WDM",MB_ICONERROR|MB_OK);
; 162  : 		break;
; 163  : 
; 164  : 	case(WAVERR_BADFORMAT):
; 165  : 		//MessageBox(outMod.hMainWindow,"The extensible format is not supported by your driver.  Get the WDM drivers for your soundcard.","WaveOut WDM",MB_ICONERROR|MB_OK);
; 166  : 		break;
; 167  : 
; 168  : 	default:
; 169  : 		//sprintf(str,"Unknown error [%i] trying to open output device %s",error,wav.cap.szPname);
; 170  : 		//MessageBox(outMod.hMainWindow,str,"WaveOut WDM",MB_ICONERROR|MB_OK);
; 171  :     break;
; 172  : 	}
; 173  : 
; 174  : 	return S_FALSE;

	mov	eax, 1
$LN16@Open:

; 175  : }

	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?Open@WaveOutput@@QAEHHIHHH@Z ENDP			; WaveOutput::Open
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\wave_output.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Deinitialize@WaveOutput@@QAEHXZ PROC			; WaveOutput::Deinitialize
; _this$ = ecx

; 52   : int WaveOutput::Deinitialize() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 53   : 	if (open) Close();						//Close output device, incase someone forgot to

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Deinitiali
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Close@WaveOutput@@QAEHXZ		; WaveOutput::Close
$LN1@Deinitiali:

; 54   : 	SafeDeleteArray(&buffer.pOut);							//Free up allocated memory

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	push	ecx
	call	??$SafeDeleteArray@X@@YAXPAPAX@Z	; SafeDeleteArray<void>
	add	esp, 4

; 55   : 	SafeDeleteArray(&buffer.pIn);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	push	edx
	call	??$SafeDeleteArray@X@@YAXPAPAX@Z	; SafeDeleteArray<void>
	add	esp, 4

; 56   :   return S_OK;

	xor	eax, eax

; 57   : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Deinitialize@WaveOutput@@QAEHXZ ENDP			; WaveOutput::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\wave_output.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Initialize@WaveOutput@@QAEHXZ PROC			; WaveOutput::Initialize
; _this$ = ecx

; 48   : int WaveOutput::Initialize() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 49   :   return S_OK;

	xor	eax, eax

; 50   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Initialize@WaveOutput@@QAEHXZ ENDP			; WaveOutput::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\wave_output.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1WaveOutput@@QAE@XZ PROC				; WaveOutput::~WaveOutput
; _this$ = ecx

; 44   : WaveOutput::~WaveOutput() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 
; 46   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1WaveOutput@@QAE@XZ ENDP				; WaveOutput::~WaveOutput
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\wave_output.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0WaveOutput@@QAE@XZ PROC				; WaveOutput::WaveOutput
; _this$ = ecx

; 23   : WaveOutput::WaveOutput() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 24   : 
; 25   : 	//Initialize variables --------------------
; 26   : 	memset(&wav.time,0,sizeof(MMTIME));		//Erase time structure

	push	12					; 0000000cH
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 200				; 000000c8H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 27   : 	wav.time.wType=TIME_SAMPLES;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+200], 2

; 28   : 	wav.samples=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+728], 0
	mov	DWORD PTR [edx+732], 0

; 29   : 	wav.ttime=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+744], 0

; 30   :   device=WAVE_MAPPER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], -1

; 31   : 	buffer.asize=0;								//No buffers have been allocated

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 0

; 32   : 	buffer.pIn=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], 0

; 33   : 	buffer.pOut=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+96], 0

; 34   : 	buffer.total_bytes=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+72], 0
	mov	DWORD PTR [edx+76], 0

; 35   : 	buffer.total_time=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 0

; 36   : 
; 37   : 	paused=0;									//Output isn't paused

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 38   : 	open=0;									//Device isn't open

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 39   : 
; 40   : 	vol=255;									//Full volume

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 255			; 000000ffH

; 41   : 	pan=0;									//Center balance

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 42   : }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0WaveOutput@@QAE@XZ ENDP				; WaveOutput::WaveOutput
_TEXT	ENDS
END
