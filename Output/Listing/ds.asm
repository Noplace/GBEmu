; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

	TITLE	C:\Users\Khalid\Documents\GitHub\GBEmu\Solution\Code\audio\ds.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??0AudioInterface@audio@@QAE@XZ			; audio::AudioInterface::AudioInterface
PUBLIC	??0DirectSound@audio@@QAE@XZ			; audio::DirectSound::DirectSound
PUBLIC	??1DirectSound@audio@@QAE@XZ			; audio::DirectSound::~DirectSound
PUBLIC	?Initialize@DirectSound@audio@@UAEHIEE@Z	; audio::DirectSound::Initialize
PUBLIC	?Deinitialize@DirectSound@audio@@UAEHXZ		; audio::DirectSound::Deinitialize
PUBLIC	?Write@DirectSound@audio@@UAEHPAXI@Z		; audio::DirectSound::Write
PUBLIC	?RestoreBuffer@@YAHPAUIDirectSoundBuffer@@@Z	; RestoreBuffer
PUBLIC	?AppWriteDataToBuffer@@YAHPAUIDirectSoundBuffer@@KPAEK@Z ; AppWriteDataToBuffer
PUBLIC	??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z ; SafeRelease<IDirectSoundBuffer>
PUBLIC	??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z ; SafeRelease<IDirectSound8>
PUBLIC	??_7AudioInterface@audio@@6B@			; audio::AudioInterface::`vftable'
PUBLIC	??_7DirectSound@audio@@6B@			; audio::DirectSound::`vftable'
PUBLIC	??_R4AudioInterface@audio@@6B@			; audio::AudioInterface::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVAudioInterface@audio@@@8		; audio::AudioInterface `RTTI Type Descriptor'
PUBLIC	??_R3AudioInterface@audio@@8			; audio::AudioInterface::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AudioInterface@audio@@8			; audio::AudioInterface::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@AudioInterface@audio@@8		; audio::AudioInterface::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4DirectSound@audio@@6B@			; audio::DirectSound::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDirectSound@audio@@@8			; audio::DirectSound `RTTI Type Descriptor'
PUBLIC	??_R3DirectSound@audio@@8			; audio::DirectSound::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DirectSound@audio@@8			; audio::DirectSound::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DirectSound@audio@@8		; audio::DirectSound::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	_DirectSoundCreate8@12:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memset:PROC
EXTRN	_DSDEVID_DefaultPlayback:BYTE
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@DirectSound@audio@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DirectSound@audio@@8 DD FLAT:??_R0?AVDirectSound@audio@@@8 ; audio::DirectSound::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DirectSound@audio@@8
rdata$r	ENDS
;	COMDAT ??_R2DirectSound@audio@@8
rdata$r	SEGMENT
??_R2DirectSound@audio@@8 DD FLAT:??_R1A@?0A@EA@DirectSound@audio@@8 ; audio::DirectSound::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@AudioInterface@audio@@8
rdata$r	ENDS
;	COMDAT ??_R3DirectSound@audio@@8
rdata$r	SEGMENT
??_R3DirectSound@audio@@8 DD 00H			; audio::DirectSound::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2DirectSound@audio@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDirectSound@audio@@@8
_DATA	SEGMENT
??_R0?AVDirectSound@audio@@@8 DD FLAT:??_7type_info@@6B@ ; audio::DirectSound `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDirectSound@audio@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DirectSound@audio@@6B@
rdata$r	SEGMENT
??_R4DirectSound@audio@@6B@ DD 00H			; audio::DirectSound::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDirectSound@audio@@@8
	DD	FLAT:??_R3DirectSound@audio@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@AudioInterface@audio@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AudioInterface@audio@@8 DD FLAT:??_R0?AVAudioInterface@audio@@@8 ; audio::AudioInterface::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AudioInterface@audio@@8
rdata$r	ENDS
;	COMDAT ??_R2AudioInterface@audio@@8
rdata$r	SEGMENT
??_R2AudioInterface@audio@@8 DD FLAT:??_R1A@?0A@EA@AudioInterface@audio@@8 ; audio::AudioInterface::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3AudioInterface@audio@@8
rdata$r	SEGMENT
??_R3AudioInterface@audio@@8 DD 00H			; audio::AudioInterface::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2AudioInterface@audio@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAudioInterface@audio@@@8
_DATA	SEGMENT
??_R0?AVAudioInterface@audio@@@8 DD FLAT:??_7type_info@@6B@ ; audio::AudioInterface `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAudioInterface@audio@@', 00H
_DATA	ENDS
;	COMDAT ??_R4AudioInterface@audio@@6B@
rdata$r	SEGMENT
??_R4AudioInterface@audio@@6B@ DD 00H			; audio::AudioInterface::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVAudioInterface@audio@@@8
	DD	FLAT:??_R3AudioInterface@audio@@8
rdata$r	ENDS
;	COMDAT ??_7DirectSound@audio@@6B@
CONST	SEGMENT
??_7DirectSound@audio@@6B@ DD FLAT:??_R4DirectSound@audio@@6B@ ; audio::DirectSound::`vftable'
	DD	FLAT:?Initialize@DirectSound@audio@@UAEHIEE@Z
	DD	FLAT:?Deinitialize@DirectSound@audio@@UAEHXZ
	DD	FLAT:?Write@DirectSound@audio@@UAEHPAXI@Z
CONST	ENDS
;	COMDAT ??_7AudioInterface@audio@@6B@
CONST	SEGMENT
??_7AudioInterface@audio@@6B@ DD FLAT:??_R4AudioInterface@audio@@6B@ ; audio::AudioInterface::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\wincore\types.h
;	COMDAT ??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z
_TEXT	SEGMENT
_ppInterfaceToRelease$ = 8				; size = 4
??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z PROC ; SafeRelease<IDirectSound8>, COMDAT

; 27   : inline void SafeRelease(Interface **ppInterfaceToRelease) {

	push	ebp
	mov	ebp, esp
	push	esi

; 28   :     if (*ppInterfaceToRelease != NULL) {

	mov	eax, DWORD PTR _ppInterfaceToRelease$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SafeReleas

; 29   :         (*ppInterfaceToRelease)->Release();

	mov	ecx, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 30   :         (*ppInterfaceToRelease) = NULL;

	mov	ecx, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	DWORD PTR [ecx], 0
$LN2@SafeReleas:

; 31   :     }
; 32   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z ENDP ; SafeRelease<IDirectSound8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\wincore\types.h
;	COMDAT ??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z
_TEXT	SEGMENT
_ppInterfaceToRelease$ = 8				; size = 4
??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z PROC ; SafeRelease<IDirectSoundBuffer>, COMDAT

; 27   : inline void SafeRelease(Interface **ppInterfaceToRelease) {

	push	ebp
	mov	ebp, esp
	push	esi

; 28   :     if (*ppInterfaceToRelease != NULL) {

	mov	eax, DWORD PTR _ppInterfaceToRelease$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SafeReleas

; 29   :         (*ppInterfaceToRelease)->Release();

	mov	ecx, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 30   :         (*ppInterfaceToRelease) = NULL;

	mov	ecx, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	DWORD PTR [ecx], 0
$LN2@SafeReleas:

; 31   :     }
; 32   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z ENDP ; SafeRelease<IDirectSoundBuffer>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\ds.cpp
_TEXT	SEGMENT
_a$1 = -56						; size = 4
_hr$ = -52						; size = 4
_dwBytes2$ = -44					; size = 4
_lpvPtr2$ = -32						; size = 4
_dwBytes1$ = -20					; size = 4
_lpvPtr1$ = -8						; size = 4
_lpDsb$ = 8						; size = 4
_dwOffset$ = 12						; size = 4
_lpbSoundData$ = 16					; size = 4
_dwSoundBytes$ = 20					; size = 4
?AppWriteDataToBuffer@@YAHPAUIDirectSoundBuffer@@KPAEK@Z PROC ; AppWriteDataToBuffer

; 36   :     { 

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 37   :       LPVOID  lpvPtr1; 
; 38   :       DWORD dwBytes1; 
; 39   :       LPVOID  lpvPtr2; 
; 40   :       DWORD dwBytes2; 
; 41   :       HRESULT hr; 
; 42   :      
; 43   :       // Obtain memory address of write block. This will be in two parts
; 44   :       // if the block wraps around.
; 45   :      
; 46   :       hr = lpDsb->Lock(dwOffset, dwSoundBytes, &lpvPtr1, 
; 47   :           &dwBytes1, &lpvPtr2, &dwBytes2, 0); 

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _dwBytes2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpvPtr2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwBytes1$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpvPtr1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwSoundBytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwOffset$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDsb$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _lpDsb$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+44]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 48   :      
; 49   :       // If the buffer was lost, restore and retry lock. 
; 50   :       if (hr == DSERR_PRIOLEVELNEEDED) {

	cmp	DWORD PTR _hr$[ebp], -2005401530	; 88780046H
	jne	SHORT $LN5@AppWriteDa

; 51   :         int a= 1;

	mov	DWORD PTR _a$1[ebp], 1
$LN5@AppWriteDa:

; 52   :       }
; 53   :       if (DSERR_BUFFERLOST == hr) 

	cmp	DWORD PTR _hr$[ebp], -2005401450	; 88780096H
	jne	SHORT $LN4@AppWriteDa

; 54   :       { 
; 55   :         lpDsb->Restore(); 

	mov	ecx, DWORD PTR _lpDsb$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	eax, DWORD PTR _lpDsb$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+80]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 56   :         hr = lpDsb->Lock(dwOffset, dwSoundBytes, 
; 57   :             &lpvPtr1, &dwBytes1,
; 58   :             &lpvPtr2, &dwBytes2, 0); 

	mov	esi, esp
	push	0
	lea	edx, DWORD PTR _dwBytes2$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpvPtr2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwBytes1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpvPtr1$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwSoundBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwOffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDsb$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _lpDsb$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+44]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
$LN4@AppWriteDa:

; 59   :       } 
; 60   :       if (SUCCEEDED(hr)) 

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN3@AppWriteDa

; 61   :       { 
; 62   :         // Write to pointers. 
; 63   :      
; 64   :         CopyMemory(lpvPtr1, lpbSoundData, dwBytes1); 

	mov	eax, DWORD PTR _dwBytes1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpbSoundData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvPtr1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 65   :         if (NULL != lpvPtr2) 

	cmp	DWORD PTR _lpvPtr2$[ebp], 0
	je	SHORT $LN2@AppWriteDa

; 66   :         { 
; 67   :           CopyMemory(lpvPtr2, lpbSoundData+dwBytes1, dwBytes2); 

	mov	eax, DWORD PTR _dwBytes2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpbSoundData$[ebp]
	add	ecx, DWORD PTR _dwBytes1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvPtr2$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN2@AppWriteDa:

; 68   :         } 
; 69   :      
; 70   :         // Release the data back to DirectSound. 
; 71   :      
; 72   :         hr = lpDsb->Unlock(lpvPtr1, dwBytes1, lpvPtr2, 
; 73   :         dwBytes2); 

	mov	esi, esp
	mov	eax, DWORD PTR _dwBytes2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvPtr2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwBytes1$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvPtr1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDsb$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpDsb$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+76]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 74   :         if (SUCCEEDED(hr)) 

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN3@AppWriteDa

; 75   :         { 
; 76   :           // Success. 
; 77   :           return TRUE; 

	mov	eax, 1
	jmp	SHORT $LN6@AppWriteDa
$LN3@AppWriteDa:

; 78   :         } 
; 79   :       } 
; 80   :      
; 81   :       // Lock, Unlock, or Restore failed. 
; 82   :      
; 83   :       return FALSE; 

	xor	eax, eax
$LN6@AppWriteDa:

; 84   :     } 

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@AppWriteDa
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@AppWriteDa:
	DD	4
	DD	$LN12@AppWriteDa
$LN12@AppWriteDa:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN8@AppWriteDa
	DD	-20					; ffffffecH
	DD	4
	DD	$LN9@AppWriteDa
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN10@AppWriteDa
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN11@AppWriteDa
$LN11@AppWriteDa:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	50					; 00000032H
	DB	0
$LN10@AppWriteDa:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	118					; 00000076H
	DB	80					; 00000050H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	50					; 00000032H
	DB	0
$LN9@AppWriteDa:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	49					; 00000031H
	DB	0
$LN8@AppWriteDa:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	118					; 00000076H
	DB	80					; 00000050H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	49					; 00000031H
	DB	0
?AppWriteDataToBuffer@@YAHPAUIDirectSoundBuffer@@KPAEK@Z ENDP ; AppWriteDataToBuffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\ds.cpp
_TEXT	SEGMENT
_dwStatus$ = -16					; size = 4
_pbWasRestored$ = -8					; size = 4
_hr$ = -4						; size = 4
_pDSB$ = 8						; size = 4
?RestoreBuffer@@YAHPAUIDirectSoundBuffer@@@Z PROC	; RestoreBuffer

; 8    : BOOL RestoreBuffer( LPDIRECTSOUNDBUFFER pDSB )	{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 9    : 		HRESULT hr;
; 10   :     BOOL pbWasRestored=false;

	mov	DWORD PTR _pbWasRestored$[ebp], 0

; 11   : 	
; 12   : 		DWORD dwStatus;
; 13   : 		pDSB->GetStatus( &dwStatus );    

	mov	esi, esp
	lea	eax, DWORD PTR _dwStatus$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDSB$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pDSB$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+36]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14   : 
; 15   : 		if( dwStatus & DSBSTATUS_BUFFERLOST )

	mov	edx, DWORD PTR _dwStatus$[ebp]
	and	edx, 2
	je	SHORT $LN5@RestoreBuf
$LN4@RestoreBuf:

; 16   : 		{
; 17   : 			do 
; 18   : 			{
; 19   : 				hr = pDSB->Restore();

	mov	eax, DWORD PTR _pDSB$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pDSB$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+80]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 20   : 				if( hr == DSERR_BUFFERLOST )

	cmp	DWORD PTR _hr$[ebp], -2005401450	; 88780096H
	jne	SHORT $LN3@RestoreBuf

; 21   : 					Sleep( 10 );

	mov	esi, esp
	push	10					; 0000000aH
	call	DWORD PTR __imp__Sleep@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@RestoreBuf:

; 22   : 			}
; 23   : 			while( ( pDSB->Restore() ) == DSERR_BUFFERLOST );

	mov	ecx, DWORD PTR _pDSB$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	eax, DWORD PTR _pDSB$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+80]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, -2005401450			; 88780096H
	je	SHORT $LN4@RestoreBuf

; 24   : 
; 25   : 			pbWasRestored = true;

	mov	DWORD PTR _pbWasRestored$[ebp], 1
$LN5@RestoreBuf:

; 26   : 		}
; 27   :     return pbWasRestored;

	mov	eax, DWORD PTR _pbWasRestored$[ebp]

; 28   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@RestoreBuf
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@RestoreBuf:
	DD	1
	DD	$LN9@RestoreBuf
$LN9@RestoreBuf:
	DD	-16					; fffffff0H
	DD	4
	DD	$LN8@RestoreBuf
$LN8@RestoreBuf:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	0
?RestoreBuffer@@YAHPAUIDirectSoundBuffer@@@Z ENDP	; RestoreBuffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\ds.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_data$ = 8						; size = 4
_size$ = 12						; size = 4
?Write@DirectSound@audio@@UAEHPAXI@Z PROC		; audio::DirectSound::Write
; _this$ = ecx

; 160  : int DirectSound::Write(void* data, size_t size) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 161  :   //BYTE* buffer_data;
; 162  :  // DWORD locked_size;
; 163  :   RestoreBuffer(encapsulated->secondary_buffer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	?RestoreBuffer@@YAHPAUIDirectSoundBuffer@@@Z ; RestoreBuffer
	add	esp, 4

; 164  :   if (written_bytes + size > AUDIO_BUFFER_SIZE) {
; 165  :     //do something
; 166  :   }
; 167  : 
; 168  :   memcpy(&audio_data[written_bytes],data,size);

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+40]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 169  :   written_bytes += size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], edx

; 170  :   if (written_bytes >= AUDIO_BUFFER_SIZE) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+40], 1024		; 00000400H
	jb	SHORT $LN3@Write

; 171  :     written_bytes = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0

; 172  : 
; 173  :     if (AppWriteDataToBuffer(this->encapsulated->secondary_buffer,offset_,audio_data,AUDIO_BUFFER_SIZE)==TRUE)

	push	1024					; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?AppWriteDataToBuffer@@YAHPAUIDirectSoundBuffer@@KPAEK@Z ; AppWriteDataToBuffer
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jne	SHORT $LN2@Write

; 174  :       offset_ += AUDIO_BUFFER_SIZE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, 1024				; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], edx
$LN2@Write:

; 175  : 
; 176  : 		/*secondary_buffer->Lock(offset, AUDIO_BUFFER_SIZE, (LPVOID*)&buffer_data, &locked_size, NULL, 0, 0);
; 177  : 		memcpy(buffer_data, audio_data, locked_size);
; 178  : 		secondary_buffer->Unlock(buffer_data, locked_size, NULL, 0);*/
; 179  :     //offset += AUDIO_BUFFER_SIZE;
; 180  :     if (offset_ == BUFFER_SIZE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+36], 10240		; 00002800H
	jne	SHORT $LN3@Write

; 181  :       offset_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 0
$LN3@Write:

; 182  :   }
; 183  : 
; 184  : 
; 185  :   
; 186  :   /*
; 187  :   
; 188  :   primary_buffer->Lock(written_bytes,bytes, (LPVOID*)&buffer_data, &locked_size, NULL, NULL, 0L); 
; 189  :   memcpy(buffer_data,data,bytes);
; 190  :   primary_buffer->Unlock(buffer_data,locked_size,null,null);
; 191  :   written_bytes += bytes;*/
; 192  : 
; 193  : 
; 194  :   //if (AppWriteDataToBuffer(secondary_buffer,written_bytes,(LPBYTE)data,bytes)==TRUE) 
; 195  :   //  written_bytes += bytes;
; 196  : 
; 197  :  
; 198  : 
; 199  :   return S_OK;

	xor	eax, eax

; 200  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Write@DirectSound@audio@@UAEHPAXI@Z ENDP		; audio::DirectSound::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\ds.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?Deinitialize@DirectSound@audio@@UAEHXZ PROC		; audio::DirectSound::Deinitialize
; _this$ = ecx

; 150  : int DirectSound::Deinitialize() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 151  :   encapsulated->secondary_buffer->Stop();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [edx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+72]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 152  :   encapsulated->primary_buffer->Stop();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+72]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 153  :   SafeRelease(&encapsulated->secondary_buffer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 8
	push	ecx
	call	??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z ; SafeRelease<IDirectSoundBuffer>
	add	esp, 4

; 154  :   SafeRelease(&encapsulated->primary_buffer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 4
	push	eax
	call	??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z ; SafeRelease<IDirectSoundBuffer>
	add	esp, 4

; 155  :   SafeRelease(&encapsulated->ds8);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z ; SafeRelease<IDirectSound8>
	add	esp, 4

; 156  :   delete [] audio_data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 157  :   return S_OK;

	xor	eax, eax

; 158  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Deinitialize@DirectSound@audio@@UAEHXZ ENDP		; audio::DirectSound::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\ds.cpp
_TEXT	SEGMENT
$T1 = -60						; size = 4
_dsbd$ = -52						; size = 36
_hr$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_sample_rate$ = 8					; size = 4
_channels$ = 12						; size = 1
_bits$ = 16						; size = 1
?Initialize@DirectSound@audio@@UAEHIEE@Z PROC		; audio::DirectSound::Initialize
; _this$ = ecx

; 102  : int DirectSound::Initialize(uint32_t sample_rate, uint8_t channels, uint8_t bits) {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 103  :   audio_data = new BYTE[AUDIO_BUFFER_SIZE];

	push	1024					; 00000400H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+24], ecx

; 104  :   HRESULT hr = DirectSoundCreate8(&DSDEVID_DefaultPlayback,&encapsulated->ds8,nullptr);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	push	OFFSET _DSDEVID_DefaultPlayback
	call	_DirectSoundCreate8@12
	mov	DWORD PTR _hr$[ebp], eax

; 105  :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN8@Initialize
	mov	eax, 1
	jmp	$LN9@Initialize
$LN8@Initialize:

; 106  :   hr = encapsulated->ds8->SetCooperativeLevel((HWND)window_handle_,DSSCL_PRIORITY);

	mov	esi, esp
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	push	eax
	mov	edx, DWORD PTR [ecx+24]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 107  :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN7@Initialize
	mov	eax, 1
	jmp	$LN9@Initialize
$LN7@Initialize:

; 108  :   DSBUFFERDESC dsbd;
; 109  : 	ZeroMemory( &dsbd, sizeof(DSBUFFERDESC) );

	push	36					; 00000024H
	push	0
	lea	eax, DWORD PTR _dsbd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 110  : 	dsbd.dwSize        = sizeof(DSBUFFERDESC);

	mov	DWORD PTR _dsbd$[ebp], 36		; 00000024H

; 111  : 	dsbd.dwFlags       =   DSBCAPS_PRIMARYBUFFER;

	mov	DWORD PTR _dsbd$[ebp+4], 1

; 112  : 	dsbd.dwBufferBytes = 0;

	mov	DWORD PTR _dsbd$[ebp+8], 0

; 113  : 	dsbd.lpwfxFormat   = NULL;

	mov	DWORD PTR _dsbd$[ebp+16], 0

; 114  : 
; 115  : 
; 116  : 	hr = encapsulated->ds8->CreateSoundBuffer( &dsbd,&encapsulated->primary_buffer, NULL ) ;

	mov	esi, esp
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 4
	push	edx
	lea	eax, DWORD PTR _dsbd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 117  :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN6@Initialize
	mov	eax, 1
	jmp	$LN9@Initialize
$LN6@Initialize:

; 118  : 
; 119  : 	ZeroMemory( &wave_format_, sizeof(WAVEFORMATEX) ); 

	push	18					; 00000012H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 120  : 	wave_format_.wFormatTag      = (WORD) WAVE_FORMAT_PCM; 

	mov	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+4], dx

; 121  : 	wave_format_.nChannels       =  channels; 

	movzx	cx, BYTE PTR _channels$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+6], cx

; 122  : 	wave_format_.nSamplesPerSec  = sample_rate; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _sample_rate$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 123  : 	wave_format_.wBitsPerSample  = (WORD) bits; 

	movzx	dx, BYTE PTR _bits$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+18], dx

; 124  : 	wave_format_.nBlockAlign     = (WORD) (wave_format_.wBitsPerSample / 8 * wave_format_.nChannels);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [ecx+18]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [edx+6]
	imul	eax, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+16], ax

; 125  : 	wave_format_.nAvgBytesPerSec = (DWORD) (wave_format_.nSamplesPerSec * wave_format_.nBlockAlign);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 126  :   wave_format_.cbSize = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], cx

; 127  : 	hr = encapsulated->primary_buffer->SetFormat(&wave_format_);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	eax, DWORD PTR [edx+56]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 128  :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN5@Initialize
	mov	eax, 1
	jmp	$LN9@Initialize
$LN5@Initialize:

; 129  :   hr = encapsulated->primary_buffer->Play(0,0,DSBPLAY_LOOPING);

	mov	esi, esp
	push	1
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 130  :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN4@Initialize
	mov	eax, 1
	jmp	$LN9@Initialize
$LN4@Initialize:

; 131  : 
; 132  : 	ZeroMemory( &dsbd, sizeof(DSBUFFERDESC) );

	push	36					; 00000024H
	push	0
	lea	ecx, DWORD PTR _dsbd$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 133  : 	dsbd.dwSize        = sizeof(DSBUFFERDESC);

	mov	DWORD PTR _dsbd$[ebp], 36		; 00000024H

; 134  : 	dsbd.dwFlags       =   DSBCAPS_LOCSOFTWARE | DSBCAPS_GETCURRENTPOSITION2;;

	mov	DWORD PTR _dsbd$[ebp+4], 65544		; 00010008H

; 135  : 	dsbd.dwBufferBytes = BUFFER_SIZE;//(wfx.nAvgBytesPerSec / 50)*4;

	mov	DWORD PTR _dsbd$[ebp+8], 10240		; 00002800H

; 136  : 	dsbd.lpwfxFormat   = &wave_format_;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR _dsbd$[ebp+16], edx

; 137  :   // Create a temporary sound buffer with the specific buffer settings.
; 138  : 	hr = encapsulated->ds8->CreateSoundBuffer(&dsbd, &encapsulated->secondary_buffer, NULL);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 8
	push	ecx
	lea	edx, DWORD PTR _dsbd$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	push	eax
	mov	edx, DWORD PTR [ecx+12]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 139  :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN3@Initialize
	mov	eax, 1
	jmp	$LN9@Initialize
$LN3@Initialize:

; 140  : 
; 141  :   buffer_size = dsbd.dwBufferBytes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dsbd$[ebp+8]
	mov	DWORD PTR [eax+44], ecx

; 142  :   written_bytes = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0

; 143  :   hr = encapsulated->secondary_buffer->Play(0,0,DSBPLAY_LOOPING);

	mov	esi, esp
	push	1
	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [edx]
	push	eax
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 144  :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN2@Initialize
	mov	eax, 1
	jmp	SHORT $LN9@Initialize
$LN2@Initialize:

; 145  :   hr = encapsulated->primary_buffer->SetVolume(DSBVOLUME_MAX);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx]
	push	eax
	mov	edx, DWORD PTR [ecx+60]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 146  :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Initialize
	mov	eax, 1
	jmp	SHORT $LN9@Initialize
$LN1@Initialize:

; 147  :   return S_OK;

	xor	eax, eax
$LN9@Initialize:

; 148  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@Initialize
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN13@Initialize:
	DD	1
	DD	$LN12@Initialize
$LN12@Initialize:
	DD	-52					; ffffffccH
	DD	36					; 00000024H
	DD	$LN11@Initialize
$LN11@Initialize:
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	98					; 00000062H
	DB	100					; 00000064H
	DB	0
?Initialize@DirectSound@audio@@UAEHIEE@Z ENDP		; audio::DirectSound::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\ds.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1DirectSound@audio@@QAE@XZ PROC			; audio::DirectSound::~DirectSound
; _this$ = ecx

; 98   : DirectSound::~DirectSound() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DirectSound@audio@@6B@

; 99   :   delete encapsulated;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 100  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1DirectSound@audio@@QAE@XZ ENDP			; audio::DirectSound::~DirectSound
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\ds.cpp
_TEXT	SEGMENT
tv80 = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
??0DirectSound@audio@@QAE@XZ PROC			; audio::DirectSound::DirectSound
; _this$ = ecx

; 94   : DirectSound::DirectSound() : window_handle_(nullptr), offset_(0) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0AudioInterface@audio@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DirectSound@audio@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 0

; 95   :   encapsulated = new HiddenMembers();

	mov	DWORD PTR $T2[ebp], 12			; 0000000cH
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@DirectSoun
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN4@DirectSoun
$LN3@DirectSoun:
	mov	DWORD PTR tv80[ebp], 0
$LN4@DirectSoun:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR [ecx+28], edx

; 96   : }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0DirectSound@audio@@QAE@XZ ENDP			; audio::DirectSound::DirectSound
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0AudioInterface@audio@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0AudioInterface@audio@@QAE@XZ PROC			; audio::AudioInterface::AudioInterface, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7AudioInterface@audio@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0AudioInterface@audio@@QAE@XZ ENDP			; audio::AudioInterface::AudioInterface
_TEXT	ENDS
END
