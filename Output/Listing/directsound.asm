; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

	TITLE	C:\Users\Khalid\Documents\GitHub\GBEmu\Solution\Code\audio\directsound.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?value@?$integral_constant@H$0A@@std@@2HB	; std::integral_constant<int,0>::value
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
PUBLIC	?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
PUBLIC	?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_nonNull
PUBLIC	?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelException
PUBLIC	?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_notInlined
PUBLIC	?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_structured
PUBLIC	?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_localCancel
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_reserved
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
PUBLIC	?value@?$_Abs@$0JIJGIA@@std@@2_JB		; std::_Abs<10000000>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB		; std::_GcdX<10000000,0>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_GcdX<10000000,10000000>::value
PUBLIC	?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Gcd<10000000,10000000>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?num@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::num
PUBLIC	?den@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::den
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?is_monotonic@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_monotonic
PUBLIC	?is_steady@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_steady
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	_ConcRT_ProviderGuid
PUBLIC	_ConcRTEventGuid
PUBLIC	_SchedulerEventGuid
PUBLIC	_ScheduleGroupEventGuid
PUBLIC	_ContextEventGuid
PUBLIC	_ChoreEventGuid
PUBLIC	_VirtualProcessorEventGuid
PUBLIC	_LockEventGuid
PUBLIC	_ResourceManagerEventGuid
PUBLIC	_PPLParallelInvokeEventGuid
PUBLIC	_PPLParallelForEventGuid
PUBLIC	_PPLParallelForeachEventGuid
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
PUBLIC	_AgentEventGuid
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB		; std::_GcdX<10000000,1>::value
PUBLIC	?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB		; std::_GcdX<1,10000000>::value
PUBLIC	?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB		; std::_Gcd<1,10000000>::value
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?num@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::num
PUBLIC	?den@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::den
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?value@?$_Abs@$0GE@@std@@2_JB			; std::_Abs<100>::value
PUBLIC	?value@?$_Abs@$0DLJKMKAA@@std@@2_JB		; std::_Abs<1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?value@?$_GcdX@$0GE@$0A@@std@@2_JB		; std::_GcdX<100,0>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB	; std::_GcdX<1000000000,100>::value
PUBLIC	?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
PUBLIC	?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
PUBLIC	?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<100,1000000000>::value
PUBLIC	?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
PUBLIC	?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
PUBLIC	?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<100,1000000000>::value
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?value@?$_Abs@$00@std@@2_JB			; std::_Abs<1>::value
PUBLIC	?value@?$_GcdX@$00$0A@@std@@2_JB		; std::_GcdX<1,0>::value
PUBLIC	?value@?$_GcdX@$00$00@std@@2_JB			; std::_GcdX<1,1>::value
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?value@?$_Gcd@$00$00@std@@2_JB			; std::_Gcd<1,1>::value
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_monotonic@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_monotonic
PUBLIC	?is_steady@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_steady
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?is_steady@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@system_clock@chrono@std@@2_NB DB 00H		; std::chrono::system_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@system_clock@chrono@std@@2_NB DB 00H	; std::chrono::system_clock::is_monotonic
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0A@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$00@std@@2_JB DQ 0000000000000001H	; std::_Abs<1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_Gcd<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB DD 03H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
CONST	ENDS
;	COMDAT ?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 02H ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 01H ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
CONST	ENDS
;	COMDAT ?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB DD 00H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<1000000000,100>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0A@@std@@2_JB DQ 0000000000000064H	; std::_GcdX<100,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Abs<1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0GE@@std@@2_JB DQ 0000000000000064H	; std::_Abs<100>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::ratio<1,10000000>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,10000000>::num
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000000,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT _AgentEventGuid
CONST	SEGMENT
_AgentEventGuid DD 0b9b5b78cH
	DW	0713H
	DW	04898H
	DB	0a2H
	DB	01aH
	DB	0c6H
	DB	079H
	DB	049H
	DB	0dcH
	DB	0edH
	DB	07H
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
CONST	ENDS
;	COMDAT _PPLParallelForeachEventGuid
CONST	SEGMENT
_PPLParallelForeachEventGuid DD 05cb7d785H
	DW	09d66H
	DW	0465dH
	DB	0baH
	DB	0e1H
	DB	046H
	DB	011H
	DB	06H
	DB	01bH
	DB	054H
	DB	034H
CONST	ENDS
;	COMDAT _PPLParallelForEventGuid
CONST	SEGMENT
_PPLParallelForEventGuid DD 031c8da6bH
	DW	06165H
	DW	04042H
	DB	08bH
	DB	092H
	DB	094H
	DB	09eH
	DB	031H
	DB	05fH
	DB	04dH
	DB	084H
CONST	ENDS
;	COMDAT _PPLParallelInvokeEventGuid
CONST	SEGMENT
_PPLParallelInvokeEventGuid DD 0d1b5b133H
	DW	0ec3dH
	DW	049f4H
	DB	098H
	DB	0a3H
	DB	046H
	DB	04dH
	DB	01aH
	DB	09eH
	DB	046H
	DB	082H
CONST	ENDS
;	COMDAT _ResourceManagerEventGuid
CONST	SEGMENT
_ResourceManagerEventGuid DD 02718d25bH
	DW	05bf5H
	DW	04479H
	DB	08eH
	DB	088H
	DB	0baH
	DB	0bcH
	DB	064H
	DB	0bdH
	DB	0bfH
	DB	0caH
CONST	ENDS
;	COMDAT _LockEventGuid
CONST	SEGMENT
_LockEventGuid DD 079a60dc6H
	DW	05fc8H
	DW	04952H
	DB	0a4H
	DB	01cH
	DB	011H
	DB	063H
	DB	0aeH
	DB	0ecH
	DB	05eH
	DB	0b8H
CONST	ENDS
;	COMDAT _VirtualProcessorEventGuid
CONST	SEGMENT
_VirtualProcessorEventGuid DD 02f27805fH
	DW	01676H
	DW	04eccH
	DB	096H
	DB	0faH
	DB	07eH
	DB	0b0H
	DB	09dH
	DB	044H
	DB	030H
	DB	02fH
CONST	ENDS
;	COMDAT _ChoreEventGuid
CONST	SEGMENT
_ChoreEventGuid DD 07e854ec7H
	DW	0cdc4H
	DW	0405aH
	DB	0b5H
	DB	0b2H
	DB	0aaH
	DB	0f7H
	DB	0c9H
	DB	0e7H
	DB	0d4H
	DB	0cH
CONST	ENDS
;	COMDAT _ContextEventGuid
CONST	SEGMENT
_ContextEventGuid DD 05727a00fH
	DW	050beH
	DW	04519H
	DB	082H
	DB	056H
	DB	0f7H
	DB	069H
	DB	098H
	DB	071H
	DB	0feH
	DB	0cbH
CONST	ENDS
;	COMDAT _ScheduleGroupEventGuid
CONST	SEGMENT
_ScheduleGroupEventGuid DD 0e8a3bf1fH
	DW	0a86bH
	DW	04390H
	DB	09cH
	DB	060H
	DB	053H
	DB	090H
	DB	0b9H
	DB	069H
	DB	0d2H
	DB	02cH
CONST	ENDS
;	COMDAT _SchedulerEventGuid
CONST	SEGMENT
_SchedulerEventGuid DD 0e2091f8aH
	DW	01e0aH
	DW	04731H
	DB	084H
	DB	0a2H
	DB	0dH
	DB	0d5H
	DB	07cH
	DB	08aH
	DB	052H
	DB	061H
CONST	ENDS
;	COMDAT _ConcRTEventGuid
CONST	SEGMENT
_ConcRTEventGuid DD 072b14a7dH
	DW	0704cH
	DW	0423eH
	DB	092H
	DB	0f8H
	DB	07eH
	DB	06dH
	DB	064H
	DB	0bcH
	DB	0b9H
	DB	02aH
CONST	ENDS
;	COMDAT _ConcRT_ProviderGuid
CONST	SEGMENT
_ConcRT_ProviderGuid DD 0f7b697a3H
	DW	04db5H
	DW	04d3bH
	DB	0beH
	DB	071H
	DB	0c4H
	DB	0d2H
	DB	084H
	DB	0e6H
	DB	059H
	DB	02fH
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?is_steady@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@steady_clock@chrono@std@@2_NB DB 01H		; std::chrono::steady_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@steady_clock@chrono@std@@2_NB DB 01H	; std::chrono::steady_clock::is_monotonic
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::num
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0JIJGIA@@std@@2_JB DQ 0000000000989680H	; std::_Abs<10000000>::value
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_reserved
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_localCancel
CONST	ENDS
;	COMDAT ?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_structured
CONST	ENDS
;	COMDAT ?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB DD 0ffffffffH ; Concurrency::details::_TaskCollectionBase::_S_notInlined
CONST	ENDS
;	COMDAT ?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_cancelException
CONST	ENDS
;	COMDAT ?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB DD 08H ; Concurrency::details::_TaskCollectionBase::_S_nonNull
CONST	ENDS
;	COMDAT ?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
CONST	ENDS
;	COMDAT ?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB DD 00H ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
CONST	SEGMENT
_dutycycletable DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@H$0A@@std@@2HB
CONST	SEGMENT
?value@?$integral_constant@H$0A@@std@@2HB DD 00H	; std::integral_constant<int,0>::value
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
PUBLIC	?handle@Window@windows@core@@QAEPAUHWND__@@XZ	; core::windows::Window::handle
PUBLIC	??0Interface@output@audio@@QAE@XZ		; audio::output::Interface::Interface
PUBLIC	??0DirectSound@output@audio@@QAE@XZ		; audio::output::DirectSound::DirectSound
PUBLIC	??1DirectSound@output@audio@@QAE@XZ		; audio::output::DirectSound::~DirectSound
PUBLIC	?Initialize@DirectSound@output@audio@@UAEHIEE@Z	; audio::output::DirectSound::Initialize
PUBLIC	?Deinitialize@DirectSound@output@audio@@UAEHXZ	; audio::output::DirectSound::Deinitialize
PUBLIC	?Play@DirectSound@output@audio@@UAEHXZ		; audio::output::DirectSound::Play
PUBLIC	?Stop@DirectSound@output@audio@@UAEHXZ		; audio::output::DirectSound::Stop
PUBLIC	?GetBytesBuffered@DirectSound@output@audio@@UAEIXZ ; audio::output::DirectSound::GetBytesBuffered
PUBLIC	?GetCursors@DirectSound@output@audio@@UAEXAAI0@Z ; audio::output::DirectSound::GetCursors
PUBLIC	?Write@DirectSound@output@audio@@UAEHPAXI@Z	; audio::output::DirectSound::Write
PUBLIC	?BeginWrite@DirectSound@output@audio@@UAEHAAI@Z	; audio::output::DirectSound::BeginWrite
PUBLIC	?EndWrite@DirectSound@output@audio@@UAEHPAX@Z	; audio::output::DirectSound::EndWrite
PUBLIC	??0_Ignore@std@@QAE@XZ				; std::_Ignore::_Ignore
PUBLIC	?display_window@Application@app@@QAEAAVDisplayWindow@2@XZ ; app::Application::display_window
PUBLIC	?Current@Application@app@@SAPAV12@XZ		; app::Application::Current
PUBLIC	??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z ; SafeRelease<IDirectSoundBuffer>
PUBLIC	??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z ; SafeRelease<IDirectSound8>
PUBLIC	??_7Interface@output@audio@@6B@			; audio::output::Interface::`vftable'
PUBLIC	??_7DirectSound@output@audio@@6B@		; audio::output::DirectSound::`vftable'
PUBLIC	??_R4Interface@output@audio@@6B@		; audio::output::Interface::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVInterface@output@audio@@@8		; audio::output::Interface `RTTI Type Descriptor'
PUBLIC	??_R3Interface@output@audio@@8			; audio::output::Interface::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Interface@output@audio@@8			; audio::output::Interface::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Interface@output@audio@@8		; audio::output::Interface::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4DirectSound@output@audio@@6B@		; audio::output::DirectSound::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDirectSound@output@audio@@@8		; audio::output::DirectSound `RTTI Type Descriptor'
PUBLIC	??_R3DirectSound@output@audio@@8		; audio::output::DirectSound::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DirectSound@output@audio@@8		; audio::output::DirectSound::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DirectSound@output@audio@@8	; audio::output::DirectSound::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3fd999999999999a
PUBLIC	__real@46feb000
PUBLIC	__real@47000000
PUBLIC	__real@c6feb000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__purecall:PROC
EXTRN	_memset:PROC
EXTRN	_DirectSoundCreate8@12:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	_DSDEVID_DefaultPlayback:BYTE
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?current_app_@Application@app@@1PAV12@A:DWORD	; app::Application::current_app_
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_ignore	DB	01H DUP (?)
__Tuple_alloc DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c6feb000
CONST	SEGMENT
__real@c6feb000 DD 0c6feb000r			; -32600
CONST	ENDS
;	COMDAT __real@47000000
CONST	SEGMENT
__real@47000000 DD 047000000r			; 32768
CONST	ENDS
;	COMDAT __real@46feb000
CONST	SEGMENT
__real@46feb000 DD 046feb000r			; 32600
CONST	ENDS
;	COMDAT __real@3fd999999999999a
CONST	SEGMENT
__real@3fd999999999999a DQ 03fd999999999999ar	; 0.4
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@DirectSound@output@audio@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DirectSound@output@audio@@8 DD FLAT:??_R0?AVDirectSound@output@audio@@@8 ; audio::output::DirectSound::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DirectSound@output@audio@@8
rdata$r	ENDS
;	COMDAT ??_R2DirectSound@output@audio@@8
rdata$r	SEGMENT
??_R2DirectSound@output@audio@@8 DD FLAT:??_R1A@?0A@EA@DirectSound@output@audio@@8 ; audio::output::DirectSound::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Interface@output@audio@@8
rdata$r	ENDS
;	COMDAT ??_R3DirectSound@output@audio@@8
rdata$r	SEGMENT
??_R3DirectSound@output@audio@@8 DD 00H			; audio::output::DirectSound::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2DirectSound@output@audio@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDirectSound@output@audio@@@8
_DATA	SEGMENT
??_R0?AVDirectSound@output@audio@@@8 DD FLAT:??_7type_info@@6B@ ; audio::output::DirectSound `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDirectSound@output@audio@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DirectSound@output@audio@@6B@
rdata$r	SEGMENT
??_R4DirectSound@output@audio@@6B@ DD 00H		; audio::output::DirectSound::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDirectSound@output@audio@@@8
	DD	FLAT:??_R3DirectSound@output@audio@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Interface@output@audio@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Interface@output@audio@@8 DD FLAT:??_R0?AVInterface@output@audio@@@8 ; audio::output::Interface::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Interface@output@audio@@8
rdata$r	ENDS
;	COMDAT ??_R2Interface@output@audio@@8
rdata$r	SEGMENT
??_R2Interface@output@audio@@8 DD FLAT:??_R1A@?0A@EA@Interface@output@audio@@8 ; audio::output::Interface::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Interface@output@audio@@8
rdata$r	SEGMENT
??_R3Interface@output@audio@@8 DD 00H			; audio::output::Interface::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Interface@output@audio@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVInterface@output@audio@@@8
_DATA	SEGMENT
??_R0?AVInterface@output@audio@@@8 DD FLAT:??_7type_info@@6B@ ; audio::output::Interface `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVInterface@output@audio@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Interface@output@audio@@6B@
rdata$r	SEGMENT
??_R4Interface@output@audio@@6B@ DD 00H			; audio::output::Interface::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVInterface@output@audio@@@8
	DD	FLAT:??_R3Interface@output@audio@@8
rdata$r	ENDS
;	COMDAT ??_7DirectSound@output@audio@@6B@
CONST	SEGMENT
??_7DirectSound@output@audio@@6B@ DD FLAT:??_R4DirectSound@output@audio@@6B@ ; audio::output::DirectSound::`vftable'
	DD	FLAT:?Initialize@DirectSound@output@audio@@UAEHIEE@Z
	DD	FLAT:?Deinitialize@DirectSound@output@audio@@UAEHXZ
	DD	FLAT:?Play@DirectSound@output@audio@@UAEHXZ
	DD	FLAT:?Stop@DirectSound@output@audio@@UAEHXZ
	DD	FLAT:?GetBytesBuffered@DirectSound@output@audio@@UAEIXZ
	DD	FLAT:?GetCursors@DirectSound@output@audio@@UAEXAAI0@Z
	DD	FLAT:?Write@DirectSound@output@audio@@UAEHPAXI@Z
	DD	FLAT:?BeginWrite@DirectSound@output@audio@@UAEHAAI@Z
	DD	FLAT:?EndWrite@DirectSound@output@audio@@UAEHPAX@Z
CONST	ENDS
;	COMDAT ??_7Interface@output@audio@@6B@
CONST	SEGMENT
??_7Interface@output@audio@@6B@ DD FLAT:??_R4Interface@output@audio@@6B@ ; audio::output::Interface::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\directsound.cpp
_TEXT	SEGMENT
_v$1 = -12						; size = 4
_i$2 = -8						; size = 4
_dests$ = -4						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_nsamples$ = 16						; size = 4
?clamp@output@audio@@YAXPAXPBMH@Z PROC			; audio::output::clamp

; 267  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 268  :   int16_t *dests = (int16_t *)dest;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _dests$[ebp], eax

; 269  : 
; 270  :   for (int32_t i=0; i < nsamples; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN5@clamp
$LN4@clamp:
	mov	ecx, DWORD PTR _i$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$2[ebp], ecx
$LN5@clamp:
	mov	edx, DWORD PTR _i$2[ebp]
	cmp	edx, DWORD PTR _nsamples$[ebp]
	jge	SHORT $LN3@clamp

; 271  :   {
; 272  :     float v = src[i] * 32768.0f;

	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	mulss	xmm0, DWORD PTR __real@47000000
	movss	DWORD PTR _v$1[ebp], xmm0

; 273  :     if (v >  32600.0f) v =  32600.0f;

	movss	xmm0, DWORD PTR _v$1[ebp]
	comiss	xmm0, DWORD PTR __real@46feb000
	jbe	SHORT $LN2@clamp
	movss	xmm0, DWORD PTR __real@46feb000
	movss	DWORD PTR _v$1[ebp], xmm0
$LN2@clamp:

; 274  :     if (v < -32600.0f) v = -32600.0f;

	movss	xmm0, DWORD PTR __real@c6feb000
	comiss	xmm0, DWORD PTR _v$1[ebp]
	jbe	SHORT $LN1@clamp
	movss	xmm0, DWORD PTR __real@c6feb000
	movss	DWORD PTR _v$1[ebp], xmm0
$LN1@clamp:

; 275  :     dests[i] = (int16_t)v;

	cvttss2si edx, DWORD PTR _v$1[ebp]
	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _dests$[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 276  :   }

	jmp	SHORT $LN4@clamp
$LN3@clamp:

; 277  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?clamp@output@audio@@YAXPAXPBMH@Z ENDP			; audio::output::clamp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\wincore\types.h
;	COMDAT ??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z
_TEXT	SEGMENT
_ppInterfaceToRelease$ = 8				; size = 4
??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z PROC ; SafeRelease<IDirectSound8>, COMDAT

; 27   : inline void SafeRelease(Interface **ppInterfaceToRelease) {

	push	ebp
	mov	ebp, esp
	push	esi

; 28   :     if (*ppInterfaceToRelease != NULL) {

	mov	eax, DWORD PTR _ppInterfaceToRelease$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SafeReleas

; 29   :         (*ppInterfaceToRelease)->Release();

	mov	ecx, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 30   :         (*ppInterfaceToRelease) = NULL;

	mov	ecx, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	DWORD PTR [ecx], 0
$LN2@SafeReleas:

; 31   :     }
; 32   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z ENDP ; SafeRelease<IDirectSound8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\wincore\types.h
;	COMDAT ??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z
_TEXT	SEGMENT
_ppInterfaceToRelease$ = 8				; size = 4
??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z PROC ; SafeRelease<IDirectSoundBuffer>, COMDAT

; 27   : inline void SafeRelease(Interface **ppInterfaceToRelease) {

	push	ebp
	mov	ebp, esp
	push	esi

; 28   :     if (*ppInterfaceToRelease != NULL) {

	mov	eax, DWORD PTR _ppInterfaceToRelease$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SafeReleas

; 29   :         (*ppInterfaceToRelease)->Release();

	mov	ecx, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 30   :         (*ppInterfaceToRelease) = NULL;

	mov	ecx, DWORD PTR _ppInterfaceToRelease$[ebp]
	mov	DWORD PTR [ecx], 0
$LN2@SafeReleas:

; 31   :     }
; 32   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z ENDP ; SafeRelease<IDirectSoundBuffer>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\application.h
;	COMDAT ?Current@Application@app@@SAPAV12@XZ
_TEXT	SEGMENT
?Current@Application@app@@SAPAV12@XZ PROC		; app::Application::Current, COMDAT

; 34   :     static Application* Current() {

	push	ebp
	mov	ebp, esp

; 35   :       return current_app_;

	mov	eax, DWORD PTR ?current_app_@Application@app@@1PAV12@A ; app::Application::current_app_

; 36   :     }

	pop	ebp
	ret	0
?Current@Application@app@@SAPAV12@XZ ENDP		; app::Application::Current
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\application.h
;	COMDAT ?display_window@Application@app@@QAEAAVDisplayWindow@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?display_window@Application@app@@QAEAAVDisplayWindow@2@XZ PROC ; app::Application::display_window, COMDAT
; _this$ = ecx

; 31   :     DisplayWindow& display_window() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 32   :       return display_window_;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8

; 33   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?display_window@Application@app@@QAEAAVDisplayWindow@2@XZ ENDP ; app::Application::display_window
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 137  : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$yc	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 130  : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Ignore@std@@QAE@XZ PROC				; std::_Ignore::_Ignore, COMDAT
; _this$ = ecx

; 120  : 	_Ignore()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Ignore@std@@QAE@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\directsound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_data_pointer$ = 8					; size = 4
?EndWrite@DirectSound@output@audio@@UAEHPAX@Z PROC	; audio::output::DirectSound::EndWrite
; _this$ = ecx

; 280  : int DirectSound::EndWrite(void* data_pointer) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 281  : 
; 282  :   /*auto dest_buf=(uint8_t*)buf1;
; 283  :   auto dw=len1;
; 284  : 
; 285  :   auto src_buf=(float*)data_pointer;
; 286  :   while (dw) { 
; 287  :     float v = *src_buf++;
; 288  :     v *= 32768.0f; // * vol;
; 289  :     if (v >  32600.0f) v =  32600.0f;
; 290  :     if (v < -32600.0f) v = -32600.0f;
; 291  :     *dest_buf++ = (short)v;
; 292  :     dw--;
; 293  :   }
; 294  : 
; 295  :   if(buf2)  {
; 296  :     dest_buf=(uint8_t*)buf2;
; 297  :     dw=len2;
; 298  :     while(dw) {
; 299  :       float v = *src_buf++;
; 300  :       v *= 32768.0f; // * vol;
; 301  :       if (v >  32600.0f) v =  32600.0f;
; 302  :       if (v < -32600.0f) v = -32600.0f;
; 303  :       *dest_buf++ = (short)v;
; 304  :     dw--;
; 305  :     }
; 306  :   }*/
; 307  : 
; 308  :     if (buf1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN4@EndWrite

; 309  :       clamp(buf1, (float*)data_pointer, len1/2);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	shr	edx, 1
	push	edx
	mov	eax, DWORD PTR _data_pointer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?clamp@output@audio@@YAXPAXPBMH@Z	; audio::output::clamp
	add	esp, 12					; 0000000cH
$LN4@EndWrite:

; 310  :     if (buf2)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN3@EndWrite

; 311  :       clamp(buf2, (float*)data_pointer + len1/2, len2/2);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	shr	edx, 1
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	shr	ecx, 1
	mov	edx, DWORD PTR _data_pointer$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	?clamp@output@audio@@YAXPAXPBMH@Z	; audio::output::clamp
	add	esp, 12					; 0000000cH
$LN3@EndWrite:

; 312  : 
; 313  :   if (secondary_buffer->Unlock(buf1, len1, buf2, len2)==DS_OK)

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+76]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN2@EndWrite

; 314  :     return S_OK;

	xor	eax, eax
	jmp	SHORT $LN5@EndWrite

; 315  :   else

	jmp	SHORT $LN5@EndWrite
$LN2@EndWrite:

; 316  :     return S_FALSE;

	mov	eax, 1
$LN5@EndWrite:

; 317  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?EndWrite@DirectSound@output@audio@@UAEHPAX@Z ENDP	; audio::output::DirectSound::EndWrite
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\directsound.cpp
_TEXT	SEGMENT
_hr$1 = -24						; size = 4
_nwrite$ = -20						; size = 4
_curpos$ = -12						; size = 4
_this$ = -4						; size = 4
_samples$ = 8						; size = 4
?BeginWrite@DirectSound@output@audio@@UAEHAAI@Z PROC	; audio::output::DirectSound::BeginWrite
; _this$ = ecx

; 231  : int DirectSound::BeginWrite(uint32_t& samples) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 232  :    DWORD curpos;
; 233  :   int32_t nwrite = 0;

	mov	DWORD PTR _nwrite$[ebp], 0
$LN9@BeginWrite:

; 234  :   for (;;) {
; 235  :     HRESULT hr = secondary_buffer->GetCurrentPosition(&curpos, 0);

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _curpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+16]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$1[ebp], eax

; 236  :     if (hr == S_OK)

	cmp	DWORD PTR _hr$1[ebp], 0
	jne	$LN7@BeginWrite

; 237  :     {
; 238  :       // find out how many bytes to write
; 239  :       curpos &= ~31u;

	mov	ecx, DWORD PTR _curpos$[ebp]
	and	ecx, -32				; ffffffe0H
	mov	DWORD PTR _curpos$[ebp], ecx

; 240  :       if (curpos == last_cursor_pos)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _curpos$[ebp]
	cmp	eax, DWORD PTR [edx+60]
	jne	SHORT $LN6@BeginWrite

; 241  :         return S_FALSE;

	mov	eax, 1
	jmp	$LN10@BeginWrite
$LN6@BeginWrite:

; 242  : 
; 243  :       nwrite = curpos - last_cursor_pos;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _curpos$[ebp]
	sub	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _nwrite$[ebp], edx

; 244  :       if (nwrite < 0)

	jns	SHORT $LN5@BeginWrite

; 245  :         nwrite += buffer_size_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nwrite$[ebp]
	add	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _nwrite$[ebp], ecx
$LN5@BeginWrite:

; 246  : 
; 247  :       hr = secondary_buffer->Lock(last_cursor_pos, nwrite, &buf1, &len1, &buf2, &len2, 0);

	mov	esi, esp
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _nwrite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+44]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$1[ebp], eax
$LN7@BeginWrite:

; 248  :     }
; 249  : 
; 250  :     if (hr == S_OK)

	cmp	DWORD PTR _hr$1[ebp], 0
	jne	SHORT $LN4@BeginWrite

; 251  :       break;

	jmp	SHORT $LN8@BeginWrite
	jmp	SHORT $LN3@BeginWrite
$LN4@BeginWrite:

; 252  :     else if (hr == DSERR_BUFFERLOST)

	cmp	DWORD PTR _hr$1[ebp], -2005401450	; 88780096H
	jne	SHORT $LN2@BeginWrite

; 253  :       secondary_buffer->Restore();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR [ecx+80]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 254  :     else

	jmp	SHORT $LN3@BeginWrite
$LN2@BeginWrite:

; 255  :       return S_FALSE;

	mov	eax, 1
	jmp	SHORT $LN10@BeginWrite
$LN3@BeginWrite:

; 256  :   }

	jmp	$LN9@BeginWrite
$LN8@BeginWrite:

; 257  : 
; 258  :   // we got the lock
; 259  :   last_cursor_pos = curpos;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _curpos$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 260  :   //g_dsound.bufcnt += nwrite;
; 261  :   samples = nwrite / 4;

	mov	eax, DWORD PTR _nwrite$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	edx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR [edx], eax

; 262  :   return S_OK;

	xor	eax, eax
$LN10@BeginWrite:

; 263  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@BeginWrite
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN14@BeginWrite:
	DD	1
	DD	$LN13@BeginWrite
$LN13@BeginWrite:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN12@BeginWrite
$LN12@BeginWrite:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
?BeginWrite@DirectSound@output@audio@@UAEHAAI@Z ENDP	; audio::output::DirectSound::BeginWrite
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\directsound.cpp
_TEXT	SEGMENT
$T1 = -96						; size = 1
$T2 = -95						; size = 1
$T3 = -94						; size = 1
$T4 = -93						; size = 1
_src_buf$ = -92						; size = 4
_len$ = -88						; size = 4
_dest_buf$ = -84					; size = 4
_buf_size2$ = -76					; size = 4
_buf_size1$ = -64					; size = 4
_write_cursor$ = -52					; size = 4
_play_cursor$ = -40					; size = 4
_hr$ = -32						; size = 4
_buf_ptr2$ = -24					; size = 4
_buf_ptr1$ = -12					; size = 4
_this$ = -4						; size = 4
_data_pointer$ = 8					; size = 4
_size_bytes$ = 12					; size = 4
?Write@DirectSound@output@audio@@UAEHPAXI@Z PROC	; audio::output::DirectSound::Write
; _this$ = ecx

; 143  : int DirectSound::Write(void* data_pointer, uint32_t size_bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	BYTE PTR $T4[ebp], 0
	mov	BYTE PTR $T2[ebp], 0
	mov	BYTE PTR $T3[ebp], 0
	mov	BYTE PTR $T1[ebp], 0
$LN12@Write:

; 144  :   LPVOID buf_ptr1, buf_ptr2;
; 145  :   HRESULT hr;
; 146  :   DWORD play_cursor,write_cursor;
; 147  :   DWORD buf_size1,buf_size2; 
; 148  : 
; 149  :   for (;;) {
; 150  :     hr = secondary_buffer->GetCurrentPosition(&play_cursor,&write_cursor);

	mov	esi, esp
	lea	eax, DWORD PTR _write_cursor$[ebp]
	push	eax
	lea	ecx, DWORD PTR _play_cursor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+16]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 151  :     if (hr == S_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	jne	SHORT $LN10@Write

; 152  :     {
; 153  :       hr = secondary_buffer->Lock(write_cursor,size_bytes,&buf_ptr1,&buf_size1,&buf_ptr2,&buf_size2,0);

	mov	esi, esp
	push	0
	mov	BYTE PTR $T4[ebp], 1
	lea	edx, DWORD PTR _buf_size2$[ebp]
	push	edx
	mov	BYTE PTR $T3[ebp], 1
	lea	eax, DWORD PTR _buf_ptr2$[ebp]
	push	eax
	mov	BYTE PTR $T2[ebp], 1
	lea	ecx, DWORD PTR _buf_size1$[ebp]
	push	ecx
	mov	BYTE PTR $T1[ebp], 1
	lea	edx, DWORD PTR _buf_ptr1$[ebp]
	push	edx
	mov	eax, DWORD PTR _size_bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _write_cursor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+44]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
$LN10@Write:

; 154  :     }
; 155  : 
; 156  :     if (hr == S_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	jne	SHORT $LN9@Write

; 157  :       break;

	jmp	SHORT $LN11@Write
	jmp	SHORT $LN8@Write
$LN9@Write:

; 158  :     else if (hr == DSERR_BUFFERLOST)

	cmp	DWORD PTR _hr$[ebp], -2005401450	; 88780096H
	jne	SHORT $LN7@Write

; 159  :       secondary_buffer->Restore();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [eax]
	mov	esi, esp
	push	edx
	mov	ecx, DWORD PTR [eax+80]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 160  :     else

	jmp	SHORT $LN8@Write
$LN7@Write:

; 161  :       return S_FALSE;

	mov	eax, 1
	jmp	$LN13@Write
$LN8@Write:

; 162  :   }  

	jmp	$LN12@Write
$LN11@Write:

; 163  : 
; 164  :   auto dest_buf=(uint8_t*)buf_ptr1;

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN15@Write
	push	OFFSET $LN16@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN15@Write:
	mov	edx, DWORD PTR _buf_ptr1$[ebp]
	mov	DWORD PTR _dest_buf$[ebp], edx

; 165  :   auto len=buf_size1;

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN17@Write
	push	OFFSET $LN18@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN17@Write:
	mov	eax, DWORD PTR _buf_size1$[ebp]
	mov	DWORD PTR _len$[ebp], eax

; 166  : 
; 167  :   auto src_buf=(uint8_t*)data_pointer;

	mov	ecx, DWORD PTR _data_pointer$[ebp]
	mov	DWORD PTR _src_buf$[ebp], ecx
$LN5@Write:

; 168  :   while(len) {*dest_buf++=*src_buf++;len--;}

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN4@Write
	mov	edx, DWORD PTR _dest_buf$[ebp]
	mov	eax, DWORD PTR _src_buf$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _dest_buf$[ebp]
	add	edx, 1
	mov	DWORD PTR _dest_buf$[ebp], edx
	mov	eax, DWORD PTR _src_buf$[ebp]
	add	eax, 1
	mov	DWORD PTR _src_buf$[ebp], eax
	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	jmp	SHORT $LN5@Write
$LN4@Write:

; 169  : 
; 170  :   if(buf_ptr2)  {

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN19@Write
	push	OFFSET $LN20@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN19@Write:
	cmp	DWORD PTR _buf_ptr2$[ebp], 0
	je	SHORT $LN3@Write

; 171  :     dest_buf=(uint8_t*)buf_ptr2;

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN21@Write
	push	OFFSET $LN20@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN21@Write:
	mov	edx, DWORD PTR _buf_ptr2$[ebp]
	mov	DWORD PTR _dest_buf$[ebp], edx

; 172  :     len=buf_size2;

	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN22@Write
	push	OFFSET $LN23@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN22@Write:
	mov	eax, DWORD PTR _buf_size2$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN2@Write:

; 173  :     while(len) {*dest_buf++=*src_buf++;len--;}

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN3@Write
	mov	ecx, DWORD PTR _dest_buf$[ebp]
	mov	edx, DWORD PTR _src_buf$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _dest_buf$[ebp]
	add	ecx, 1
	mov	DWORD PTR _dest_buf$[ebp], ecx
	mov	edx, DWORD PTR _src_buf$[ebp]
	add	edx, 1
	mov	DWORD PTR _src_buf$[ebp], edx
	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN2@Write
$LN3@Write:

; 174  :   }
; 175  : 
; 176  :   secondary_buffer->Unlock(buf_ptr1,buf_size1,buf_ptr2,buf_size2);

	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN24@Write
	push	OFFSET $LN23@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN24@Write:
	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN25@Write
	push	OFFSET $LN20@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN25@Write:
	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN26@Write
	push	OFFSET $LN18@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN26@Write:
	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN27@Write
	push	OFFSET $LN16@Write
	call	__RTC_UninitUse
	add	esp, 4
$LN27@Write:
	mov	esi, esp
	mov	ecx, DWORD PTR _buf_size2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf_ptr2$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf_size1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf_ptr1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+76]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 177  :   return S_OK;

	xor	eax, eax
$LN13@Write:

; 178  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN31@Write
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN31@Write:
	DD	6
	DD	$LN30@Write
$LN30@Write:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN16@Write
	DD	-64					; ffffffc0H
	DD	4
	DD	$LN18@Write
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN20@Write
	DD	-76					; ffffffb4H
	DD	4
	DD	$LN23@Write
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN28@Write
	DD	-52					; ffffffccH
	DD	4
	DD	$LN29@Write
$LN29@Write:
	DB	119					; 00000077H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
$LN28@Write:
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
$LN23@Write:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	50					; 00000032H
	DB	0
$LN20@Write:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	50					; 00000032H
	DB	0
$LN18@Write:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	49					; 00000031H
	DB	0
$LN16@Write:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	49					; 00000031H
	DB	0
?Write@DirectSound@output@audio@@UAEHPAXI@Z ENDP	; audio::output::DirectSound::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\directsound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_play$ = 8						; size = 4
_write$ = 12						; size = 4
?GetCursors@DirectSound@output@audio@@UAEXAAI0@Z PROC	; audio::output::DirectSound::GetCursors
; _this$ = ecx

; 138  : void DirectSound::GetCursors(uint32_t& play, uint32_t& write) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 139  :   secondary_buffer->GetCurrentPosition((LPDWORD)&play,(LPDWORD)&write);

	mov	esi, esp
	mov	eax, DWORD PTR _write$[ebp]
	push	eax
	mov	ecx, DWORD PTR _play$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+16]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 140  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetCursors@DirectSound@output@audio@@UAEXAAI0@Z ENDP	; audio::output::DirectSound::GetCursors
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\directsound.cpp
_TEXT	SEGMENT
_cwrite$ = -24						; size = 4
_cplay$ = -12						; size = 4
_this$ = -4						; size = 4
?GetBytesBuffered@DirectSound@output@audio@@UAEIXZ PROC	; audio::output::DirectSound::GetBytesBuffered
; _this$ = ecx

; 125  : uint32_t DirectSound::GetBytesBuffered() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 126  :  unsigned long cplay,cwrite;
; 127  : 
; 128  :  if(last_write_cursor==0xffffffff) return 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+64], -1
	jne	SHORT $LN3@GetBytesBu
	xor	eax, eax
	jmp	SHORT $LN4@GetBytesBu
$LN3@GetBytesBu:

; 129  : 
; 130  :  secondary_buffer->GetCurrentPosition(&cplay,&cwrite);

	mov	esi, esp
	lea	ecx, DWORD PTR _cwrite$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cplay$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+16]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 131  : 
; 132  :  if(cplay>buffer_size_) return buffer_size_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cplay$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jbe	SHORT $LN2@GetBytesBu
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	jmp	SHORT $LN4@GetBytesBu
$LN2@GetBytesBu:

; 133  : 
; 134  :  if(cplay<last_write_cursor) return last_write_cursor-cplay;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cplay$[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	jae	SHORT $LN1@GetBytesBu
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	sub	eax, DWORD PTR _cplay$[ebp]
	jmp	SHORT $LN4@GetBytesBu
$LN1@GetBytesBu:

; 135  :  return (buffer_size_-cplay)+last_write_cursor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	sub	eax, DWORD PTR _cplay$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+64]
$LN4@GetBytesBu:

; 136  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@GetBytesBu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN9@GetBytesBu:
	DD	2
	DD	$LN8@GetBytesBu
$LN8@GetBytesBu:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN6@GetBytesBu
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN7@GetBytesBu
$LN7@GetBytesBu:
	DB	99					; 00000063H
	DB	119					; 00000077H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
$LN6@GetBytesBu:
	DB	99					; 00000063H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	0
?GetBytesBuffered@DirectSound@output@audio@@UAEIXZ ENDP	; audio::output::DirectSound::GetBytesBuffered
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\directsound.cpp
_TEXT	SEGMENT
_hr$1 = -12						; size = 4
_hr$2 = -8						; size = 4
_this$ = -4						; size = 4
?Stop@DirectSound@output@audio@@UAEHXZ PROC		; audio::output::DirectSound::Stop
; _this$ = ecx

; 113  : int DirectSound::Stop() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 114  :   if (secondary_buffer != nullptr) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN4@Stop

; 115  :     auto hr = secondary_buffer->Stop();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	mov	eax, DWORD PTR [edx+72]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$2[ebp], eax

; 116  :     if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$2[ebp], 0
	jge	SHORT $LN4@Stop
	mov	eax, 1
	jmp	SHORT $LN5@Stop
$LN4@Stop:

; 117  :   }
; 118  :   if (primary_buffer != nullptr) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN2@Stop

; 119  :     auto hr = primary_buffer->Stop();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax]
	mov	esi, esp
	push	edx
	mov	ecx, DWORD PTR [eax+72]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$1[ebp], eax

; 120  :     if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$1[ebp], 0
	jge	SHORT $LN2@Stop
	mov	eax, 1
	jmp	SHORT $LN5@Stop
$LN2@Stop:

; 121  :   }
; 122  :   return S_OK;

	xor	eax, eax
$LN5@Stop:

; 123  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Stop@DirectSound@output@audio@@UAEHXZ ENDP		; audio::output::DirectSound::Stop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\directsound.cpp
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
?Play@DirectSound@output@audio@@UAEHXZ PROC		; audio::output::DirectSound::Play
; _this$ = ecx

; 104  : int DirectSound::Play() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 105  :   auto hr = primary_buffer->Play(0,0,DSBPLAY_LOOPING);

	mov	esi, esp
	push	1
	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 106  :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN2@Play
	mov	eax, 1
	jmp	SHORT $LN3@Play
$LN2@Play:

; 107  :   hr = secondary_buffer->Play(0,0,DSBPLAY_LOOPING);

	mov	esi, esp
	push	1
	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 108  :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Play
	mov	eax, 1
	jmp	SHORT $LN3@Play
$LN1@Play:

; 109  :   hr = secondary_buffer->SetCurrentPosition(0);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 110  :   return hr;

	mov	eax, DWORD PTR _hr$[ebp]
$LN3@Play:

; 111  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Play@DirectSound@output@audio@@UAEHXZ ENDP		; audio::output::DirectSound::Play
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\directsound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Deinitialize@DirectSound@output@audio@@UAEHXZ PROC	; audio::output::DirectSound::Deinitialize
; _this$ = ecx

; 96   : int DirectSound::Deinitialize() {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 97   :   Stop();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 98   :   SafeRelease(&secondary_buffer);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	call	??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z ; SafeRelease<IDirectSoundBuffer>
	add	esp, 4

; 99   :   SafeRelease(&primary_buffer);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	call	??$SafeRelease@UIDirectSoundBuffer@@@@YAXPAPAUIDirectSoundBuffer@@@Z ; SafeRelease<IDirectSoundBuffer>
	add	esp, 4

; 100  :   SafeRelease(&ds8);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	call	??$SafeRelease@UIDirectSound8@@@@YAXPAPAUIDirectSound8@@@Z ; SafeRelease<IDirectSound8>
	add	esp, 4

; 101  :   return S_OK;

	xor	eax, eax

; 102  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Deinitialize@DirectSound@output@audio@@UAEHXZ ENDP	; audio::output::DirectSound::Deinitialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\directsound.cpp
_TEXT	SEGMENT
tv442 = -84						; size = 8
tv440 = -76						; size = 4
tv437 = -70						; size = 2
tv435 = -68						; size = 8
tv431 = -60						; size = 4
_dsbd$ = -52						; size = 36
_hr$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_sample_rate$ = 8					; size = 4
_channels$ = 12						; size = 1
_bits$ = 16						; size = 1
?Initialize@DirectSound@output@audio@@UAEHIEE@Z PROC	; audio::output::DirectSound::Initialize
; _this$ = ecx

; 36   : int DirectSound::Initialize(uint32_t sample_rate, uint8_t channels, uint8_t bits) {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 37   :   last_write_cursor=0xffffffff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], -1

; 38   :   HRESULT hr = DirectSoundCreate8(&DSDEVID_DefaultPlayback,&ds8,nullptr);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	push	OFFSET _DSDEVID_DefaultPlayback
	call	_DirectSoundCreate8@12
	mov	DWORD PTR _hr$[ebp], eax

; 39   :   if (FAILED(hr)) {

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN8@Initialize

; 40   :     Deinitialize();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 41   :     return S_FALSE;

	mov	eax, 1
	jmp	$LN9@Initialize
$LN8@Initialize:

; 42   :   }
; 43   : 
; 44   :   if (window_handle_==nullptr)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN7@Initialize

; 45   :     window_handle_ = app::Application::Current()->display_window().handle();

	call	?Current@Application@app@@SAPAV12@XZ	; app::Application::Current
	mov	ecx, eax
	call	?display_window@Application@app@@QAEAAVDisplayWindow@2@XZ ; app::Application::display_window
	mov	ecx, eax
	call	?handle@Window@windows@core@@QAEPAUHWND__@@XZ ; core::windows::Window::handle
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN7@Initialize:

; 46   :   hr = ds8->SetCooperativeLevel((HWND)window_handle_,DSSCL_PRIORITY);

	mov	esi, esp
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+24]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 47   :   if (FAILED(hr)) {

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN5@Initialize

; 48   :     hr = ds8->SetCooperativeLevel((HWND)window_handle_,DSSCL_NORMAL);  

	mov	esi, esp
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+24]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 49   :     if (FAILED(hr)) {

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN5@Initialize

; 50   :       return S_FALSE;

	mov	eax, 1
	jmp	$LN9@Initialize
$LN5@Initialize:

; 51   :     }
; 52   :   }
; 53   : 
; 54   :   DSBUFFERDESC dsbd;
; 55   : 	ZeroMemory(&dsbd,sizeof(DSBUFFERDESC));

	push	36					; 00000024H
	push	0
	lea	eax, DWORD PTR _dsbd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 56   : 	dsbd.dwSize        = sizeof(DSBUFFERDESC);

	mov	DWORD PTR _dsbd$[ebp], 36		; 00000024H

; 57   : 	dsbd.dwFlags       = DSBCAPS_PRIMARYBUFFER;

	mov	DWORD PTR _dsbd$[ebp+4], 1

; 58   : 	dsbd.dwBufferBytes = 0;

	mov	DWORD PTR _dsbd$[ebp+8], 0

; 59   : 	dsbd.lpwfxFormat   = NULL;

	mov	DWORD PTR _dsbd$[ebp+16], 0

; 60   : 
; 61   : 
; 62   : 	hr = ds8->CreateSoundBuffer(&dsbd,&primary_buffer,nullptr) ;

	mov	esi, esp
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	lea	edx, DWORD PTR _dsbd$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+12]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 63   :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN4@Initialize
	mov	eax, 1
	jmp	$LN9@Initialize
$LN4@Initialize:

; 64   : 
; 65   : 	ZeroMemory( &wave_format_, sizeof(WAVEFORMATEX) ); 

	push	18					; 00000012H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 66   : 	wave_format_.wFormatTag      = (WORD) WAVE_FORMAT_PCM; 

	mov	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+4], cx

; 67   : 	wave_format_.nChannels       =  channels; 

	movzx	ax, BYTE PTR _channels$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+6], ax

; 68   : 	wave_format_.nSamplesPerSec  = sample_rate; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _sample_rate$[ebp]
	mov	DWORD PTR [edx+8], eax

; 69   : 	wave_format_.wBitsPerSample  = (WORD) bits; 

	movzx	cx, BYTE PTR _bits$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+18], cx

; 70   : 	wave_format_.nBlockAlign     = (WORD) ((wave_format_.wBitsPerSample >> 3) * wave_format_.nChannels);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+18]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+6]
	imul	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+16], cx

; 71   : 	wave_format_.nAvgBytesPerSec = (DWORD) (wave_format_.nSamplesPerSec * wave_format_.nBlockAlign);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 72   :   wave_format_.cbSize = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+20], cx

; 73   : 	hr = primary_buffer->SetFormat(&wave_format_);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+56]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 74   :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN3@Initialize
	mov	eax, 1
	jmp	$LN9@Initialize
$LN3@Initialize:

; 75   : 
; 76   : 
; 77   :   if (buffer_size_ == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN2@Initialize

; 78   :     buffer_size_ = uint32_t(wave_format_.nBlockAlign * wave_format_.nSamplesPerSec * 0.4); //400ms

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR tv431[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv431[ebp]
	mov	edx, DWORD PTR tv431[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	mulsd	xmm0, QWORD PTR __real@3fd999999999999a
	movsd	QWORD PTR tv435[ebp], xmm0
	fld	QWORD PTR tv435[ebp]
	fnstcw	WORD PTR tv437[ebp]
	movzx	eax, WORD PTR tv437[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv440[ebp], eax
	fldcw	WORD PTR tv440[ebp]
	fistp	QWORD PTR tv442[ebp]
	fldcw	WORD PTR tv437[ebp]
	mov	eax, DWORD PTR tv442[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax
$LN2@Initialize:

; 79   : 
; 80   : 
; 81   : 	ZeroMemory( &dsbd, sizeof(DSBUFFERDESC) );

	push	36					; 00000024H
	push	0
	lea	edx, DWORD PTR _dsbd$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 82   : 	dsbd.dwSize        = sizeof(DSBUFFERDESC);

	mov	DWORD PTR _dsbd$[ebp], 36		; 00000024H

; 83   : 	dsbd.dwFlags       = DSBCAPS_GLOBALFOCUS | DSBCAPS_GETCURRENTPOSITION2;

	mov	DWORD PTR _dsbd$[ebp+4], 98304		; 00018000H

; 84   : 	dsbd.dwBufferBytes = buffer_size_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _dsbd$[ebp+8], ecx

; 85   : 	dsbd.lpwfxFormat   = &wave_format_;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR _dsbd$[ebp+16], edx

; 86   :   // Create a temporary sound buffer with the specific buffer settings.
; 87   : 	hr = ds8->CreateSoundBuffer(&dsbd, &secondary_buffer, NULL);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	lea	ecx, DWORD PTR _dsbd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+12]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 88   :   if (FAILED(hr)) return S_FALSE;

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Initialize
	mov	eax, 1
	jmp	SHORT $LN9@Initialize
$LN1@Initialize:

; 89   : 
; 90   :     //hr = secondary_buffer->SetVolume(DSBVOLUME_MAX);
; 91   :   //if (FAILED(hr)) return S_FALSE;
; 92   : 
; 93   :   return Play();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@Initialize:

; 94   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@Initialize
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN13@Initialize:
	DD	1
	DD	$LN12@Initialize
$LN12@Initialize:
	DD	-52					; ffffffccH
	DD	36					; 00000024H
	DD	$LN11@Initialize
$LN11@Initialize:
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	98					; 00000062H
	DB	100					; 00000064H
	DB	0
?Initialize@DirectSound@output@audio@@UAEHIEE@Z ENDP	; audio::output::DirectSound::Initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\directsound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DirectSound@output@audio@@QAE@XZ PROC		; audio::output::DirectSound::~DirectSound
; _this$ = ecx

; 32   : DirectSound::~DirectSound() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DirectSound@output@audio@@6B@

; 33   :   Deinitialize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Deinitialize@DirectSound@output@audio@@UAEHXZ ; audio::output::DirectSound::Deinitialize

; 34   : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1DirectSound@output@audio@@QAE@XZ ENDP		; audio::output::DirectSound::~DirectSound
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\gbemu\solution\code\audio\directsound.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DirectSound@output@audio@@QAE@XZ PROC		; audio::output::DirectSound::DirectSound
; _this$ = ecx

; 27   : DirectSound::DirectSound() : last_write_cursor(0),last_cursor_pos(0) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Interface@output@audio@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DirectSound@output@audio@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 0

; 28   :   window_handle_ = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 29   :   buffer_size_ = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 30   : }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0DirectSound@output@audio@@QAE@XZ ENDP		; audio::output::DirectSound::DirectSound
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0Interface@output@audio@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Interface@output@audio@@QAE@XZ PROC			; audio::output::Interface::Interface, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Interface@output@audio@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Interface@output@audio@@QAE@XZ ENDP			; audio::output::Interface::Interface
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\khalid\documents\github\wincore\windows\window.h
;	COMDAT ?handle@Window@windows@core@@QAEPAUHWND__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?handle@Window@windows@core@@QAEPAUHWND__@@XZ PROC	; core::windows::Window::handle, COMDAT
; _this$ = ecx

; 42   :   HWND handle() { return handle_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+576]
	mov	esp, ebp
	pop	ebp
	ret	0
?handle@Window@windows@core@@QAEPAUHWND__@@XZ ENDP	; core::windows::Window::handle
_TEXT	ENDS
END
